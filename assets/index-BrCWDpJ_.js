(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link2);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link2) {
    const fetchOpts = {};
    if (link2.integrity) fetchOpts.integrity = link2.integrity;
    if (link2.referrerPolicy) fetchOpts.referrerPolicy = link2.referrerPolicy;
    if (link2.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link2.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link2) {
    if (link2.ep)
      return;
    link2.ep = true;
    const fetchOpts = getFetchOpts(link2);
    fetch(link2.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$1(a) {
  if (null === a || "object" !== typeof a) return null;
  a = z$1 && a[z$1] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b, e) {
  var d, c = {}, k2 = null, h = null;
  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k2 = "" + b.key), b) J.call(b, d) && !L$1.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g) c.children = e;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++) f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
  return { $$typeof: l$1, type: a, key: k2, ref: h, props: c, _owner: K$1.current };
}
function N$1(a, b) {
  return { $$typeof: l$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$1;
}
function escape$1(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape$1("" + a.key) : b.toString(36);
}
function R$1(a, b, e, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2) a = null;
  var h = false;
  if (null === a) h = true;
  else switch (k2) {
    case "string":
    case "number":
      h = true;
      break;
    case "object":
      switch (a.$$typeof) {
        case l$1:
        case n$1:
          h = true;
      }
  }
  if (h) return h = a, c = c(h), a = "" === d ? "." + Q$1(h, 0) : d, I$1(c) ? (e = "", null != a && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b, e, "", function(a2) {
    return a2;
  })) : null != c && (O$1(c) && (c = N$1(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
  h = 0;
  d = "" === d ? "." : d + ":";
  if (I$1(a)) for (var g = 0; g < a.length; g++) {
    k2 = a[g];
    var f2 = d + Q$1(k2, g);
    h += R$1(k2, b, e, f2, c);
  }
  else if (f2 = A$1(a), "function" === typeof f2) for (a = f2.call(a), g = 0; !(k2 = a.next()).done; ) k2 = k2.value, f2 = d + Q$1(k2, g++), h += R$1(k2, b, e, f2, c);
  else if ("object" === k2) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h;
}
function S$1(a, b, e) {
  if (null == a) return a;
  var d = [], c = 0;
  R$1(a, d, "", "", function(a2) {
    return b.call(e, a2, c++);
  });
  return d;
}
function T$1(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
    }, function(b2) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status) return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
function X$1() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a, b, e) {
  S$1(a, function() {
    b.apply(this, arguments);
  }, e);
}, count: function(a) {
  var b = 0;
  S$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a)) throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$2;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(a, b, e) {
  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$1({}, a.props), c = a.key, k2 = a.ref, h = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k2 = b.ref, h = K$1.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
    for (f2 in b) J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d.children = e;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g[m2] = arguments[m2 + 2];
    d.children = g;
  }
  return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d, _owner: h };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b = M$1.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$1, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: x$1, type: a, compare: void 0 === b ? null : b };
};
react_production_min.startTransition = function(a) {
  var b = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b;
  }
};
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(a, b) {
  return U$1.current.useCallback(a, b);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b) {
  return U$1.current.useEffect(a, b);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b, e) {
  return U$1.current.useImperativeHandle(a, b, e);
};
react_production_min.useInsertionEffect = function(a, b) {
  return U$1.current.useInsertionEffect(a, b);
};
react_production_min.useLayoutEffect = function(a, b) {
  return U$1.current.useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return U$1.current.useMemo(a, b);
};
react_production_min.useReducer = function(a, b, e) {
  return U$1.current.useReducer(a, b, e);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b, e) {
  return U$1.current.useSyncExternalStore(a, b, e);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h = a.ref);
  for (b in a) m$1.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b) {
    var c = a.length;
    a.push(b);
    a: for (; 0 < c; ) {
      var d = c - 1 >>> 1, e = a[d];
      if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
      else break a;
    }
  }
  function h(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length) return null;
    var b = a[0], c = a.pop();
    if (c !== b) {
      a[0] = c;
      a: for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
        var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x = a[n2];
        if (0 > g(C2, c)) n2 < e && 0 > g(x, C2) ? (a[d] = x, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
        else if (n2 < e && 0 > g(x, c)) a[d] = x, a[n2] = c, d = n2;
        else break a;
      }
    }
    return b;
  }
  function g(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b = h(t2); null !== b; ) {
      if (null === b.callback) k2(t2);
      else if (b.startTime <= a) k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
      else break;
      b = h(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2) if (null !== h(r2)) A2 = true, I2(J2);
    else {
      var b = h(t2);
      null !== b && K2(H2, b.startTime - a);
    }
  }
  function J2(a, b) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b);
      for (v2 = h(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
        var d = v2.callback;
        if ("function" === typeof d) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e = d(v2.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e ? v2.callback = e : v2 === h(r2) && k2(r2);
          G2(b);
        } else k2(r2);
        v2 = h(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h(t2);
        null !== m2 && K2(H2, m2.startTime - b);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b = true;
      try {
        b = O2(true, a);
      } finally {
        b ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = y2;
    }
    var c = y2;
    y2 = b;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: u2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), null === h(r2) && a === h(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b = y2;
    return function() {
      var c = y2;
      y2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}
function ha(a, b) {
  ea[a] = b;
  for (a = 0; a < b.length; a++) da.add(b[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a)) return true;
  if (ja.call(la, a)) return false;
  if (ka.test(a)) return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b, c, d) {
  if (null !== c && 0 === c.type) return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d) return false;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
  if (d) return false;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;
    case 4:
      return false === b;
    case 5:
      return isNaN(b);
    case 6:
      return isNaN(b) || 1 > b;
  }
  return false;
}
function v(a, b, c, d, e, f2, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z[a] = new v(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  z[b] = new v(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z[a] = new v(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z[a] = new v(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z[a] = new v(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z[a] = new v(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ra,
    sa
  );
  z[b] = new v(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
});
z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b, c, d) {
  var e = z.hasOwnProperty(b) ? z[b] : null;
  if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign, La;
function Ma(a) {
  if (void 0 === La) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    La = b && b[1] || "";
  }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b) {
  if (!a || Na) return "";
  Na = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b) if (b = function() {
      throw Error();
    }, Object.defineProperty(b.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b, []);
      } catch (l2) {
        var d = l2;
      }
      Reflect.construct(a, [], b);
    } else {
      try {
        b.call();
      } catch (l2) {
        d = l2;
      }
      a.call(b.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && "string" === typeof l2.stack) {
      for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e.length - 1, h = f2.length - 1; 1 <= g && 0 <= h && e[g] !== f2[h]; ) h--;
      for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f2[h]) {
        if (1 !== g || 1 !== h) {
          do
            if (g--, h--, 0 > h || e[g] !== f2[h]) {
              var k2 = "\n" + e[g].replace(" at new ", " at ");
              a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
              return k2;
            }
          while (1 <= g && 0 <= h);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a) switch (a.$$typeof) {
    case Ca:
      return (a.displayName || "Context") + ".Consumer";
    case Ba:
      return (a._context.displayName || "Context") + ".Provider";
    case Da:
      var b = a.render;
      a = a.displayName;
      a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      return a;
    case Ga:
      return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
    case Ha:
      b = a._payload;
      a = a._init;
      try {
        return Qa(a(b));
      } catch (c) {
      }
  }
  return null;
}
function Ra(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b);
    case 8:
      return b === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b) return b.displayName || b.name || null;
      if ("string" === typeof b) return b;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a) return false;
  var b = a._valueTracker;
  if (!b) return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, false);
}
function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value), d = b.type;
  if (null != c) if ("number" === d) {
    if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
  } else a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
  return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b) throw Error(p(92));
      if (eb(c)) {
        if (1 < c.length) throw Error(p(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
    for (; b.firstChild; ) a.appendChild(b.firstChild);
  }
});
function ob(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});
function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}
function sb(a, b) {
  a = a.style;
  for (var c in b) if (b.hasOwnProperty(c)) {
    var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
    "float" === c && (c = "cssFloat");
    d ? a.setProperty(c, e) : a[c] = e;
  }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(p(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
    }
    if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
  }
}
function vb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(p(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb() {
}
var Ib = false;
function Jb(a, b, c) {
  if (Ib) return a(b, c);
  Ib = true;
  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db(c);
  if (null === d) return null;
  c = d[b];
  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;
    default:
      a = false;
  }
  if (a) return null;
  if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
  return c;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a) {
  Lb = false;
}
function Nb(a, b, c, d, e, f2, g, h, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b, c, d, e, f2, g, h, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b, c, d, e, f2, g, h, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b = a, c = a;
  if (a.alternate) for (; b.return; ) b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a) throw Error(p(188));
}
function Yb(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb(a);
    if (null === b) throw Error(p(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (null === e) break;
    var f2 = e.alternate;
    if (null === f2) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f2.child) {
      for (f2 = e.child; f2; ) {
        if (f2 === c) return Xb(e), a;
        if (f2 === d) return Xb(e), b;
        f2 = f2.sibling;
      }
      throw Error(p(188));
    }
    if (c.return !== d.return) c = e, d = f2;
    else {
      for (var g = false, h = e.child; h; ) {
        if (h === c) {
          g = true;
          c = e;
          d = f2;
          break;
        }
        if (h === d) {
          g = true;
          d = e;
          c = f2;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f2.child; h; ) {
          if (h === c) {
            g = true;
            c = f2;
            d = e;
            break;
          }
          if (h === d) {
            g = true;
            d = f2;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g) throw Error(p(189));
      }
    }
    if (c.alternate !== d) throw Error(p(190));
  }
  if (3 !== c.tag) throw Error(p(188));
  return c.stateNode.current === c ? a : b;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag) return a;
  for (a = a.child; null !== a; ) {
    var b = $b(a);
    if (null !== b) return b;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec$1 = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
  } catch (b) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return 0;
  var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
  if (0 !== g) {
    var h = g & ~e;
    0 !== h ? d = tc(h) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
  } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
  if (0 === d) return 0;
  if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240))) return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h = 1 << g, k2 = e[g];
    if (-1 === k2) {
      if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
    } else k2 <= b && (a.expiredLanes |= h);
    f2 &= ~h;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b = [], c = 0; 31 > c; c++) b.push(a);
  return b;
}
function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}
function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e = 31 - oc(c), f2 = 1 << e;
    b[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f2;
  }
}
function Cc(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c; ) {
    var d = 31 - oc(c), e = 1 << d;
    e & b | a[d] & b && (a[d] |= b);
    c &= ~e;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}
function Tc(a, b, c, d, e, f2) {
  if (null === a || a.nativeEvent !== f2) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function Uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d, e), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d, e), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d, e), true;
    case "pointerover":
      var f2 = e.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d, e)), true;
  }
  return false;
}
function Vc(a) {
  var b = Wc(a.target);
  if (null !== b) {
    var c = Vb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = Wb(c), null !== b) {
          a.blockedOn = b;
          Ic(a.priority, function() {
            Gc(c);
          });
          return;
        }
      } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn) return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b(b2) {
    return ad(b2, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);
  for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b, c, d) {
  var e = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd$1(a, b, c, d);
  } finally {
    C = e, cd.transition = f2;
  }
}
function gd(a, b, c, d) {
  var e = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd$1(a, b, c, d);
  } finally {
    C = e, cd.transition = f2;
  }
}
function fd$1(a, b, c, d) {
  if (dd) {
    var e = Yc(a, b, c, d);
    if (null === e) hd(a, b, d, id, c), Sc(a, d);
    else if (Uc(e, a, b, c, d)) d.stopPropagation();
    else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e; ) {
        var f2 = Cb(e);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b, c, d);
        null === f2 && hd(a, b, d, id, c);
        if (f2 === e) break;
        e = f2;
      }
      null !== e && d.stopPropagation();
    } else hd(a, b, d, null, c);
  }
}
var id = null;
function Yc(a, b, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a) if (b = Vb(a), null === b) a = null;
  else if (c = b.tag, 13 === c) {
    a = Wb(b);
    if (null !== a) return a;
    a = null;
  } else if (3 === c) {
    if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
    a = null;
  } else b !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec$1()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++) ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f2 - d]; d++) ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f2, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td$1 = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a) return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b) return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td$1("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re$1(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b)) return a;
}
function ve(a, b) {
  if ("change" === a) return b;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re$1, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}
function Ee(a, b) {
  if ("click" === a) return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b)) return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length) return false;
  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b, e) || !He(a[e], b[e])) return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; ) a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c) a = b.contentWindow;
    else break;
    b = Xa(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(), c = a.focusedElem, d = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) {
      if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e = c.textContent.length, f2 = Math.min(d.start, e);
        d = void 0 === d.end ? f2 : Math.min(d.end, e);
        !a.extend && f2 > d && (e = d, d = f2, f2 = e);
        e = Ke(c, f2);
        var g = Ke(
          c,
          d
        );
        e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
      }
    }
    b = [];
    for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td$1("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a]) return Xe[a];
  if (!We[a]) return a;
  var b = We[a], c;
  for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g], k2 = h.instance, l2 = h.currentTarget;
        h = h.listener;
        if (k2 !== f2 && e.isPropagationStopped()) break a;
        nf(e, h, l2);
        f2 = k2;
      }
      else for (g = 0; g < d.length; g++) {
        h = d[g];
        k2 = h.instance;
        l2 = h.currentTarget;
        h = h.listener;
        if (k2 !== f2 && e.isPropagationStopped()) break a;
        nf(e, h, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, false), c.add(d));
}
function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b2) {
      "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
  }
}
function pf(a, b, c, d) {
  switch (jd(b)) {
    case 1:
      var e = ed;
      break;
    case 4:
      e = gd;
      break;
    default:
      e = fd$1;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
  d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function hd(a, b, c, d, e) {
  var f2 = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
    if (null === d) return;
    var g = d.tag;
    if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;
      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
      if (4 === g) for (g = d.return; null !== g; ) {
        var k2 = g.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e) return;
        }
        g = g.return;
      }
      for (; null !== h; ) {
        g = Wc(h);
        if (null === g) return;
        k2 = g.tag;
        if (5 === k2 || 6 === k2) {
          d = f2 = g;
          continue a;
        }
        h = h.parentNode;
      }
    }
    d = d.return;
  }
  Jb(function() {
    var d2 = f2, e2 = xb(c), g2 = [];
    a: {
      var h2 = df.get(a);
      if (void 0 !== h2) {
        var k3 = td$1, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x = t2 ? null !== h2 ? h2 + "Capture" : null : h2;
        t2 = [];
        for (var w2 = d2, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x && (F2 = Kb(w2, x), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h2 = new k3(h2, n2, null, c, e2), g2.push({ event: h2, listeners: t2 }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h2 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h2 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h2) {
          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d2;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a) t2 = Td, F2 = "onPointerLeave", x = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h2 : ue(k3);
            u2 = null == n2 ? h2 : ue(n2);
            h2 = new t2(F2, w2 + "leave", k3, c, e2);
            h2.target = J2;
            h2.relatedTarget = u2;
            F2 = null;
            Wc(e2) === d2 && (t2 = new t2(x, w2 + "enter", n2, c, e2), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x = vf(x), u2--;
              for (; w2--; ) {
                if (t2 === x || null !== x && t2 === x.alternate) break b;
                t2 = vf(t2);
                x = vf(x);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g2, h2, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h2 = d2 ? ue(d2) : window;
        k3 = h2.nodeName && h2.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h2.type) var na = ve;
        else if (me(h2)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h2.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
        if (na && (na = na(a, d2))) {
          ne(g2, na, c, e2);
          break a;
        }
        xa && xa(a, h2, d2);
        "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
      }
      xa = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var $a;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
    }
    se(g2, b);
  });
}
function tf(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e = a, f2 = e.stateNode;
    5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e)), f2 = Kb(a, b), null != f2 && d.push(tf(a, f2, e)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a) return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d, e) {
  for (var f2 = b._reactName, g = []; null !== c && c !== d; ) {
    var h = c, k2 = h.alternate, l2 = h.stateNode;
    if (null !== k2 && k2 === d) break;
    5 === h.tag && null !== l2 && (h = l2, e ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h))) : e || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h))));
    c = c.return;
  }
  0 !== g.length && a.push({ event: b, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c) throw Error(p(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b) {
  var c = b, d = 0;
  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
      if (0 === d) {
        a.removeChild(e);
        bd(b);
        return;
      }
      d--;
    } else "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e;
  } while (c);
  bd(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b) break;
      if ("/$" === b) return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b = a[Of];
  if (b) return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
        if (c = a[Of]) return c;
        a = Mf(a);
      }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(p(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f2;
  for (f2 in c) e[f2] = b[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b, c) {
  if (H.current !== Vf) throw Error(p(168));
  G(H, b);
  G(Wf, c);
}
function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();
  for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
  return A({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(p(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (null !== d);
      }
      eg = null;
      fg = false;
    } catch (e) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
    } finally {
      C = b, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e = 32 - oc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f2 = 32 - oc(b) + e;
  if (30 < f2) {
    var g = e - e % 5;
    f2 = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e -= g;
    rg = 1 << 32 - oc(b) + e | c << e | d;
    sg = f2 + a;
  } else rg = 1 << f2 | c << e | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a)) throw Error(p(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a)) throw Error(p(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg) return false;
  if (!I) return Fg(a), I = true, false;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a)) throw Hg(), Error(p(418));
    for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(p(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; ) a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag) throw Error(p(309));
        var d = c.stateNode;
      }
      if (!d) throw Error(p(147, a));
      var e = d, f2 = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2) return b.ref;
      b = function(a2) {
        var b2 = e.refs;
        null === a2 ? delete b2[f2] : b2[f2] = a2;
      };
      b._stringRef = f2;
      return b;
    }
    if ("string" !== typeof a) throw Error(p(284));
    if (!c._owner) throw Error(p(290, a));
  }
  return a;
}
function Mg(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function Ng(a) {
  var b = a._init;
  return b(a._payload);
}
function Og(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.deletions;
      null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a) return null;
    for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Pg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d2) {
    b2.index = d2;
    if (!a) return b2.flags |= 1048576, c2;
    d2 = b2.alternate;
    if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
    b2.flags |= 2;
    return c2;
  }
  function g(b2) {
    a && null === b2.alternate && (b2.flags |= 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k2(a2, b2, c2, d2) {
    var f3 = c2.type;
    if (f3 === ya) return m2(a2, b2, c2.props.children, d2, c2.key);
    if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
    d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Lg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function m2(a2, b2, c2, d2, f3) {
    if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f3), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function q2(a2, b2, c2) {
    if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case va:
          return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
        case wa:
          return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
        case Ha:
          var d2 = b2._init;
          return q2(a2, d2(b2._payload), c2);
      }
      if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Mg(a2, b2);
    }
    return null;
  }
  function r2(a2, b2, c2, d2) {
    var e2 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va:
          return c2.key === e2 ? k2(a2, b2, c2, d2) : null;
        case wa:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
        case Ha:
          return e2 = c2._init, r2(
            a2,
            b2,
            e2(c2._payload),
            d2
          );
      }
      if (eb(c2) || Ka(c2)) return null !== e2 ? null : m2(a2, b2, c2, d2, null);
      Mg(a2, c2);
    }
    return null;
  }
  function y2(a2, b2, c2, d2, e2) {
    if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case va:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b2, a2, d2, e2);
        case wa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
        case Ha:
          var f3 = d2._init;
          return y2(a2, b2, c2, f3(d2._payload), e2);
      }
      if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
      Mg(b2, d2);
    }
    return null;
  }
  function n2(e2, g2, h2, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x = null; null !== u2 && w2 < h2.length; w2++) {
      u2.index > w2 ? (x = u2, u2 = null) : x = u2.sibling;
      var n3 = r2(e2, u2, h2[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x);
        break;
      }
      a && u2 && null === n3.alternate && b(e2, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x;
    }
    if (w2 === h2.length) return c(e2, u2), I && tg(e2, w2), l3;
    if (null === u2) {
      for (; w2 < h2.length; w2++) u2 = q2(e2, h2[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e2, w2);
      return l3;
    }
    for (u2 = d(e2, u2); w2 < h2.length; w2++) x = y2(u2, e2, w2, h2[w2], k3), null !== x && (a && null !== x.alternate && u2.delete(null === x.key ? w2 : x.key), g2 = f2(x, g2, w2), null === m3 ? l3 = x : m3.sibling = x, m3 = x);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    I && tg(e2, w2);
    return l3;
  }
  function t2(e2, g2, h2, k3) {
    var l3 = Ka(h2);
    if ("function" !== typeof l3) throw Error(p(150));
    h2 = l3.call(h2);
    if (null == h2) throw Error(p(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x = null, n3 = h2.next(); null !== m3 && !n3.done; w2++, n3 = h2.next()) {
      m3.index > w2 ? (x = m3, m3 = null) : x = m3.sibling;
      var t3 = r2(e2, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x);
        break;
      }
      a && m3 && null === t3.alternate && b(e2, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x;
    }
    if (n3.done) return c(
      e2,
      m3
    ), I && tg(e2, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h2.next()) n3 = q2(e2, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e2, w2);
      return l3;
    }
    for (m3 = d(e2, m3); !n3.done; w2++, n3 = h2.next()) n3 = y2(m3, e2, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b(e2, a2);
    });
    I && tg(e2, w2);
    return l3;
  }
  function J2(a2, d2, f3, h2) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d2; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d2 = e(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e(l3, f3.props);
                  d2.ref = Lg(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else b(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d2 = Tg(f3.props.children, a2.mode, h2, f3.key), d2.return = a2, a2 = d2) : (h2 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f3), h2.return = a2, a2 = h2);
          }
          return g(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d2; ) {
              if (d2.key === l3) if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                c(a2, d2.sibling);
                d2 = e(d2, f3.children || []);
                d2.return = a2;
                a2 = d2;
                break a;
              } else {
                c(a2, d2);
                break;
              }
              else b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Sg(f3, a2.mode, h2);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h2);
      }
      if (eb(f3)) return n2(a2, d2, f3, h2);
      if (Ka(f3)) return t2(a2, d2, f3, h2);
      Mg(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f3, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a) {
  var b = Wg.current;
  E(Wg);
  a._currentValue = b;
}
function bh(a, b, c) {
  for (; null !== a; ) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c) break;
    a = a.return;
  }
}
function ch(a, b) {
  Xg = a;
  Zg = Yg = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
}
function eh(a) {
  var b = a._currentValue;
  if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
    if (null === Xg) throw Error(p(308));
    Yg = a;
    Xg.dependencies = { lanes: 0, firstContext: a };
  } else Yg = Yg.next = a;
  return b;
}
var fh = null;
function gh(a) {
  null === fh ? fh = [a] : fh.push(a);
}
function hh(a, b, c, d) {
  var e = b.interleaved;
  null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
  b.interleaved = c;
  return ih(a, d);
}
function ih(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var jh = false;
function kh(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function mh(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function nh(a, b, c) {
  var d = a.updateQueue;
  if (null === d) return null;
  d = d.shared;
  if (0 !== (K & 2)) {
    var e = d.pending;
    null === e ? b.next = b : (b.next = e.next, e.next = b);
    d.pending = b;
    return ih(a, c);
  }
  e = d.interleaved;
  null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
  d.interleaved = b;
  return ih(a, c);
}
function oh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
function ph(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e = f2 = g : f2 = f2.next = g;
        c = c.next;
      } while (null !== c);
      null === f2 ? e = f2 = b : f2 = f2.next = b;
    } else e = f2 = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function qh(a, b, c, d) {
  var e = a.updateQueue;
  jh = false;
  var f2 = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
  if (null !== h) {
    e.shared.pending = null;
    var k2 = h, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h = m2.lastBaseUpdate, h !== g && (null === h ? m2.firstBaseUpdate = l2 : h.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h = f2;
    do {
      var r2 = h.lane, y2 = h.eventTime;
      if ((d & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h.tag,
          payload: h.payload,
          callback: h.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h;
          r2 = b;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
      } else y2 = { eventTime: y2, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h = h.next;
      if (null === h) if (h = e.shared.pending, null === h) break;
      else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e.baseState = k2;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = m2;
    b = e.shared.interleaved;
    if (null !== b) {
      e = b;
      do
        g |= e.lane, e = e.next;
      while (e !== b);
    } else null === f2 && (e.shared.lanes = 0);
    rh |= g;
    a.lanes = g;
    a.memoizedState = q2;
  }
}
function sh(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b], e = d.callback;
    if (null !== e) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e) throw Error(p(191, e));
      e.call(d);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a) {
  if (a === th) throw Error(p(174));
  return a;
}
function yh(a, b) {
  G(wh, b);
  G(vh, a);
  G(uh, th);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }
  E(uh);
  G(uh, b);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a) {
  xh(wh.current);
  var b = xh(uh.current);
  var c = lb(b, a.type);
  b !== c && (G(vh, a), G(uh, c));
}
function Bh(a) {
  vh.current === a && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128)) return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a) break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a) return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P() {
  throw Error(p(321));
}
function Mh(a, b) {
  if (null === b) return false;
  for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
  return true;
}
function Nh(a, b, c, d, e, f2) {
  Hh = f2;
  M = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
  a = c(d, e);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p(301));
      f2 += 1;
      O = N = null;
      b.updateQueue = null;
      Fh.current = Qh;
      a = c(d, e);
    } while (Jh);
  }
  Fh.current = Rh;
  b = null !== N && null !== N.next;
  Hh = 0;
  O = N = M = null;
  Ih = false;
  if (b) throw Error(p(300));
  return a;
}
function Sh() {
  var a = 0 !== Kh;
  Kh = 0;
  return a;
}
function Th() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M.memoizedState = O = a : O = O.next = a;
  return O;
}
function Uh() {
  if (null === N) {
    var a = M.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = N.next;
  var b = null === O ? M.memoizedState : O.next;
  if (null !== b) O = b, N = a;
  else {
    if (null === a) throw Error(p(310));
    N = a;
    a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
  }
  return O;
}
function Vh(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function Wh(a) {
  var b = Uh(), c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = N, e = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e) {
      var g = e.next;
      e.next = f2.next;
      f2.next = g;
    }
    d.baseQueue = e = f2;
    c.pending = null;
  }
  if (null !== e) {
    f2 = e.next;
    d = d.baseState;
    var h = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h = k2 = q2, g = d) : k2 = k2.next = q2;
        M.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d : k2.next = h;
    He(d, b.memoizedState) || (dh = true);
    b.memoizedState = d;
    b.baseState = g;
    b.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e = a;
    do
      f2 = e.lane, M.lanes |= f2, rh |= f2, e = e.next;
    while (e !== a);
  } else null === e && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function Xh(a) {
  var b = Uh(), c = b.queue;
  if (null === c) throw Error(p(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g = e = e.next;
    do
      f2 = a(f2, g.action), g = g.next;
    while (g !== e);
    He(f2, b.memoizedState) || (dh = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function Yh() {
}
function Zh(a, b) {
  var c = M, d = Uh(), e = b(), f2 = !He(d.memoizedState, e);
  f2 && (d.memoizedState = e, dh = true);
  d = d.queue;
  $h(ai.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b || f2 || null !== O && O.memoizedState.tag & 1) {
    c.flags |= 2048;
    bi(9, ci.bind(null, c, d, e, b), void 0, null);
    if (null === Q) throw Error(p(349));
    0 !== (Hh & 30) || di(c, b, e);
  }
  return e;
}
function di(a, b, c) {
  a.flags |= 16384;
  a = { getSnapshot: b, value: c };
  b = M.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function ci(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  ei(b) && fi(a);
}
function ai(a, b, c) {
  return c(function() {
    ei(b) && fi(a);
  });
}
function ei(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return true;
  }
}
function fi(a) {
  var b = ih(a, 1);
  null !== b && gi(b, a, 1, -1);
}
function hi(a) {
  var b = Th();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
  b.queue = a;
  a = a.dispatch = ii.bind(null, M, a);
  return [b.memoizedState, a];
}
function bi(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = M.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a, b, c, d) {
  var e = Th();
  M.flags |= a;
  e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
}
function li(a, b, c, d) {
  var e = Uh();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== N) {
    var g = N.memoizedState;
    f2 = g.destroy;
    if (null !== d && Mh(d, g.deps)) {
      e.memoizedState = bi(b, c, f2, d);
      return;
    }
  }
  M.flags |= a;
  e.memoizedState = bi(1 | b, c, f2, d);
}
function mi(a, b) {
  return ki(8390656, 8, a, b);
}
function $h(a, b) {
  return li(2048, 8, a, b);
}
function ni(a, b) {
  return li(4, 2, a, b);
}
function oi(a, b) {
  return li(4, 4, a, b);
}
function pi(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function() {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
    b.current = null;
  };
}
function qi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return li(4, 4, pi.bind(null, b, a), c);
}
function ri() {
}
function si(a, b) {
  var c = Uh();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Mh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ti(a, b) {
  var c = Uh();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Mh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function ui(a, b, c) {
  if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
  He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
  return b;
}
function vi(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d = Gh.transition;
  Gh.transition = {};
  try {
    a(false), b();
  } finally {
    C = c, Gh.transition = d;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a, b, c) {
  var d = yi(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b, c);
  else if (c = hh(a, b, c, d), null !== c) {
    var e = R();
    gi(c, a, d, e);
    Bi(c, b, d);
  }
}
function ii(a, b, c) {
  var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (zi(a)) Ai(b, e);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2)) try {
      var g = b.lastRenderedState, h = f2(g, c);
      e.hasEagerState = true;
      e.eagerState = h;
      if (He(h, g)) {
        var k2 = b.interleaved;
        null === k2 ? (e.next = e, gh(b)) : (e.next = k2.next, k2.next = e);
        b.interleaved = e;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c = hh(a, b, e, d);
    null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
  }
}
function zi(a) {
  var b = a.alternate;
  return a === M || null !== b && b === M;
}
function Ai(a, b) {
  Jh = Ih = true;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Bi(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
  Th().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b, a),
    c
  );
}, useLayoutEffect: function(a, b) {
  return ki(4194308, 4, a, b);
}, useInsertionEffect: function(a, b) {
  return ki(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Th();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Th();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  d.queue = a;
  a = a.dispatch = xi.bind(null, M, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b = Th();
  a = { current: a };
  return b.memoizedState = a;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
  return Th().memoizedState = a;
}, useTransition: function() {
  var a = hi(false), b = a[0];
  a = vi.bind(null, a[1]);
  Th().memoizedState = a;
  return [b, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b, c) {
  var d = M, e = Th();
  if (I) {
    if (void 0 === c) throw Error(p(407));
    c = c();
  } else {
    c = b();
    if (null === Q) throw Error(p(349));
    0 !== (Hh & 30) || di(d, b, c);
  }
  e.memoizedState = c;
  var f2 = { value: c, getSnapshot: b };
  e.queue = f2;
  mi(ai.bind(
    null,
    d,
    f2,
    a
  ), [a]);
  d.flags |= 2048;
  bi(9, ci.bind(null, d, f2, c, b), void 0, null);
  return c;
}, useId: function() {
  var a = Th(), b = Q.identifierPrefix;
  if (I) {
    var c = sg;
    var d = rg;
    c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
    b = ":" + b + "R" + c;
    c = Kh++;
    0 < c && (b += "H" + c.toString(32));
    b += ":";
  } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
  return a.memoizedState = b;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a) {
    var b = Uh();
    return ui(b, N.memoizedState, a);
  },
  useTransition: function() {
    var a = Wh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a) {
  var b = Uh();
  return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
}, useTransition: function() {
  var a = Xh(Vh)[0], b = Uh().memoizedState;
  return [a, b];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a, b) {
  if (a && a.defaultProps) {
    b = A({}, b);
    a = a.defaultProps;
    for (var c in a) void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
function Di(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var Ei = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = R(), e = yi(a), f2 = mh(d, e);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = nh(a, f2, e);
  null !== b && (gi(b, a, e, d), oh(b, a, e));
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = R(), e = yi(a), f2 = mh(d, e);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = nh(a, f2, e);
  null !== b && (gi(b, a, e, d), oh(b, a, e));
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = R(), d = yi(a), e = mh(c, d);
  e.tag = 2;
  void 0 !== b && null !== b && (e.callback = b);
  b = nh(a, e, d);
  null !== b && (gi(b, a, d, c), oh(b, a, d));
} };
function Fi(a, b, c, d, e, f2, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f2) : true;
}
function Gi(a, b, c) {
  var d = false, e = Vf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Ei;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function Hi(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
}
function Ii(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = {};
  kh(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e.context = eh(f2) : (f2 = Zf(b) ? Xf : H.current, e.context = Yf(a, f2));
  e.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a, b, f2, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4194308);
}
function Ji(a, b) {
  try {
    var c = "", d = b;
    do
      c += Pa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f2) {
    e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e, digest: null };
}
function Ki(a, b, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
}
function Li(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a, b, c) {
  c = mh(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Oi || (Oi = true, Pi = d);
    Li(a, b);
  };
  return c;
}
function Qi(a, b, c) {
  c = mh(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function() {
      return d(e);
    };
    c.callback = function() {
      Li(a, b);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Li(a, b);
    "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Si(a, b, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Mi();
    var e = /* @__PURE__ */ new Set();
    d.set(b, e);
  } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
  e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
}
function Ui(a) {
  do {
    var b;
    if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
    if (b) return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Vi(a, b, c, d, e) {
  if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a, b, c, d) {
  b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
}
function Yi(a, b, c, d, e) {
  c = c.render;
  var f2 = b.ref;
  ch(b, e);
  d = Nh(a, b, c, d, f2, e);
  c = Sh();
  if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
  I && c && vg(b);
  b.flags |= 1;
  Xi(a, b, d, e);
  return b.child;
}
function $i(a, b, c, d, e) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f2, bj(a, b, f2, d, e);
    a = Rg(c.type, null, d, b, b.mode, e);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e)) {
    var g = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
  }
  b.flags |= 1;
  a = Pg(f2, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function bj(a, b, c, d, e) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f2, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
    else return b.lanes = a.lanes, Zi(a, b, e);
  }
  return cj(a, b, c, d, e);
}
function dj(a, b, c) {
  var d = b.pendingProps, e = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
  else {
    if (0 === (c & 1073741824)) return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
    b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d = null !== f2 ? f2.baseLanes : c;
    G(ej, fj);
    fj |= d;
  }
  else null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
  Xi(a, b, e, c);
  return b.child;
}
function gj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
}
function cj(a, b, c, d, e) {
  var f2 = Zf(c) ? Xf : H.current;
  f2 = Yf(b, f2);
  ch(b, e);
  c = Nh(a, b, c, d, f2, e);
  d = Sh();
  if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
  I && d && vg(b);
  b.flags |= 1;
  Xi(a, b, c, e);
  return b.child;
}
function hj(a, b, c, d, e) {
  if (Zf(c)) {
    var f2 = true;
    cg(b);
  } else f2 = false;
  ch(b, e);
  if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
  else if (null === a) {
    var g = b.stateNode, h = b.memoizedProps;
    g.props = h;
    var k2 = g.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k2 !== l2) && Hi(b, g, d, l2);
    jh = false;
    var r2 = b.memoizedState;
    g.state = r2;
    qh(b, d, g, e);
    k2 = b.memoizedState;
    h !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c, m2, d), k2 = b.memoizedState), (h = jh || Fi(b, c, h, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
  } else {
    g = b.stateNode;
    lh(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : Ci(b.type, h);
    g.props = l2;
    q2 = b.pendingProps;
    r2 = g.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q2 || r2 !== k2) && Hi(b, g, d, k2);
    jh = false;
    r2 = b.memoizedState;
    g.state = r2;
    qh(b, d, g, e);
    var n2 = b.memoizedState;
    h !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c, y2, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
  }
  return jj(a, b, c, d, f2, e);
}
function jj(a, b, c, d, e, f2) {
  gj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d && !g) return e && dg(b, c, false), Zi(a, b, f2);
  d = b.stateNode;
  Wi.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Ug(b, a.child, null, f2), b.child = Ug(b, null, h, f2)) : Xi(a, b, h, f2);
  b.memoizedState = d.state;
  e && dg(b, c, true);
  return b.child;
}
function kj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
  yh(a, b.containerInfo);
}
function lj(a, b, c, d, e) {
  Ig();
  Jg(e);
  b.flags |= 256;
  Xi(a, b, c, d);
  return b.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function oj(a, b, c) {
  var d = b.pendingProps, e = L.current, f2 = false, g = 0 !== (b.flags & 128), h;
  (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
  if (h) f2 = true, b.flags &= -129;
  else if (null === a || null !== a.memoizedState) e |= 1;
  G(L, e & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f2 ? (d = b.mode, f2 = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = pj(g, d, 0, null), a = Tg(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
  }
  e = a.memoizedState;
  if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
  if (f2) {
    f2 = d.fallback;
    g = b.mode;
    e = a.child;
    h = e.sibling;
    var k2 = { mode: "hidden", children: d.children };
    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064);
    null !== h ? f2 = Pg(h, f2) : (f2 = Tg(f2, g, c, null), f2.flags |= 2);
    f2.return = b;
    d.return = b;
    d.sibling = f2;
    b.child = d;
    d = f2;
    f2 = b.child;
    g = a.child.memoizedState;
    g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a.childLanes & ~c;
    b.memoizedState = mj;
    return d;
  }
  f2 = a.child;
  a = f2.sibling;
  d = Pg(f2, { mode: "visible", children: d.children });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}
function qj(a, b) {
  b = pj({ mode: "visible", children: b }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function sj(a, b, c, d) {
  null !== d && Jg(d);
  Ug(b, a.child, null, c);
  a = qj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function rj(a, b, c, d, e, f2, g) {
  if (c) {
    if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
    if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
    f2 = d.fallback;
    e = b.mode;
    d = pj({ mode: "visible", children: d.children }, e, 0, null);
    f2 = Tg(f2, e, g, null);
    f2.flags |= 2;
    d.return = b;
    f2.return = b;
    d.sibling = f2;
    b.child = d;
    0 !== (b.mode & 1) && Ug(b, a.child, null, g);
    b.child.memoizedState = nj(g);
    b.memoizedState = mj;
    return f2;
  }
  if (0 === (b.mode & 1)) return sj(a, b, g, null);
  if ("$!" === e.data) {
    d = e.nextSibling && e.nextSibling.dataset;
    if (d) var h = d.dgst;
    d = h;
    f2 = Error(p(419));
    d = Ki(f2, d, void 0);
    return sj(a, b, g, d);
  }
  h = 0 !== (g & a.childLanes);
  if (dh || h) {
    d = Q;
    if (null !== d) {
      switch (g & -g) {
        case 4:
          e = 2;
          break;
        case 16:
          e = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e = 32;
          break;
        case 536870912:
          e = 268435456;
          break;
        default:
          e = 0;
      }
      e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
      0 !== e && e !== f2.retryLane && (f2.retryLane = e, ih(a, e), gi(d, a, e, -1));
    }
    tj();
    d = Ki(Error(p(421)));
    return sj(a, b, g, d);
  }
  if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
  a = f2.treeContext;
  yg = Lf(e.nextSibling);
  xg = b;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = qj(b, d.children);
  b.flags |= 4096;
  return b;
}
function vj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  bh(a.return, b, c);
}
function wj(a, b, c, d, e) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
}
function xj(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
  Xi(a, b, d.children, c);
  d = L.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
      if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
      else if (19 === a.tag) vj(a, c, b);
      else if (null !== a.child) {
        a.child.return = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;
      for (; null === a.sibling; ) {
        if (null === a.return || a.return === b) break a;
        a = a.return;
      }
      a.sibling.return = a.return;
      a = a.sibling;
    }
    d &= 1;
  }
  G(L, d);
  if (0 === (b.mode & 1)) b.memoizedState = null;
  else switch (e) {
    case "forwards":
      c = b.child;
      for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
      c = e;
      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
      wj(b, false, e, c, f2);
      break;
    case "backwards":
      c = null;
      e = b.child;
      for (b.child = null; null !== e; ) {
        a = e.alternate;
        if (null !== a && null === Ch(a)) {
          b.child = e;
          break;
        }
        a = e.sibling;
        e.sibling = c;
        c = e;
        e = a;
      }
      wj(b, true, c, null, f2);
      break;
    case "together":
      wj(b, false, null, null, void 0);
      break;
    default:
      b.memoizedState = null;
  }
  return b.child;
}
function ij(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function Zi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  rh |= b.lanes;
  if (0 === (c & b.childLanes)) return null;
  if (null !== a && b.child !== a.child) throw Error(p(153));
  if (null !== b.child) {
    a = b.child;
    c = Pg(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function yj(a, b, c) {
  switch (b.tag) {
    case 3:
      kj(b);
      Ig();
      break;
    case 5:
      Ah(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      yh(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d = b.type._context, e = b.memoizedProps.value;
      G(Wg, d._currentValue);
      d._currentValue = e;
      break;
    case 13:
      d = b.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
        G(L, L.current & 1);
        a = Zi(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d) return xj(a, b, c);
        b.flags |= 128;
      }
      e = b.memoizedState;
      null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(L, L.current);
      if (d) break;
      else return null;
    case 22:
    case 23:
      return b.lanes = 0, dj(a, b, c);
  }
  return Zi(a, b, c);
}
var zj, Aj, Bj, Cj;
zj = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b) break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b) return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Aj = function() {
};
Bj = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f2 = [];
        break;
      case "select":
        e = A({}, e, { value: void 0 });
        d = A({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g;
    c = null;
    for (l2 in e) if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2]) if ("style" === l2) {
      var h = e[l2];
      for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h = null != e ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h && (null != k2 || null != h)) if ("style" === l2) if (h) {
        for (g in h) !h.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
        for (g in k2) k2.hasOwnProperty(g) && h[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
      } else c || (f2 || (f2 = []), f2.push(
        l2,
        c
      )), c = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h = h ? h.__html : void 0, null != k2 && h !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b.updateQueue = l2) b.flags |= 4;
  }
};
Cj = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Dj(a, b) {
  if (!I) switch (a.tailMode) {
    case "hidden":
      b = a.tail;
      for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
      null === c ? a.tail = null : c.sibling = null;
      break;
    case "collapsed":
      c = a.tail;
      for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}
function S(a) {
  var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
  if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
  else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}
function Ej(a, b, c) {
  var d = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b), null;
    case 1:
      return Zf(b.type) && $f(), S(b), null;
    case 3:
      d = b.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a, b);
      S(b);
      return null;
    case 5:
      Bh(b);
      var e = xh(wh.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      else {
        if (!d) {
          if (null === b.stateNode) throw Error(p(166));
          S(b);
          return null;
        }
        a = xh(uh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f2;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e = 0; e < lf.length; e++) D(lf[e], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d
              );
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Za(d, f2);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d);
              break;
            case "textarea":
              hb(d, f2), D("invalid", d);
          }
          ub(c, f2);
          e = null;
          for (var g in f2) if (f2.hasOwnProperty(g)) {
            var h = f2[g];
            "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f2.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f2.suppressHydrationWarning && Af(
              d.textContent,
              h,
              a
            ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
          }
          switch (c) {
            case "input":
              Va(d);
              db(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = Bf);
          }
          d = e;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          zj(a, b, false, false);
          b.stateNode = a;
          a: {
            g = vb(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], a);
                e = d;
                break;
              case "source":
                D("error", a);
                e = d;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e = d;
                break;
              case "details":
                D("toggle", a);
                e = d;
                break;
              case "input":
                Za(a, d);
                e = Ya(a, d);
                D("invalid", a);
                break;
              case "option":
                e = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e = A({}, d, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e = gb(a, d);
                D("invalid", a);
                break;
              default:
                e = d;
            }
            ub(c, e);
            h = e;
            for (f2 in h) if (h.hasOwnProperty(f2)) {
              var k2 = h[f2];
              "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
            }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                  a,
                  !!d.multiple,
                  d.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S(b);
      return null;
    case 6:
      if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
        c = xh(wh.current);
        xh(uh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f2 = d.nodeValue !== c) {
            if (a = xg, null !== a) switch (a.tag) {
              case 3:
                Af(d.nodeValue, c, 0 !== (a.mode & 1));
                break;
              case 5:
                true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
            }
          }
          f2 && (b.flags |= 4);
        } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S(b);
      return null;
    case 13:
      E(L);
      d = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f2 = false;
        else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f2) throw Error(p(318));
            f2 = b.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p(317));
            f2[Of] = b;
          } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S(b);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128)) return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b.updateQueue && (b.flags |= 4);
      S(b);
      return null;
    case 4:
      return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
    case 10:
      return ah(b.type._context), S(b), null;
    case 17:
      return Zf(b.type) && $f(), S(b), null;
    case 19:
      E(L);
      f2 = b.memoizedState;
      if (null === f2) return S(b), null;
      d = 0 !== (b.flags & 128);
      g = f2.rendering;
      if (null === g) if (d) Dj(f2, false);
      else {
        if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
          g = Ch(a);
          if (null !== g) {
            b.flags |= 128;
            Dj(f2, false);
            d = g.updateQueue;
            null !== d && (b.updateQueue = d, b.flags |= 4);
            b.subtreeFlags = 0;
            d = c;
            for (c = b.child; null !== c; ) f2 = c, a = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
            G(L, L.current & 1 | 2);
            return b.child;
          }
          a = a.sibling;
        }
        null !== f2.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
      }
      else {
        if (!d) if (a = Ch(g), null !== a) {
          if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I) return S(b), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f2.last, null !== c ? c.sibling = g : b.child = g, f2.last = g);
      }
      if (null !== f2.tail) return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
      S(b);
      return null;
    case 22:
    case 23:
      return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p(156, b.tag));
}
function Ij(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Bh(b), null;
    case 13:
      E(L);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate) throw Error(p(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Lj(a, b) {
  var c = a.ref;
  if (null !== c) if ("function" === typeof c) try {
    c(null);
  } catch (d) {
    W(a, b, d);
  }
  else c.current = null;
}
function Mj(a, b, c) {
  try {
    c();
  } catch (d) {
    W(a, b, d);
  }
}
var Nj = false;
function Oj(a, b) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
    else a: {
      c = (c = a.ownerDocument) && c.defaultView || window;
      var d = c.getSelection && c.getSelection();
      if (d && 0 !== d.rangeCount) {
        c = d.anchorNode;
        var e = d.anchorOffset, f2 = d.focusNode;
        d = d.focusOffset;
        try {
          c.nodeType, f2.nodeType;
        } catch (F2) {
          c = null;
          break a;
        }
        var g = 0, h = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c || 0 !== e && 3 !== q2.nodeType || (h = g + e);
            q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
            3 === q2.nodeType && (g += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a) break b;
            r2 === c && ++l2 === e && (h = g);
            r2 === f2 && ++m2 === d && (k2 = g);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c = -1 === h || -1 === k2 ? null : { start: h, end: k2 };
      } else c = null;
    }
    c = c || { start: 0, end: 0 };
  } else c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd = false;
  for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
  else for (; null !== V; ) {
    b = V;
    try {
      var n2 = b.alternate;
      if (0 !== (b.flags & 1024)) switch (b.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x = b.stateNode, w2 = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J2);
            x.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p(163));
      }
    } catch (F2) {
      W(b, b.return, F2);
    }
    a = b.sibling;
    if (null !== a) {
      a.return = b.return;
      V = a;
      break;
    }
    V = b.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e = d = d.next;
    do {
      if ((e.tag & a) === a) {
        var f2 = e.destroy;
        e.destroy = void 0;
        void 0 !== f2 && Mj(b, c, f2);
      }
      e = e.next;
    } while (e !== d);
  }
}
function Qj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Rj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Sj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Sj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Tj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Uj(a) {
  a: for (; ; ) {
    for (; null === a.sibling; ) {
      if (null === a.return || Tj(a.return)) return null;
      a = a.return;
    }
    a.sibling.return = a.return;
    for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
      if (a.flags & 2) continue a;
      if (null === a.child || 4 === a.tag) continue a;
      else a.child.return = a, a = a.child;
    }
    if (!(a.flags & 2)) return a.stateNode;
  }
}
function Vj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
  else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
}
function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
}
var X = null, Xj = false;
function Yj(a, b, c) {
  for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
}
function Zj(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c);
  } catch (h) {
  }
  switch (c.tag) {
    case 5:
      U || Lj(c, b);
    case 6:
      var d = X, e = Xj;
      X = null;
      Yj(a, b, c);
      X = d;
      Xj = e;
      null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;
    case 18:
      null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;
    case 4:
      d = X;
      e = Xj;
      X = c.stateNode.containerInfo;
      Xj = true;
      Yj(a, b, c);
      X = d;
      Xj = e;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e = d = d.next;
        do {
          var f2 = e, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Mj(c, b, g) : 0 !== (f2 & 4) && Mj(c, b, g));
          e = e.next;
        } while (e !== d);
      }
      Yj(a, b, c);
      break;
    case 1:
      if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
        d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
      } catch (h) {
        W(c, b, h);
      }
      Yj(a, b, c);
      break;
    case 21:
      Yj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
      break;
    default:
      Yj(a, b, c);
  }
}
function ak(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Kj());
    b.forEach(function(b2) {
      var d = bk.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function ck(a, b) {
  var c = b.deletions;
  if (null !== c) for (var d = 0; d < c.length; d++) {
    var e = c[d];
    try {
      var f2 = a, g = b, h = g;
      a: for (; null !== h; ) {
        switch (h.tag) {
          case 5:
            X = h.stateNode;
            Xj = false;
            break a;
          case 3:
            X = h.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X = h.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h = h.return;
      }
      if (null === X) throw Error(p(160));
      Zj(f2, g, e);
      X = null;
      Xj = false;
      var k2 = e.alternate;
      null !== k2 && (k2.return = null);
      e.return = null;
    } catch (l2) {
      W(e, b, l2);
    }
  }
  if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
}
function dk(a, b) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b, a);
      ek(a);
      if (d & 4) {
        try {
          Pj(3, a, a.return), Qj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Pj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      ck(b, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      break;
    case 5:
      ck(b, a);
      ek(a);
      d & 512 && null !== c && Lj(c, c.return);
      if (a.flags & 32) {
        var e = a.stateNode;
        try {
          ob(e, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d & 4 && (e = a.stateNode, null != e)) {
        var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2) try {
          "input" === h && "radio" === f2.type && null != f2.name && ab(e, f2);
          vb(h, g);
          var l2 = vb(h, f2);
          for (g = 0; g < k2.length; g += 2) {
            var m2 = k2[g], q2 = k2[g + 1];
            "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
          }
          switch (h) {
            case "input":
              bb(e, f2);
              break;
            case "textarea":
              ib(e, f2);
              break;
            case "select":
              var r2 = e._wrapperState.wasMultiple;
              e._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e[Pf] = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 6:
      ck(b, a);
      ek(a);
      if (d & 4) {
        if (null === a.stateNode) throw Error(p(162));
        e = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      ck(b, a);
      ek(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
        bd(b.containerInfo);
      } catch (t2) {
        W(a, a.return, t2);
      }
      break;
    case 4:
      ck(b, a);
      ek(a);
      break;
    case 13:
      ck(b, a);
      ek(a);
      e = a.child;
      e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
      d & 4 && ak(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, ck(b, a), U = l2) : ck(b, a);
      ek(a);
      if (d & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1)) for (V = a, m2 = a.child; null !== m2; ) {
          for (q2 = V = m2; null !== V; ) {
            r2 = V;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d = r2;
                  c = r2.return;
                  try {
                    b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d, c, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h.style.display = rb("display", g));
              } catch (t2) {
                W(a, a.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a, a.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b, a);
      ek(a);
      d & 4 && ak(a);
      break;
    case 21:
      break;
    default:
      ck(
        b,
        a
      ), ek(a);
  }
}
function ek(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Tj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p(160));
      }
      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (ob(e, ""), d.flags &= -33);
          var f2 = Uj(a);
          Wj(a, f2, e);
          break;
        case 3:
        case 4:
          var g = d.stateNode.containerInfo, h = Uj(a);
          Vj(a, h, g);
          break;
        default:
          throw Error(p(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function hk(a, b, c) {
  V = a;
  ik(a);
}
function ik(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V; ) {
    var e = V, f2 = e.child;
    if (22 === e.tag && d) {
      var g = null !== e.memoizedState || Jj;
      if (!g) {
        var h = e.alternate, k2 = null !== h && null !== h.memoizedState || U;
        h = Jj;
        var l2 = U;
        Jj = g;
        if ((U = k2) && !l2) for (V = e; null !== V; ) g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k2 ? (k2.return = g, V = k2) : jk(e);
        for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
        V = e;
        Jj = h;
        U = l2;
      }
      kk(a);
    } else 0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : kk(a);
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b = V;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            U || Qj(5, b);
            break;
          case 1:
            var d = b.stateNode;
            if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
            else {
              var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
              d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b.updateQueue;
            null !== f2 && sh(b, f2, d);
            break;
          case 3:
            var g = b.updateQueue;
            if (null !== g) {
              c = null;
              if (null !== b.child) switch (b.child.tag) {
                case 5:
                  c = b.child.stateNode;
                  break;
                case 1:
                  c = b.child.stateNode;
              }
              sh(b, g, c);
            }
            break;
          case 5:
            var h = b.stateNode;
            if (null === c && b.flags & 4) {
              c = h;
              var k2 = b.memoizedProps;
              switch (b.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c.focus();
                  break;
                case "img":
                  k2.src && (c.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b.memoizedState) {
              var l2 = b.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p(163));
        }
        U || b.flags & 512 && Rj(b);
      } catch (r2) {
        W(b, b.return, r2);
      }
    }
    if (b === a) {
      V = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function gk(a) {
  for (; null !== V; ) {
    var b = V;
    if (b === a) {
      V = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function jk(a) {
  for (; null !== V; ) {
    var b = V;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Qj(4, b);
          } catch (k2) {
            W(b, c, k2);
          }
          break;
        case 1:
          var d = b.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e = b.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              W(b, e, k2);
            }
          }
          var f2 = b.return;
          try {
            Rj(b);
          } catch (k2) {
            W(b, f2, k2);
          }
          break;
        case 5:
          var g = b.return;
          try {
            Rj(b);
          } catch (k2) {
            W(b, g, k2);
          }
      }
    } catch (k2) {
      W(b, b.return, k2);
    }
    if (b === a) {
      V = null;
      break;
    }
    var h = b.sibling;
    if (null !== h) {
      h.return = b.return;
      V = h;
      break;
    }
    V = b.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok$2 = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a) {
  if (0 === (a.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a = C;
  if (0 !== a) return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function gi(a, b, c, d) {
  if (50 < yk) throw yk = 0, zk = null, Error(p(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d = uc(a, a === Q ? Z : 0);
  if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
      0 === (K & 6) && jg();
    }), c = null;
    else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Fk(c, Gk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Gk(a, b) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p(327));
  var c = a.callbackNode;
  if (Hk() && a.callbackNode !== c) return null;
  var d = uc(a, a === Q ? Z : 0);
  if (0 === d) return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
  else {
    b = d;
    var e = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
    do
      try {
        Lk();
        break;
      } catch (h) {
        Mk(a, h);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e;
    null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
  }
  if (0 !== b) {
    2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
    if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
    if (6 === b) Ck(a, d);
    else {
      e = a.current.alternate;
      if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f2 = xc(a), 0 !== f2 && (d = f2, b = Nk(a, f2))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;
      switch (b) {
        case 0:
        case 1:
          throw Error(p(345));
        case 2:
          Pk(a, tk, uk);
          break;
        case 3:
          Ck(a, d);
          if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0)) break;
            e = a.suspendedLanes;
            if ((e & d) !== d) {
              R();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 4:
          Ck(a, d);
          if ((d & 4194240) === d) break;
          b = a.eventTimes;
          for (e = -1; 0 < d; ) {
            var g = 31 - oc(d);
            f2 = 1 << g;
            g = b[g];
            g > e && (e = g);
            d &= ~f2;
          }
          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
            break;
          }
          Pk(a, tk, uk);
          break;
        case 5:
          Pk(a, tk, uk);
          break;
        default:
          throw Error(p(329));
      }
    }
  }
  Dk(a, B());
  return a.callbackNode === c ? Gk.bind(null, a) : null;
}
function Nk(a, b) {
  var c = sk;
  a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
  a = Ik(a, b);
  2 !== a && (b = tk, tk = c, null !== b && Fj(b));
  return a;
}
function Fj(a) {
  null === tk ? tk = a : tk.push.apply(tk, a);
}
function Ok(a) {
  for (var b = a; ; ) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
        var e = c[d], f2 = e.getSnapshot;
        e = e.value;
        try {
          if (!He(f2(), e)) return false;
        } catch (g) {
          return false;
        }
      }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
    else {
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return true;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return true;
}
function Ck(a, b) {
  b &= ~rk;
  b &= ~qk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - oc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Ek(a) {
  if (0 !== (K & 6)) throw Error(p(327));
  Hk();
  var b = uc(a, 0);
  if (0 === (b & 1)) return Dk(a, B()), null;
  var c = Ik(a, b);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b = d, c = Nk(a, d));
  }
  if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
  if (6 === c) throw Error(p(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Pk(a, tk, uk);
  Dk(a, B());
  return null;
}
function Qk(a, b) {
  var c = K;
  K |= 1;
  try {
    return a(b);
  } finally {
    K = c, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b = K;
  K |= 1;
  var c = ok$2.transition, d = C;
  try {
    if (ok$2.transition = null, C = 1, a) return a();
  } finally {
    C = d, ok$2.transition = c, K = b, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y) for (c = Y.return; null !== c; ) {
    var d = c;
    wg(d);
    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c = c.return;
  }
  Q = a;
  Y = a = Pg(a.current, null);
  Z = fj = b;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
      c.interleaved = null;
      var e = d.next, f2 = c.pending;
      if (null !== f2) {
        var g = f2.next;
        f2.next = e;
        d.next = g;
      }
      c.pending = d;
    }
    fh = null;
  }
  return a;
}
function Mk(a, b) {
  do {
    var c = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d = M.memoizedState; null !== d; ) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c || null === c.return) {
        T = 1;
        pk = b;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g = c.return, h = c, k2 = b;
        b = Z;
        h.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g, h, f2, b);
            y2.mode & 1 && Si(f2, l2, b);
            b = y2;
            k2 = l2;
            var n2 = b.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b & 1)) {
              Si(f2, l2, b);
              tj();
              break a;
            }
            k2 = Error(p(426));
          }
        } else if (I && h.mode & 1) {
          var J2 = Ui(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g, h, f2, b);
            Jg(Ji(k2, h));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b &= -b;
              f2.lanes |= b;
              var x = Ni(f2, k2, b);
              ph(f2, x);
              break a;
            case 1:
              h = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var F2 = Qi(f2, h, b);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c);
    } catch (na) {
      b = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a = mk.current;
  mk.current = Rh;
  return null === a ? Rh : a;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a, b) {
  var c = K;
  K |= 2;
  var d = Jk();
  if (Q !== a || Z !== b) uk = null, Kk(a, b);
  do
    try {
      Tk();
      break;
    } catch (e) {
      Mk(a, e);
    }
  while (1);
  $g();
  K = c;
  mk.current = d;
  if (null !== Y) throw Error(p(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a) {
  var b = Vk(a.alternate, a, fj);
  a.memoizedProps = a.pendingProps;
  null === b ? Sk(a) : Y = b;
  nk.current = null;
}
function Sk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Ej(c, b, fj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Ij(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }
      if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === T && (T = 5);
}
function Pk(a, b, c) {
  var d = C, e = ok$2.transition;
  try {
    ok$2.transition = null, C = 1, Wk(a, b, c, d);
  } finally {
    ok$2.transition = e, C = d;
  }
  return null;
}
function Wk(a, b, c, d) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(p(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc(a, f2);
  a === Q && (Y = Q = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = ok$2.transition;
    ok$2.transition = null;
    var g = C;
    C = 1;
    var h = K;
    K |= 4;
    nk.current = null;
    Oj(a, c);
    dk(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    hk(c);
    dc();
    K = h;
    C = g;
    ok$2.transition = f2;
  } else a.current = c;
  vk && (vk = false, wk = a, xk = e);
  f2 = a.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c.stateNode);
  Dk(a, B());
  if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
  if (Oi) throw Oi = false, a = Pi, Pi = null, a;
  0 !== (xk & 1) && 0 !== a.tag && Hk();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a = Dc(xk), b = ok$2.transition, c = C;
    try {
      ok$2.transition = null;
      C = 16 > a ? 16 : a;
      if (null === wk) var d = false;
      else {
        a = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p(331));
        var e = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g = f2.child;
          if (0 !== (V.flags & 16)) {
            var h = f2.deletions;
            if (null !== h) {
              for (var k2 = 0; k2 < h.length; k2++) {
                var l2 = h[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V = q2;
                  else for (; null !== V; ) {
                    m2 = V;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V = r2;
                      break;
                    }
                    V = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g) g.return = f2, V = g;
          else b: for (; null !== V; ) {
            f2 = V;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x = f2.sibling;
            if (null !== x) {
              x.return = f2.return;
              V = x;
              break b;
            }
            V = f2.return;
          }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g = V;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2) u2.return = g, V = u2;
          else b: for (g = w2; null !== V; ) {
            h = V;
            if (0 !== (h.flags & 2048)) try {
              switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h);
              }
            } catch (na) {
              W(h, h.return, na);
            }
            if (h === g) {
              V = null;
              break b;
            }
            var F2 = h.sibling;
            if (null !== F2) {
              F2.return = h.return;
              V = F2;
              break b;
            }
            V = h.return;
          }
        }
        K = e;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a);
        } catch (na) {
        }
        d = true;
      }
      return d;
    } finally {
      C = c, ok$2.transition = b;
    }
  }
  return false;
}
function Xk(a, b, c) {
  b = Ji(c, b);
  b = Ni(a, b, 1);
  a = nh(a, b, 1);
  b = R();
  null !== a && (Ac(a, 1, b), Dk(a, b));
}
function W(a, b, c) {
  if (3 === a.tag) Xk(a, a, c);
  else for (; null !== b; ) {
    if (3 === b.tag) {
      Xk(b, a, c);
      break;
    } else if (1 === b.tag) {
      var d = b.stateNode;
      if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
        a = Ji(c, a);
        a = Qi(b, a, 1);
        b = nh(b, a, 1);
        a = R();
        null !== b && (Ac(b, 1, a), Dk(b, a));
        break;
      }
    }
    b = b.return;
  }
}
function Ti(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = R();
  a.pingedLanes |= a.suspendedLanes & c;
  Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
  Dk(a, b);
}
function Yk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = R();
  a = ih(a, b);
  null !== a && (Ac(a, b, c), Dk(a, c));
}
function uj(a) {
  var b = a.memoizedState, c = 0;
  null !== b && (c = b.retryLane);
  Yk(a, c);
}
function bk(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      null !== e && (c = e.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p(314));
  }
  null !== d && d.delete(b);
  Yk(a, c);
}
var Vk;
Vk = function(a, b, c) {
  if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
    dh = 0 !== (a.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d = b.type;
      ij(a, b);
      a = b.pendingProps;
      var e = Yf(b, H.current);
      ch(b, c);
      e = Nh(null, b, d, a, e, c);
      var f2 = Sh();
      b.flags |= 1;
      "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f2, c)) : (b.tag = 0, I && f2 && vg(b), Xi(null, b, e, c), b = b.child);
      return b;
    case 16:
      d = b.elementType;
      a: {
        ij(a, b);
        a = b.pendingProps;
        e = d._init;
        d = e(d._payload);
        b.type = d;
        e = b.tag = Zk(d);
        a = Ci(d, a);
        switch (e) {
          case 0:
            b = cj(null, b, d, a, c);
            break a;
          case 1:
            b = hj(null, b, d, a, c);
            break a;
          case 11:
            b = Yi(null, b, d, a, c);
            break a;
          case 14:
            b = $i(null, b, d, Ci(d.type, a), c);
            break a;
        }
        throw Error(p(
          306,
          d,
          ""
        ));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
    case 3:
      a: {
        kj(b);
        if (null === a) throw Error(p(387));
        d = b.pendingProps;
        f2 = b.memoizedState;
        e = f2.element;
        lh(a, b);
        qh(b, d, null, c);
        var g = b.memoizedState;
        d = g.element;
        if (f2.isDehydrated) if (f2 = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
          e = Ji(Error(p(423)), b);
          b = lj(a, b, d, c, e);
          break a;
        } else if (d !== e) {
          e = Ji(Error(p(424)), b);
          b = lj(a, b, d, c, e);
          break a;
        } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d === e) {
            b = Zi(a, b, c);
            break a;
          }
          Xi(a, b, d, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return oj(a, b, c);
    case 4:
      return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
    case 7:
      return Xi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Xi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Xi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        f2 = b.memoizedProps;
        g = e.value;
        G(Wg, d._currentValue);
        d._currentValue = g;
        if (null !== f2) if (He(f2.value, g)) {
          if (f2.children === e.children && !Wf.current) {
            b = Zi(a, b, c);
            break a;
          }
        } else for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
          var h = f2.dependencies;
          if (null !== h) {
            g = f2.child;
            for (var k2 = h.firstContext; null !== k2; ) {
              if (k2.context === d) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c & -c);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c);
                bh(
                  f2.return,
                  c,
                  b
                );
                h.lanes |= c;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g = f2.type === b.type ? null : f2.child;
          else if (18 === f2.tag) {
            g = f2.return;
            if (null === g) throw Error(p(341));
            g.lanes |= c;
            h = g.alternate;
            null !== h && (h.lanes |= c);
            bh(g, c, b);
            g = f2.sibling;
          } else g = f2.child;
          if (null !== g) g.return = f2;
          else for (g = f2; null !== g; ) {
            if (g === b) {
              g = null;
              break;
            }
            f2 = g.sibling;
            if (null !== f2) {
              f2.return = g.return;
              g = f2;
              break;
            }
            g = g.return;
          }
          f2 = g;
        }
        Xi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
    case 14:
      return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
    case 15:
      return bj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
    case 19:
      return xj(a, b, c);
    case 22:
      return dj(a, b, c);
  }
  throw Error(p(156, b.tag));
};
function Fk(a, b) {
  return ac(a, b);
}
function $k(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d) {
  return new $k(a, b, c, d);
}
function aj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function Zk(a) {
  if ("function" === typeof a) return aj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da) return 11;
    if (a === Ga) return 14;
  }
  return 2;
}
function Pg(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Rg(a, b, c, d, e, f2) {
  var g = 2;
  d = a;
  if ("function" === typeof a) aj(a) && (g = 1);
  else if ("string" === typeof a) g = 5;
  else a: switch (a) {
    case ya:
      return Tg(c.children, e, f2, b);
    case za:
      g = 8;
      e |= 8;
      break;
    case Aa:
      return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f2, a;
    case Ea:
      return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f2, a;
    case Fa:
      return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f2, a;
    case Ia:
      return pj(c, e, f2, b);
    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case Ba:
          g = 10;
          break a;
        case Ca:
          g = 9;
          break a;
        case Da:
          g = 11;
          break a;
        case Ga:
          g = 14;
          break a;
        case Ha:
          g = 16;
          d = null;
          break a;
      }
      throw Error(p(130, null == a ? a : typeof a, ""));
  }
  b = Bg(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f2;
  return b;
}
function Tg(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}
function pj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function Qg(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function Sg(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function al(a, b, c, d, e) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a, b, c, d, e, f2, g, h, k2) {
  a = new al(a, b, c, h, k2);
  1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
  f2 = Bg(3, null, null, b);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a;
}
function cl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function dl(a) {
  if (!a) return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c)) return bg(a, c, b);
  }
  return b;
}
function el(a, b, c, d, e, f2, g, h, k2) {
  a = bl(c, d, true, a, e, f2, g, h, k2);
  a.context = dl(null);
  c = a.current;
  d = R();
  e = yi(c);
  f2 = mh(d, e);
  f2.callback = void 0 !== b && null !== b ? b : null;
  nh(c, f2, e);
  a.current.lanes = e;
  Ac(a, e, d);
  Dk(a, d);
  return a;
}
function fl$1(a, b, c, d) {
  var e = b.current, f2 = R(), g = yi(e);
  c = dl(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = mh(f2, g);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = nh(e, b, g);
  null !== a && (gi(a, e, g, f2), oh(a, e, g));
  return g;
}
function gl(a) {
  a = a.current;
  if (!a.child) return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function hl(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function il(a, b) {
  hl(a, b);
  (a = a.alternate) && hl(a, b);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ll(a) {
  this._internalRoot = a;
}
ml.prototype.render = ll.prototype.render = function(a) {
  var b = this._internalRoot;
  if (null === b) throw Error(p(409));
  fl$1(a, b, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Rk(function() {
      fl$1(null, a, null, null);
    });
    b[uf] = null;
  }
};
function ml(a) {
  this._internalRoot = a;
}
ml.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b = Hc();
    a = { blockedOn: null, target: a, priority: b };
    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function nl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function pl() {
}
function ql(a, b, c, d, e) {
  if (e) {
    if ("function" === typeof d) {
      var f2 = d;
      d = function() {
        var a2 = gl(g);
        f2.call(a2);
      };
    }
    var g = el(b, d, a, 0, null, false, false, "", pl);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk();
    return g;
  }
  for (; e = a.lastChild; ) a.removeChild(e);
  if ("function" === typeof d) {
    var h = d;
    d = function() {
      var a2 = gl(k2);
      h.call(a2);
    };
  }
  var k2 = bl(a, 0, false, null, null, false, false, "", pl);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Rk(function() {
    fl$1(b, k2, c, d);
  });
  return k2;
}
function rl(a, b, c, d, e) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e) {
      var h = e;
      e = function() {
        var a2 = gl(g);
        h.call(a2);
      };
    }
    fl$1(b, g, a, e);
  } else g = ql(c, b, a, e, d);
  return gl(g);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b2 = ih(a, 1);
        if (null !== b2) {
          var c2 = R();
          gi(b2, a, 1, c2);
        }
      }), il(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b = ih(a, 134217728);
    if (null !== b) {
      var c = R();
      gi(b, a, 134217728, c);
    }
    il(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b = yi(a), c = ih(a, b);
    if (null !== c) {
      var d = R();
      gi(c, a, b, d);
    }
    il(a, b);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b) {
  var c = C;
  try {
    return C = a, b();
  } finally {
    C = c;
  }
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; ) c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e) throw Error(p(90));
            Wa(d);
            bb(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b)) throw Error(p(200));
  return cl(a, b, null, c);
};
reactDom_production_min.createRoot = function(a, b) {
  if (!nl(a)) throw Error(p(299));
  var c = false, d = "", e = kl;
  null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
  b = bl(a, 1, false, null, null, c, false, d, e);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ll(b);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(p(188));
    a = Object.keys(a).join(",");
    throw Error(p(268, a));
  }
  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Rk(a);
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!ol(b)) throw Error(p(200));
  return rl(null, a, b, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b, c) {
  if (!nl(a)) throw Error(p(405));
  var d = null != c && c.hydratedSources || null, e = false, f2 = "", g = kl;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = el(b, null, a, 1, null != c ? c : null, e, false, f2, g);
  a[uf] = b.current;
  sf(a);
  if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
    c,
    e
  );
  return new ml(b);
};
reactDom_production_min.render = function(a, b, c) {
  if (!ol(b)) throw Error(p(200));
  return rl(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!ol(a)) throw Error(p(40));
  return a._reactRootContainer ? (Rk(function() {
    rl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!ol(c)) throw Error(p(200));
  if (null == a || void 0 === a._reactInternals) throw Error(p(38));
  return rl(a, b, c, false, d);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err2) {
    console.error(err2);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m = reactDomExports;
{
  createRoot = m.createRoot;
  m.hydrateRoot;
}
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string2) => string2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && array.indexOf(className) === index2;
}).join(" ");
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color: color2 = "currentColor",
    size = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color2,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref) => reactExports.createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mic = createLucideIcon("Mic", [
  ["path", { d: "M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z", key: "131961" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Send = createLucideIcon("Send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
]);
var microsoft_cognitiveservices_speech_sdk = {};
var Exports$6 = {};
var CognitiveSubscriptionKeyAuthentication$1 = {};
var Exports$5 = {};
var AudioSourceEvents = {};
var PlatformEvent = {};
var Guid = {};
var commonjsBrowser = {};
var v1$1 = {};
var rng$1 = {};
Object.defineProperty(rng$1, "__esModule", {
  value: true
});
rng$1.default = rng;
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var stringify$3 = {};
var validate$1 = {};
var regex = {};
Object.defineProperty(regex, "__esModule", {
  value: true
});
regex.default = void 0;
var _default$d = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
regex.default = _default$d;
Object.defineProperty(validate$1, "__esModule", {
  value: true
});
validate$1.default = void 0;
var _regex = _interopRequireDefault$8(regex);
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function validate(uuid) {
  return typeof uuid === "string" && _regex.default.test(uuid);
}
var _default$c = validate;
validate$1.default = _default$c;
Object.defineProperty(stringify$3, "__esModule", {
  value: true
});
stringify$3.default = void 0;
stringify$3.unsafeStringify = unsafeStringify;
var _validate$2 = _interopRequireDefault$7(validate$1);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify$2(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!(0, _validate$2.default)(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var _default$b = stringify$2;
stringify$3.default = _default$b;
Object.defineProperty(v1$1, "__esModule", {
  value: true
});
v1$1.default = void 0;
var _rng$1 = _interopRequireDefault$6(rng$1);
var _stringify$2 = stringify$3;
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
let _nodeId;
let _clockseq;
let _lastMSecs = 0;
let _lastNSecs = 0;
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node2 = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node2 == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng$1.default)();
    if (node2 == null) {
      node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl2 >>> 24 & 255;
  b[i++] = tl2 >>> 16 & 255;
  b[i++] = tl2 >>> 8 & 255;
  b[i++] = tl2 & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n2 = 0; n2 < 6; ++n2) {
    b[i + n2] = node2[n2];
  }
  return buf || (0, _stringify$2.unsafeStringify)(b);
}
var _default$a = v1;
v1$1.default = _default$a;
var v3$1 = {};
var v35$1 = {};
var parse$2 = {};
Object.defineProperty(parse$2, "__esModule", {
  value: true
});
parse$2.default = void 0;
var _validate$1 = _interopRequireDefault$5(validate$1);
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function parse$1(uuid) {
  if (!(0, _validate$1.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  const arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var _default$9 = parse$1;
parse$2.default = _default$9;
Object.defineProperty(v35$1, "__esModule", {
  value: true
});
v35$1.URL = v35$1.DNS = void 0;
v35$1.default = v35;
var _stringify$1 = stringify$3;
var _parse = _interopRequireDefault$4(parse$2);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
v35$1.DNS = DNS;
const URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
v35$1.URL = URL$1;
function v35(name2, version2, hashfunc) {
  function generateUUID2(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = (0, _parse.default)(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify$1.unsafeStringify)(bytes);
  }
  try {
    generateUUID2.name = name2;
  } catch (err2) {
  }
  generateUUID2.DNS = DNS;
  generateUUID2.URL = URL$1;
  return generateUUID2;
}
var md5$1 = {};
Object.defineProperty(md5$1, "__esModule", {
  value: true
});
md5$1.default = void 0;
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  const lsw = (x & 65535) + (y2 & 65535);
  const msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a, b, x, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q2), safeAdd(x, t2)), s), b);
}
function md5ff(a, b, c, d, x, s, t2) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t2);
}
function md5gg(a, b, c, d, x, s, t2) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t2);
}
function md5hh(a, b, c, d, x, s, t2) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t2);
}
function md5ii(a, b, c, d, x, s, t2) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t2);
}
var _default$8 = md5;
md5$1.default = _default$8;
Object.defineProperty(v3$1, "__esModule", {
  value: true
});
v3$1.default = void 0;
var _v$2 = _interopRequireDefault$3(v35$1);
var _md = _interopRequireDefault$3(md5$1);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v3 = (0, _v$2.default)("v3", 48, _md.default);
var _default$7 = v3;
v3$1.default = _default$7;
var v4$1 = {};
var native = {};
Object.defineProperty(native, "__esModule", {
  value: true
});
native.default = void 0;
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default$6 = {
  randomUUID
};
native.default = _default$6;
Object.defineProperty(v4$1, "__esModule", {
  value: true
});
v4$1.default = void 0;
var _native = _interopRequireDefault$2(native);
var _rng = _interopRequireDefault$2(rng$1);
var _stringify = stringify$3;
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng.default)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify.unsafeStringify)(rnds);
}
var _default$5 = v4;
v4$1.default = _default$5;
var v5$1 = {};
var sha1$1 = {};
Object.defineProperty(sha1$1, "__esModule", {
  value: true
});
sha1$1.default = void 0;
function f(s, x, y2, z2) {
  switch (s) {
    case 0:
      return x & y2 ^ ~x & z2;
    case 1:
      return x ^ y2 ^ z2;
    case 2:
      return x & y2 ^ x & z2 ^ y2 & z2;
    case 3:
      return x ^ y2 ^ z2;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l2 = bytes.length / 4 + 2;
  const N2 = Math.ceil(l2 / 16);
  const M2 = new Array(N2);
  for (let i = 0; i < N2; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M2[i] = arr;
  }
  M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
  M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N2; ++i) {
    const W2 = new Uint32Array(80);
    for (let t2 = 0; t2 < 16; ++t2) {
      W2[t2] = M2[i][t2];
    }
    for (let t2 = 16; t2 < 80; ++t2) {
      W2[t2] = ROTL(W2[t2 - 3] ^ W2[t2 - 8] ^ W2[t2 - 14] ^ W2[t2 - 16], 1);
    }
    let a = H2[0];
    let b = H2[1];
    let c = H2[2];
    let d = H2[3];
    let e = H2[4];
    for (let t2 = 0; t2 < 80; ++t2) {
      const s = Math.floor(t2 / 20);
      const T2 = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W2[t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T2;
    }
    H2[0] = H2[0] + a >>> 0;
    H2[1] = H2[1] + b >>> 0;
    H2[2] = H2[2] + c >>> 0;
    H2[3] = H2[3] + d >>> 0;
    H2[4] = H2[4] + e >>> 0;
  }
  return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
}
var _default$4 = sha1;
sha1$1.default = _default$4;
Object.defineProperty(v5$1, "__esModule", {
  value: true
});
v5$1.default = void 0;
var _v$1 = _interopRequireDefault$1(v35$1);
var _sha = _interopRequireDefault$1(sha1$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
const v5 = (0, _v$1.default)("v5", 80, _sha.default);
var _default$3 = v5;
v5$1.default = _default$3;
var nil = {};
Object.defineProperty(nil, "__esModule", {
  value: true
});
nil.default = void 0;
var _default$2 = "00000000-0000-0000-0000-000000000000";
nil.default = _default$2;
var version$1 = {};
Object.defineProperty(version$1, "__esModule", {
  value: true
});
version$1.default = void 0;
var _validate = _interopRequireDefault(validate$1);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var _default$1 = version;
version$1.default = _default$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function get() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _parse2.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function get() {
      return _stringify2.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function get() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function get() {
      return _v22.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function get() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function get() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function get() {
      return _validate2.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function get() {
      return _version.default;
    }
  });
  var _v2 = _interopRequireDefault2(v1$1);
  var _v22 = _interopRequireDefault2(v3$1);
  var _v3 = _interopRequireDefault2(v4$1);
  var _v4 = _interopRequireDefault2(v5$1);
  var _nil = _interopRequireDefault2(nil);
  var _version = _interopRequireDefault2(version$1);
  var _validate2 = _interopRequireDefault2(validate$1);
  var _stringify2 = _interopRequireDefault2(stringify$3);
  var _parse2 = _interopRequireDefault2(parse$2);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
})(commonjsBrowser);
Object.defineProperty(Guid, "__esModule", { value: true });
Guid.createNoDashGuid = Guid.createGuid = void 0;
const uuid_1 = commonjsBrowser;
const createGuid = () => uuid_1.v4();
Guid.createGuid = createGuid;
const createNoDashGuid = () => createGuid().replace(new RegExp("-", "g"), "").toUpperCase();
Guid.createNoDashGuid = createNoDashGuid;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PlatformEvent = exports.EventType = void 0;
  const Guid_js_12 = Guid;
  (function(EventType) {
    EventType[EventType["Debug"] = 0] = "Debug";
    EventType[EventType["Info"] = 1] = "Info";
    EventType[EventType["Warning"] = 2] = "Warning";
    EventType[EventType["Error"] = 3] = "Error";
    EventType[EventType["None"] = 4] = "None";
  })(exports.EventType || (exports.EventType = {}));
  class PlatformEvent2 {
    constructor(eventName, eventType) {
      this.privName = eventName;
      this.privEventId = Guid_js_12.createNoDashGuid();
      this.privEventTime = (/* @__PURE__ */ new Date()).toISOString();
      this.privEventType = eventType;
      this.privMetadata = {};
    }
    get name() {
      return this.privName;
    }
    get eventId() {
      return this.privEventId;
    }
    get eventTime() {
      return this.privEventTime;
    }
    get eventType() {
      return this.privEventType;
    }
    get metadata() {
      return this.privMetadata;
    }
  }
  exports.PlatformEvent = PlatformEvent2;
})(PlatformEvent);
Object.defineProperty(AudioSourceEvents, "__esModule", { value: true });
AudioSourceEvents.AudioStreamNodeErrorEvent = AudioSourceEvents.AudioStreamNodeDetachedEvent = AudioSourceEvents.AudioStreamNodeAttachedEvent = AudioSourceEvents.AudioStreamNodeAttachingEvent = AudioSourceEvents.AudioStreamNodeEvent = AudioSourceEvents.AudioSourceErrorEvent = AudioSourceEvents.AudioSourceOffEvent = AudioSourceEvents.AudioSourceReadyEvent = AudioSourceEvents.AudioSourceInitializingEvent = AudioSourceEvents.AudioSourceEvent = void 0;
const PlatformEvent_js_1$3 = PlatformEvent;
class AudioSourceEvent extends PlatformEvent_js_1$3.PlatformEvent {
  constructor(eventName, audioSourceId, eventType = PlatformEvent_js_1$3.EventType.Info) {
    super(eventName, eventType);
    this.privAudioSourceId = audioSourceId;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
}
AudioSourceEvents.AudioSourceEvent = AudioSourceEvent;
class AudioSourceInitializingEvent extends AudioSourceEvent {
  constructor(audioSourceId) {
    super("AudioSourceInitializingEvent", audioSourceId);
  }
}
AudioSourceEvents.AudioSourceInitializingEvent = AudioSourceInitializingEvent;
class AudioSourceReadyEvent extends AudioSourceEvent {
  constructor(audioSourceId) {
    super("AudioSourceReadyEvent", audioSourceId);
  }
}
AudioSourceEvents.AudioSourceReadyEvent = AudioSourceReadyEvent;
class AudioSourceOffEvent extends AudioSourceEvent {
  constructor(audioSourceId) {
    super("AudioSourceOffEvent", audioSourceId);
  }
}
AudioSourceEvents.AudioSourceOffEvent = AudioSourceOffEvent;
class AudioSourceErrorEvent extends AudioSourceEvent {
  constructor(audioSourceId, error) {
    super("AudioSourceErrorEvent", audioSourceId, PlatformEvent_js_1$3.EventType.Error);
    this.privError = error;
  }
  get error() {
    return this.privError;
  }
}
AudioSourceEvents.AudioSourceErrorEvent = AudioSourceErrorEvent;
class AudioStreamNodeEvent extends AudioSourceEvent {
  constructor(eventName, audioSourceId, audioNodeId) {
    super(eventName, audioSourceId);
    this.privAudioNodeId = audioNodeId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
}
AudioSourceEvents.AudioStreamNodeEvent = AudioStreamNodeEvent;
class AudioStreamNodeAttachingEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId) {
    super("AudioStreamNodeAttachingEvent", audioSourceId, audioNodeId);
  }
}
AudioSourceEvents.AudioStreamNodeAttachingEvent = AudioStreamNodeAttachingEvent;
class AudioStreamNodeAttachedEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId) {
    super("AudioStreamNodeAttachedEvent", audioSourceId, audioNodeId);
  }
}
AudioSourceEvents.AudioStreamNodeAttachedEvent = AudioStreamNodeAttachedEvent;
class AudioStreamNodeDetachedEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId) {
    super("AudioStreamNodeDetachedEvent", audioSourceId, audioNodeId);
  }
}
AudioSourceEvents.AudioStreamNodeDetachedEvent = AudioStreamNodeDetachedEvent;
class AudioStreamNodeErrorEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId, error) {
    super("AudioStreamNodeErrorEvent", audioSourceId, audioNodeId);
    this.privError = error;
  }
  get error() {
    return this.privError;
  }
}
AudioSourceEvents.AudioStreamNodeErrorEvent = AudioStreamNodeErrorEvent;
var ConnectionEvents = {};
Object.defineProperty(ConnectionEvents, "__esModule", { value: true });
ConnectionEvents.ConnectionMessageSentEvent = ConnectionEvents.ConnectionMessageReceivedEvent = ConnectionEvents.ConnectionEstablishErrorEvent = ConnectionEvents.ConnectionErrorEvent = ConnectionEvents.ConnectionClosedEvent = ConnectionEvents.ConnectionEstablishedEvent = ConnectionEvents.ConnectionStartEvent = ConnectionEvents.ConnectionEvent = ConnectionEvents.ServiceEvent = void 0;
const PlatformEvent_js_1$2 = PlatformEvent;
class ServiceEvent extends PlatformEvent_js_1$2.PlatformEvent {
  constructor(eventName, jsonstring, eventType = PlatformEvent_js_1$2.EventType.Info) {
    super(eventName, eventType);
    this.privJsonResult = jsonstring;
  }
  get jsonString() {
    return this.privJsonResult;
  }
}
ConnectionEvents.ServiceEvent = ServiceEvent;
class ConnectionEvent extends PlatformEvent_js_1$2.PlatformEvent {
  constructor(eventName, connectionId, eventType = PlatformEvent_js_1$2.EventType.Info) {
    super(eventName, eventType);
    this.privConnectionId = connectionId;
  }
  get connectionId() {
    return this.privConnectionId;
  }
}
ConnectionEvents.ConnectionEvent = ConnectionEvent;
class ConnectionStartEvent extends ConnectionEvent {
  constructor(connectionId, uri, headers) {
    super("ConnectionStartEvent", connectionId);
    this.privUri = uri;
    this.privHeaders = headers;
  }
  get uri() {
    return this.privUri;
  }
  get headers() {
    return this.privHeaders;
  }
}
ConnectionEvents.ConnectionStartEvent = ConnectionStartEvent;
class ConnectionEstablishedEvent extends ConnectionEvent {
  constructor(connectionId) {
    super("ConnectionEstablishedEvent", connectionId);
  }
}
ConnectionEvents.ConnectionEstablishedEvent = ConnectionEstablishedEvent;
class ConnectionClosedEvent extends ConnectionEvent {
  constructor(connectionId, statusCode, reason) {
    super("ConnectionClosedEvent", connectionId, PlatformEvent_js_1$2.EventType.Debug);
    this.privReason = reason;
    this.privStatusCode = statusCode;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
ConnectionEvents.ConnectionClosedEvent = ConnectionClosedEvent;
class ConnectionErrorEvent extends ConnectionEvent {
  constructor(connectionId, message, type) {
    super("ConnectionErrorEvent", connectionId, PlatformEvent_js_1$2.EventType.Debug);
    this.privMessage = message;
    this.privType = type;
  }
  get message() {
    return this.privMessage;
  }
  get type() {
    return this.privType;
  }
}
ConnectionEvents.ConnectionErrorEvent = ConnectionErrorEvent;
class ConnectionEstablishErrorEvent extends ConnectionEvent {
  constructor(connectionId, statuscode, reason) {
    super("ConnectionEstablishErrorEvent", connectionId, PlatformEvent_js_1$2.EventType.Error);
    this.privStatusCode = statuscode;
    this.privReason = reason;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
ConnectionEvents.ConnectionEstablishErrorEvent = ConnectionEstablishErrorEvent;
class ConnectionMessageReceivedEvent extends ConnectionEvent {
  constructor(connectionId, networkReceivedTimeISO, message) {
    super("ConnectionMessageReceivedEvent", connectionId);
    this.privNetworkReceivedTime = networkReceivedTimeISO;
    this.privMessage = message;
  }
  get networkReceivedTime() {
    return this.privNetworkReceivedTime;
  }
  get message() {
    return this.privMessage;
  }
}
ConnectionEvents.ConnectionMessageReceivedEvent = ConnectionMessageReceivedEvent;
class ConnectionMessageSentEvent extends ConnectionEvent {
  constructor(connectionId, networkSentTimeISO, message) {
    super("ConnectionMessageSentEvent", connectionId);
    this.privNetworkSentTime = networkSentTimeISO;
    this.privMessage = message;
  }
  get networkSentTime() {
    return this.privNetworkSentTime;
  }
  get message() {
    return this.privMessage;
  }
}
ConnectionEvents.ConnectionMessageSentEvent = ConnectionMessageSentEvent;
var ConnectionMessage$1 = {};
var _Error = {};
Object.defineProperty(_Error, "__esModule", { value: true });
_Error.ObjectDisposedError = _Error.InvalidOperationError = _Error.ArgumentNullError = void 0;
class ArgumentNullError extends Error {
  /**
   * Creates an instance of ArgumentNullError.
   *
   * @param {string} argumentName - Name of the argument that is null
   *
   * @memberOf ArgumentNullError
   */
  constructor(argumentName) {
    super(argumentName);
    this.name = "ArgumentNull";
    this.message = argumentName;
  }
}
_Error.ArgumentNullError = ArgumentNullError;
class InvalidOperationError extends Error {
  /**
   * Creates an instance of InvalidOperationError.
   *
   * @param {string} error - The error
   *
   * @memberOf InvalidOperationError
   */
  constructor(error) {
    super(error);
    this.name = "InvalidOperation";
    this.message = error;
  }
}
_Error.InvalidOperationError = InvalidOperationError;
class ObjectDisposedError extends Error {
  /**
   * Creates an instance of ObjectDisposedError.
   *
   * @param {string} objectName - The object that is disposed
   * @param {string} error - The error
   *
   * @memberOf ObjectDisposedError
   */
  constructor(objectName, error) {
    super(error);
    this.name = objectName + "ObjectDisposed";
    this.message = error;
  }
}
_Error.ObjectDisposedError = ObjectDisposedError;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionMessage = exports.MessageType = void 0;
  const Error_js_12 = _Error;
  const Guid_js_12 = Guid;
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Text"] = 0] = "Text";
    MessageType2[MessageType2["Binary"] = 1] = "Binary";
  })(MessageType = exports.MessageType || (exports.MessageType = {}));
  class ConnectionMessage2 {
    constructor(messageType, body, headers, id2) {
      this.privBody = null;
      if (messageType === MessageType.Text && body && !(typeof body === "string")) {
        throw new Error_js_12.InvalidOperationError("Payload must be a string");
      }
      if (messageType === MessageType.Binary && body && !(body instanceof ArrayBuffer)) {
        throw new Error_js_12.InvalidOperationError("Payload must be ArrayBuffer");
      }
      this.privMessageType = messageType;
      this.privBody = body;
      this.privHeaders = headers ? headers : {};
      this.privId = id2 ? id2 : Guid_js_12.createNoDashGuid();
      switch (this.messageType) {
        case MessageType.Binary:
          this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
          break;
        case MessageType.Text:
          this.privSize = this.textBody.length;
      }
    }
    get messageType() {
      return this.privMessageType;
    }
    get headers() {
      return this.privHeaders;
    }
    get body() {
      return this.privBody;
    }
    get textBody() {
      if (this.privMessageType === MessageType.Binary) {
        throw new Error_js_12.InvalidOperationError("Not supported for binary message");
      }
      return this.privBody;
    }
    get binaryBody() {
      if (this.privMessageType === MessageType.Text) {
        throw new Error_js_12.InvalidOperationError("Not supported for text message");
      }
      return this.privBody;
    }
    get id() {
      return this.privId;
    }
  }
  exports.ConnectionMessage = ConnectionMessage2;
})(ConnectionMessage$1);
var ConnectionOpenResponse$1 = {};
Object.defineProperty(ConnectionOpenResponse$1, "__esModule", { value: true });
ConnectionOpenResponse$1.ConnectionOpenResponse = void 0;
class ConnectionOpenResponse {
  constructor(statusCode, reason) {
    this.privStatusCode = statusCode;
    this.privReason = reason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
  get reason() {
    return this.privReason;
  }
}
ConnectionOpenResponse$1.ConnectionOpenResponse = ConnectionOpenResponse;
var DeferralMap$1 = {};
Object.defineProperty(DeferralMap$1, "__esModule", { value: true });
DeferralMap$1.DeferralMap = void 0;
class DeferralMap {
  constructor() {
    this.privMap = {};
  }
  add(id2, deferral) {
    this.privMap[id2] = deferral;
  }
  getId(id2) {
    return this.privMap[id2];
  }
  complete(id2, result) {
    try {
      this.privMap[id2].resolve(result);
    } catch (error) {
      this.privMap[id2].reject(error);
    } finally {
      this.privMap[id2] = void 0;
    }
  }
}
DeferralMap$1.DeferralMap = DeferralMap;
var DialogEvents = {};
Object.defineProperty(DialogEvents, "__esModule", { value: true });
DialogEvents.SendingAgentContextMessageEvent = DialogEvents.DialogEvent = void 0;
const PlatformEvent_js_1$1 = PlatformEvent;
class DialogEvent extends PlatformEvent_js_1$1.PlatformEvent {
  constructor(eventName, eventType = PlatformEvent_js_1$1.EventType.Info) {
    super(eventName, eventType);
  }
}
DialogEvents.DialogEvent = DialogEvent;
class SendingAgentContextMessageEvent extends DialogEvent {
  constructor(agentConfig) {
    super("SendingAgentContextMessageEvent");
    this.privAgentConfig = agentConfig;
  }
  get agentConfig() {
    return this.privAgentConfig;
  }
}
DialogEvents.SendingAgentContextMessageEvent = SendingAgentContextMessageEvent;
var Events$1 = {};
var EventSource$1 = {};
Object.defineProperty(EventSource$1, "__esModule", { value: true });
EventSource$1.EventSource = void 0;
const Error_js_1$6 = _Error;
const Guid_js_1$2 = Guid;
class EventSource {
  constructor(metadata) {
    this.privEventListeners = {};
    this.privIsDisposed = false;
    this.privConsoleListener = void 0;
    this.privMetadata = metadata;
  }
  onEvent(event) {
    if (this.isDisposed()) {
      throw new Error_js_1$6.ObjectDisposedError("EventSource");
    }
    if (this.metadata) {
      for (const paramName in this.metadata) {
        if (paramName) {
          if (event.metadata) {
            if (!event.metadata[paramName]) {
              event.metadata[paramName] = this.metadata[paramName];
            }
          }
        }
      }
    }
    for (const eventId in this.privEventListeners) {
      if (eventId && this.privEventListeners[eventId]) {
        this.privEventListeners[eventId](event);
      }
    }
  }
  attach(onEventCallback) {
    const id2 = Guid_js_1$2.createNoDashGuid();
    this.privEventListeners[id2] = onEventCallback;
    return {
      detach: () => {
        delete this.privEventListeners[id2];
        return Promise.resolve();
      }
    };
  }
  attachListener(listener) {
    return this.attach((e) => listener.onEvent(e));
  }
  attachConsoleListener(listener) {
    if (!!this.privConsoleListener) {
      void this.privConsoleListener.detach();
    }
    this.privConsoleListener = this.attach((e) => listener.onEvent(e));
    return this.privConsoleListener;
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose() {
    this.privEventListeners = null;
    this.privIsDisposed = true;
  }
  get metadata() {
    return this.privMetadata;
  }
}
EventSource$1.EventSource = EventSource;
Object.defineProperty(Events$1, "__esModule", { value: true });
Events$1.Events = void 0;
const Error_js_1$5 = _Error;
const EventSource_js_1 = EventSource$1;
class Events {
  static setEventSource(eventSource) {
    if (!eventSource) {
      throw new Error_js_1$5.ArgumentNullError("eventSource");
    }
    Events.privInstance = eventSource;
  }
  static get instance() {
    return Events.privInstance;
  }
}
Events$1.Events = Events;
Events.privInstance = new EventSource_js_1.EventSource();
var IAudioSource = {};
Object.defineProperty(IAudioSource, "__esModule", { value: true });
var IConnection = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionState = void 0;
  (function(ConnectionState) {
    ConnectionState[ConnectionState["None"] = 0] = "None";
    ConnectionState[ConnectionState["Connected"] = 1] = "Connected";
    ConnectionState[ConnectionState["Connecting"] = 2] = "Connecting";
    ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
  })(exports.ConnectionState || (exports.ConnectionState = {}));
})(IConnection);
var IDetachable = {};
Object.defineProperty(IDetachable, "__esModule", { value: true });
var IDictionary = {};
Object.defineProperty(IDictionary, "__esModule", { value: true });
var IDisposable = {};
Object.defineProperty(IDisposable, "__esModule", { value: true });
var IEventListener = {};
Object.defineProperty(IEventListener, "__esModule", { value: true });
var IEventSource = {};
Object.defineProperty(IEventSource, "__esModule", { value: true });
var IErrorMessages = {};
Object.defineProperty(IErrorMessages, "__esModule", { value: true });
var ITimer = {};
Object.defineProperty(ITimer, "__esModule", { value: true });
var IWebsocketMessageFormatter = {};
Object.defineProperty(IWebsocketMessageFormatter, "__esModule", { value: true });
var List$1 = {};
Object.defineProperty(List$1, "__esModule", { value: true });
List$1.List = void 0;
const Error_js_1$4 = _Error;
class List {
  constructor(list2) {
    this.privSubscriptionIdCounter = 0;
    this.privAddSubscriptions = {};
    this.privRemoveSubscriptions = {};
    this.privDisposedSubscriptions = {};
    this.privDisposeReason = null;
    this.privList = [];
    if (list2) {
      for (const item of list2) {
        this.privList.push(item);
      }
    }
  }
  get(itemIndex) {
    this.throwIfDisposed();
    return this.privList[itemIndex];
  }
  first() {
    return this.get(0);
  }
  last() {
    return this.get(this.length() - 1);
  }
  add(item) {
    this.throwIfDisposed();
    this.insertAt(this.privList.length, item);
  }
  insertAt(index2, item) {
    this.throwIfDisposed();
    if (index2 === 0) {
      this.privList.unshift(item);
    } else if (index2 === this.privList.length) {
      this.privList.push(item);
    } else {
      this.privList.splice(index2, 0, item);
    }
    this.triggerSubscriptions(this.privAddSubscriptions);
  }
  removeFirst() {
    this.throwIfDisposed();
    return this.removeAt(0);
  }
  removeLast() {
    this.throwIfDisposed();
    return this.removeAt(this.length() - 1);
  }
  removeAt(index2) {
    this.throwIfDisposed();
    return this.remove(index2, 1)[0];
  }
  remove(index2, count) {
    this.throwIfDisposed();
    const removedElements = this.privList.splice(index2, count);
    this.triggerSubscriptions(this.privRemoveSubscriptions);
    return removedElements;
  }
  clear() {
    this.throwIfDisposed();
    this.remove(0, this.length());
  }
  length() {
    this.throwIfDisposed();
    return this.privList.length;
  }
  onAdded(addedCallback) {
    this.throwIfDisposed();
    const subscriptionId = this.privSubscriptionIdCounter++;
    this.privAddSubscriptions[subscriptionId] = addedCallback;
    return {
      detach: () => {
        delete this.privAddSubscriptions[subscriptionId];
        return Promise.resolve();
      }
    };
  }
  onRemoved(removedCallback) {
    this.throwIfDisposed();
    const subscriptionId = this.privSubscriptionIdCounter++;
    this.privRemoveSubscriptions[subscriptionId] = removedCallback;
    return {
      detach: () => {
        delete this.privRemoveSubscriptions[subscriptionId];
        return Promise.resolve();
      }
    };
  }
  onDisposed(disposedCallback) {
    this.throwIfDisposed();
    const subscriptionId = this.privSubscriptionIdCounter++;
    this.privDisposedSubscriptions[subscriptionId] = disposedCallback;
    return {
      detach: () => {
        delete this.privDisposedSubscriptions[subscriptionId];
        return Promise.resolve();
      }
    };
  }
  join(seperator) {
    this.throwIfDisposed();
    return this.privList.join(seperator);
  }
  toArray() {
    const cloneCopy = Array();
    this.privList.forEach((val) => {
      cloneCopy.push(val);
    });
    return cloneCopy;
  }
  any(callback) {
    this.throwIfDisposed();
    if (callback) {
      return this.where(callback).length() > 0;
    } else {
      return this.length() > 0;
    }
  }
  all(callback) {
    this.throwIfDisposed();
    return this.where(callback).length() === this.length();
  }
  forEach(callback) {
    this.throwIfDisposed();
    for (let i = 0; i < this.length(); i++) {
      callback(this.privList[i], i);
    }
  }
  select(callback) {
    this.throwIfDisposed();
    const selectList = [];
    for (let i = 0; i < this.privList.length; i++) {
      selectList.push(callback(this.privList[i], i));
    }
    return new List(selectList);
  }
  where(callback) {
    this.throwIfDisposed();
    const filteredList = new List();
    for (let i = 0; i < this.privList.length; i++) {
      if (callback(this.privList[i], i)) {
        filteredList.add(this.privList[i]);
      }
    }
    return filteredList;
  }
  orderBy(compareFn) {
    this.throwIfDisposed();
    const clonedArray = this.toArray();
    const orderedArray = clonedArray.sort(compareFn);
    return new List(orderedArray);
  }
  orderByDesc(compareFn) {
    this.throwIfDisposed();
    return this.orderBy((a, b) => compareFn(b, a));
  }
  clone() {
    this.throwIfDisposed();
    return new List(this.toArray());
  }
  concat(list2) {
    this.throwIfDisposed();
    return new List(this.privList.concat(list2.toArray()));
  }
  concatArray(array) {
    this.throwIfDisposed();
    return new List(this.privList.concat(array));
  }
  isDisposed() {
    return this.privList == null;
  }
  dispose(reason) {
    if (!this.isDisposed()) {
      this.privDisposeReason = reason;
      this.privList = null;
      this.privAddSubscriptions = null;
      this.privRemoveSubscriptions = null;
      this.triggerSubscriptions(this.privDisposedSubscriptions);
    }
  }
  throwIfDisposed() {
    if (this.isDisposed()) {
      throw new Error_js_1$4.ObjectDisposedError("List", this.privDisposeReason);
    }
  }
  triggerSubscriptions(subscriptions) {
    if (subscriptions) {
      for (const subscriptionId in subscriptions) {
        if (subscriptionId) {
          subscriptions[subscriptionId]();
        }
      }
    }
  }
}
List$1.List = List;
var _Promise = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.marshalPromiseToCallbacks = exports.Sink = exports.Deferred = exports.PromiseResultEventSource = exports.PromiseResult = exports.PromiseState = void 0;
  var PromiseState;
  (function(PromiseState2) {
    PromiseState2[PromiseState2["None"] = 0] = "None";
    PromiseState2[PromiseState2["Resolved"] = 1] = "Resolved";
    PromiseState2[PromiseState2["Rejected"] = 2] = "Rejected";
  })(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
  class PromiseResult {
    constructor(promiseResultEventSource) {
      this.throwIfError = () => {
        if (this.isError) {
          throw this.error;
        }
      };
      promiseResultEventSource.on((result) => {
        if (!this.privIsCompleted) {
          this.privIsCompleted = true;
          this.privIsError = false;
          this.privResult = result;
        }
      }, (error) => {
        if (!this.privIsCompleted) {
          this.privIsCompleted = true;
          this.privIsError = true;
          this.privError = error;
        }
      });
    }
    get isCompleted() {
      return this.privIsCompleted;
    }
    get isError() {
      return this.privIsError;
    }
    get error() {
      return this.privError;
    }
    get result() {
      return this.privResult;
    }
  }
  exports.PromiseResult = PromiseResult;
  class PromiseResultEventSource {
    constructor() {
      this.setResult = (result) => {
        this.privOnSetResult(result);
      };
      this.setError = (error) => {
        this.privOnSetError(error);
      };
      this.on = (onSetResult, onSetError) => {
        this.privOnSetResult = onSetResult;
        this.privOnSetError = onSetError;
      };
    }
  }
  exports.PromiseResultEventSource = PromiseResultEventSource;
  class Deferred {
    constructor() {
      this.resolve = (result) => {
        this.privResolve(result);
        return this;
      };
      this.reject = (error) => {
        this.privReject(error);
        return this;
      };
      this.privPromise = new Promise((resolve, reject) => {
        this.privResolve = resolve;
        this.privReject = reject;
      });
    }
    get promise() {
      return this.privPromise;
    }
  }
  exports.Deferred = Deferred;
  class Sink {
    constructor() {
      this.privState = PromiseState.None;
      this.privPromiseResult = null;
      this.privPromiseResultEvents = null;
      this.privSuccessHandlers = [];
      this.privErrorHandlers = [];
      this.privPromiseResultEvents = new PromiseResultEventSource();
      this.privPromiseResult = new PromiseResult(this.privPromiseResultEvents);
    }
    get state() {
      return this.privState;
    }
    get result() {
      return this.privPromiseResult;
    }
    resolve(result) {
      if (this.privState !== PromiseState.None) {
        throw new Error("'Cannot resolve a completed promise'");
      }
      this.privState = PromiseState.Resolved;
      this.privPromiseResultEvents.setResult(result);
      for (let i = 0; i < this.privSuccessHandlers.length; i++) {
        this.executeSuccessCallback(result, this.privSuccessHandlers[i], this.privErrorHandlers[i]);
      }
      this.detachHandlers();
    }
    reject(error) {
      if (this.privState !== PromiseState.None) {
        throw new Error("'Cannot reject a completed promise'");
      }
      this.privState = PromiseState.Rejected;
      this.privPromiseResultEvents.setError(error);
      for (const errorHandler of this.privErrorHandlers) {
        this.executeErrorCallback(error, errorHandler);
      }
      this.detachHandlers();
    }
    on(successCallback, errorCallback) {
      if (successCallback == null) {
        successCallback = () => {
        };
      }
      if (this.privState === PromiseState.None) {
        this.privSuccessHandlers.push(successCallback);
        this.privErrorHandlers.push(errorCallback);
      } else {
        if (this.privState === PromiseState.Resolved) {
          this.executeSuccessCallback(this.privPromiseResult.result, successCallback, errorCallback);
        } else if (this.privState === PromiseState.Rejected) {
          this.executeErrorCallback(this.privPromiseResult.error, errorCallback);
        }
        this.detachHandlers();
      }
    }
    executeSuccessCallback(result, successCallback, errorCallback) {
      try {
        successCallback(result);
      } catch (e) {
        this.executeErrorCallback(`'Unhandled callback error: ${e}'`, errorCallback);
      }
    }
    executeErrorCallback(error, errorCallback) {
      if (errorCallback) {
        try {
          errorCallback(error);
        } catch (e) {
          throw new Error(`'Unhandled callback error: ${e}. InnerError: ${error}'`);
        }
      } else {
        throw new Error(`'Unhandled error: ${error}'`);
      }
    }
    detachHandlers() {
      this.privErrorHandlers = [];
      this.privSuccessHandlers = [];
    }
  }
  exports.Sink = Sink;
  function marshalPromiseToCallbacks(promise, cb2, err2) {
    promise.then((val) => {
      try {
        if (!!cb2) {
          cb2(val);
        }
      } catch (error) {
        if (!!err2) {
          try {
            if (error instanceof Error) {
              const typedError = error;
              err2(typedError.name + ": " + typedError.message);
            } else {
              err2(error);
            }
          } catch (error2) {
          }
        }
      }
    }, (error) => {
      if (!!err2) {
        try {
          if (error instanceof Error) {
            const typedError = error;
            err2(typedError.name + ": " + typedError.message);
          } else {
            err2(error);
          }
        } catch (error2) {
        }
      }
    });
  }
  exports.marshalPromiseToCallbacks = marshalPromiseToCallbacks;
})(_Promise);
var Queue$1 = {};
Object.defineProperty(Queue$1, "__esModule", { value: true });
Queue$1.Queue = void 0;
const Error_js_1$3 = _Error;
const List_js_1 = List$1;
const Promise_js_1 = _Promise;
var SubscriberType;
(function(SubscriberType2) {
  SubscriberType2[SubscriberType2["Dequeue"] = 0] = "Dequeue";
  SubscriberType2[SubscriberType2["Peek"] = 1] = "Peek";
})(SubscriberType || (SubscriberType = {}));
class Queue {
  constructor(list2) {
    this.privPromiseStore = new List_js_1.List();
    this.privIsDrainInProgress = false;
    this.privIsDisposing = false;
    this.privDisposeReason = null;
    this.privList = list2 ? list2 : new List_js_1.List();
    this.privDetachables = [];
    this.privSubscribers = new List_js_1.List();
    this.privDetachables.push(this.privList.onAdded(() => this.drain()));
  }
  enqueue(item) {
    this.throwIfDispose();
    this.enqueueFromPromise(new Promise((resolve) => resolve(item)));
  }
  enqueueFromPromise(promise) {
    this.throwIfDispose();
    promise.then((val) => {
      this.privList.add(val);
    }, () => {
    });
  }
  dequeue() {
    this.throwIfDispose();
    const deferredSubscriber = new Promise_js_1.Deferred();
    if (this.privSubscribers) {
      this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });
      this.drain();
    }
    return deferredSubscriber.promise;
  }
  peek() {
    this.throwIfDispose();
    const deferredSubscriber = new Promise_js_1.Deferred();
    const subs = this.privSubscribers;
    if (subs) {
      this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });
      this.drain();
    }
    return deferredSubscriber.promise;
  }
  length() {
    this.throwIfDispose();
    return this.privList.length();
  }
  isDisposed() {
    return this.privSubscribers == null;
  }
  async drainAndDispose(pendingItemProcessor, reason) {
    if (!this.isDisposed() && !this.privIsDisposing) {
      this.privDisposeReason = reason;
      this.privIsDisposing = true;
      const subs = this.privSubscribers;
      if (subs) {
        while (subs.length() > 0) {
          const subscriber = subs.removeFirst();
          subscriber.deferral.resolve(void 0);
        }
        if (this.privSubscribers === subs) {
          this.privSubscribers = subs;
        }
      }
      for (const detachable of this.privDetachables) {
        await detachable.detach();
      }
      if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {
        const promiseArray = [];
        this.privPromiseStore.toArray().forEach((wrapper) => {
          promiseArray.push(wrapper);
        });
        return Promise.all(promiseArray).finally(() => {
          this.privSubscribers = null;
          this.privList.forEach((item) => {
            pendingItemProcessor(item);
          });
          this.privList = null;
          return;
        }).then();
      } else {
        this.privSubscribers = null;
        this.privList = null;
      }
    }
  }
  async dispose(reason) {
    await this.drainAndDispose(null, reason);
  }
  drain() {
    if (!this.privIsDrainInProgress && !this.privIsDisposing) {
      this.privIsDrainInProgress = true;
      const subs = this.privSubscribers;
      const lists = this.privList;
      if (subs && lists) {
        while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {
          const subscriber = subs.removeFirst();
          if (subscriber.type === SubscriberType.Peek) {
            subscriber.deferral.resolve(lists.first());
          } else {
            const dequeuedItem = lists.removeFirst();
            subscriber.deferral.resolve(dequeuedItem);
          }
        }
        if (this.privSubscribers === subs) {
          this.privSubscribers = subs;
        }
        if (this.privList === lists) {
          this.privList = lists;
        }
      }
      this.privIsDrainInProgress = false;
    }
  }
  throwIfDispose() {
    if (this.isDisposed()) {
      if (this.privDisposeReason) {
        throw new Error_js_1$3.InvalidOperationError(this.privDisposeReason);
      }
      throw new Error_js_1$3.ObjectDisposedError("Queue");
    } else if (this.privIsDisposing) {
      throw new Error_js_1$3.InvalidOperationError("Queue disposing");
    }
  }
}
Queue$1.Queue = Queue;
var RawWebsocketMessage$1 = {};
Object.defineProperty(RawWebsocketMessage$1, "__esModule", { value: true });
RawWebsocketMessage$1.RawWebsocketMessage = void 0;
const ConnectionMessage_js_1 = ConnectionMessage$1;
const Error_js_1$2 = _Error;
const Guid_js_1$1 = Guid;
class RawWebsocketMessage {
  constructor(messageType, payload, id2) {
    this.privPayload = null;
    if (!payload) {
      throw new Error_js_1$2.ArgumentNullError("payload");
    }
    if (messageType === ConnectionMessage_js_1.MessageType.Binary && Object.getPrototypeOf(payload).constructor.name !== "ArrayBuffer") {
      throw new Error_js_1$2.InvalidOperationError("Payload must be ArrayBuffer");
    }
    if (messageType === ConnectionMessage_js_1.MessageType.Text && !(typeof payload === "string")) {
      throw new Error_js_1$2.InvalidOperationError("Payload must be a string");
    }
    this.privMessageType = messageType;
    this.privPayload = payload;
    this.privId = id2 ? id2 : Guid_js_1$1.createNoDashGuid();
  }
  get messageType() {
    return this.privMessageType;
  }
  get payload() {
    return this.privPayload;
  }
  get textContent() {
    if (this.privMessageType === ConnectionMessage_js_1.MessageType.Binary) {
      throw new Error_js_1$2.InvalidOperationError("Not supported for binary message");
    }
    return this.privPayload;
  }
  get binaryContent() {
    if (this.privMessageType === ConnectionMessage_js_1.MessageType.Text) {
      throw new Error_js_1$2.InvalidOperationError("Not supported for text message");
    }
    return this.privPayload;
  }
  get id() {
    return this.privId;
  }
}
RawWebsocketMessage$1.RawWebsocketMessage = RawWebsocketMessage;
var RiffPcmEncoder$1 = {};
Object.defineProperty(RiffPcmEncoder$1, "__esModule", { value: true });
RiffPcmEncoder$1.RiffPcmEncoder = void 0;
class RiffPcmEncoder {
  constructor(actualSampleRate, desiredSampleRate) {
    this.privActualSampleRate = actualSampleRate;
    this.privDesiredSampleRate = desiredSampleRate;
  }
  encode(actualAudioFrame) {
    const audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);
    if (!audioFrame) {
      return null;
    }
    const audioLength = audioFrame.length * 2;
    const buffer = new ArrayBuffer(audioLength);
    const view = new DataView(buffer);
    this.floatTo16BitPCM(view, 0, audioFrame);
    return buffer;
  }
  setString(view, offset, str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset + i, str.charCodeAt(i));
    }
  }
  floatTo16BitPCM(view, offset, input) {
    for (let i = 0; i < input.length; i++, offset += 2) {
      const s = Math.max(-1, Math.min(1, input[i]));
      view.setInt16(offset, s < 0 ? s * 32768 : s * 32767, true);
    }
  }
  downSampleAudioFrame(srcFrame, srcRate, dstRate) {
    if (!srcFrame) {
      return null;
    }
    if (dstRate === srcRate || dstRate > srcRate) {
      return srcFrame;
    }
    const ratio = srcRate / dstRate;
    const dstLength = Math.round(srcFrame.length / ratio);
    const dstFrame = new Float32Array(dstLength);
    let srcOffset = 0;
    let dstOffset = 0;
    while (dstOffset < dstLength) {
      const nextSrcOffset = Math.round((dstOffset + 1) * ratio);
      let accum = 0;
      let count = 0;
      while (srcOffset < nextSrcOffset && srcOffset < srcFrame.length) {
        accum += srcFrame[srcOffset++];
        count++;
      }
      dstFrame[dstOffset++] = accum / count;
    }
    return dstFrame;
  }
}
RiffPcmEncoder$1.RiffPcmEncoder = RiffPcmEncoder;
var Stream$1 = {};
Object.defineProperty(Stream$1, "__esModule", { value: true });
Stream$1.Stream = void 0;
const Error_js_1$1 = _Error;
const Guid_js_1 = Guid;
const Queue_js_1 = Queue$1;
class Stream {
  constructor(streamId) {
    this.privIsWriteEnded = false;
    this.privIsReadEnded = false;
    this.privId = streamId ? streamId : Guid_js_1.createNoDashGuid();
    this.privReaderQueue = new Queue_js_1.Queue();
  }
  get isClosed() {
    return this.privIsWriteEnded;
  }
  get isReadEnded() {
    return this.privIsReadEnded;
  }
  get id() {
    return this.privId;
  }
  close() {
    if (!this.privIsWriteEnded) {
      this.writeStreamChunk({
        buffer: null,
        isEnd: true,
        timeReceived: Date.now()
      });
      this.privIsWriteEnded = true;
    }
  }
  writeStreamChunk(streamChunk) {
    this.throwIfClosed();
    if (!this.privReaderQueue.isDisposed()) {
      try {
        this.privReaderQueue.enqueue(streamChunk);
      } catch (e) {
      }
    }
  }
  read() {
    if (this.privIsReadEnded) {
      throw new Error_js_1$1.InvalidOperationError("Stream read has already finished");
    }
    return this.privReaderQueue.dequeue().then(async (streamChunk) => {
      if (streamChunk === void 0 || streamChunk.isEnd) {
        await this.privReaderQueue.dispose("End of stream reached");
      }
      return streamChunk;
    });
  }
  readEnded() {
    if (!this.privIsReadEnded) {
      this.privIsReadEnded = true;
      this.privReaderQueue = new Queue_js_1.Queue();
    }
  }
  throwIfClosed() {
    if (this.privIsWriteEnded) {
      throw new Error_js_1$1.InvalidOperationError("Stream closed");
    }
  }
}
Stream$1.Stream = Stream;
var TranslationStatus = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TranslationStatus = void 0;
  (function(TranslationStatus2) {
    TranslationStatus2[TranslationStatus2["Success"] = 0] = "Success";
    TranslationStatus2[TranslationStatus2["Error"] = 1] = "Error";
  })(exports.TranslationStatus || (exports.TranslationStatus = {}));
})(TranslationStatus);
var ChunkedArrayBufferStream = {};
var hasRequiredChunkedArrayBufferStream;
function requireChunkedArrayBufferStream() {
  if (hasRequiredChunkedArrayBufferStream) return ChunkedArrayBufferStream;
  hasRequiredChunkedArrayBufferStream = 1;
  Object.defineProperty(ChunkedArrayBufferStream, "__esModule", { value: true });
  ChunkedArrayBufferStream.ChunkedArrayBufferStream = void 0;
  const Exports_js_12 = requireExports$5();
  let ChunkedArrayBufferStream$1 = class ChunkedArrayBufferStream extends Exports_js_12.Stream {
    constructor(targetChunkSize, streamId) {
      super(streamId);
      this.privTargetChunkSize = targetChunkSize;
      this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(chunk) {
      if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(chunk);
        return;
      }
      let bytesCopiedFromBuffer = 0;
      while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {
        if (void 0 === this.privNextBufferToWrite) {
          this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);
          this.privNextBufferStartTime = chunk.timeReceived;
        }
        const bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);
        const targetView = new Uint8Array(this.privNextBufferToWrite);
        const sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));
        targetView.set(sourceView, this.privNextBufferReadyBytes);
        this.privNextBufferReadyBytes += bytesToCopy;
        bytesCopiedFromBuffer += bytesToCopy;
        if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {
          super.writeStreamChunk({
            buffer: this.privNextBufferToWrite,
            isEnd: false,
            timeReceived: this.privNextBufferStartTime
          });
          this.privNextBufferReadyBytes = 0;
          this.privNextBufferToWrite = void 0;
        }
      }
    }
    close() {
      if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {
        super.writeStreamChunk({
          buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
          isEnd: false,
          timeReceived: this.privNextBufferStartTime
        });
      }
      super.close();
    }
  };
  ChunkedArrayBufferStream.ChunkedArrayBufferStream = ChunkedArrayBufferStream$1;
  return ChunkedArrayBufferStream;
}
var IAudioDestination = {};
Object.defineProperty(IAudioDestination, "__esModule", { value: true });
var Timeout$1 = {};
Object.defineProperty(Timeout$1, "__esModule", { value: true });
Timeout$1.Timeout = void 0;
class Timeout {
  static load() {
    const scheduledTimeoutFunctions = /* @__PURE__ */ new Map([[0, () => {
    }]]);
    const unhandledRequests = /* @__PURE__ */ new Map();
    const workerScript = `!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`;
    const workerUrl = "data:text/javascript;base64," + btoa(workerScript);
    const worker = new Worker(workerUrl);
    worker.addEventListener("message", ({ data }) => {
      if (Timeout.isCallNotification(data)) {
        const { params: { timerId } } = data;
        const idOrFunc = scheduledTimeoutFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const unhandledTimerId = unhandledRequests.get(idOrFunc);
          if (unhandledTimerId === void 0 || unhandledTimerId !== timerId) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
          scheduledTimeoutFunctions.delete(timerId);
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      } else if (Timeout.isClearResponse(data)) {
        const { id: id2 } = data;
        const unhandledTimerId = unhandledRequests.get(id2);
        if (unhandledTimerId === void 0) {
          throw new Error("The timer is in an undefined state.");
        }
        unhandledRequests.delete(id2);
        scheduledTimeoutFunctions.delete(unhandledTimerId);
      } else {
        const { error: { message } } = data;
        throw new Error(message);
      }
    });
    const clearTimeout2 = (timerId) => {
      const id2 = Math.random();
      unhandledRequests.set(id2, timerId);
      scheduledTimeoutFunctions.set(timerId, id2);
      worker.postMessage({
        id: id2,
        method: "clear",
        params: { timerId }
      });
    };
    const setTimeout2 = (func, delay) => {
      const timerId = Math.random();
      scheduledTimeoutFunctions.set(timerId, func);
      worker.postMessage({
        id: null,
        method: "set",
        params: {
          delay,
          now: performance.now(),
          timerId
        }
      });
      return timerId;
    };
    return {
      clearTimeout: clearTimeout2,
      setTimeout: setTimeout2
    };
  }
  static loadWorkerTimers() {
    return () => {
      if (Timeout.workerTimers !== null) {
        return Timeout.workerTimers;
      }
      Timeout.workerTimers = Timeout.load();
      return Timeout.workerTimers;
    };
  }
  static isCallNotification(message) {
    return message.method !== void 0 && message.method === "call";
  }
  static isClearResponse(message) {
    return message.error === null && typeof message.id === "number";
  }
}
Timeout$1.Timeout = Timeout;
Timeout.workerTimers = null;
Timeout.clearTimeout = (timerId) => Timeout.timers().clearTimeout(timerId);
Timeout.setTimeout = (func, delay) => Timeout.timers().setTimeout(func, delay);
Timeout.timers = Timeout.loadWorkerTimers();
var OCSPEvents = {};
Object.defineProperty(OCSPEvents, "__esModule", { value: true });
OCSPEvents.OCSPCacheUpdateErrorEvent = OCSPEvents.OCSPResponseRetrievedEvent = OCSPEvents.OCSPCacheFetchErrorEvent = OCSPEvents.OCSPVerificationFailedEvent = OCSPEvents.OCSPCacheHitEvent = OCSPEvents.OCSPCacheEntryNeedsRefreshEvent = OCSPEvents.OCSPCacheEntryExpiredEvent = OCSPEvents.OCSPWSUpgradeStartedEvent = OCSPEvents.OCSPStapleReceivedEvent = OCSPEvents.OCSPCacheUpdateCompleteEvent = OCSPEvents.OCSPDiskCacheStoreEvent = OCSPEvents.OCSPMemoryCacheStoreEvent = OCSPEvents.OCSPCacheUpdateNeededEvent = OCSPEvents.OCSPDiskCacheHitEvent = OCSPEvents.OCSPCacheMissEvent = OCSPEvents.OCSPMemoryCacheHitEvent = OCSPEvents.OCSPEvent = void 0;
const PlatformEvent_js_1 = PlatformEvent;
class OCSPEvent extends PlatformEvent_js_1.PlatformEvent {
  constructor(eventName, eventType, signature) {
    super(eventName, eventType);
    this.privSignature = signature;
  }
}
OCSPEvents.OCSPEvent = OCSPEvent;
class OCSPMemoryCacheHitEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPMemoryCacheHitEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPMemoryCacheHitEvent = OCSPMemoryCacheHitEvent;
class OCSPCacheMissEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPCacheMissEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPCacheMissEvent = OCSPCacheMissEvent;
class OCSPDiskCacheHitEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPDiskCacheHitEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPDiskCacheHitEvent = OCSPDiskCacheHitEvent;
class OCSPCacheUpdateNeededEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPCacheUpdateNeededEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPCacheUpdateNeededEvent = OCSPCacheUpdateNeededEvent;
class OCSPMemoryCacheStoreEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPMemoryCacheStoreEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPMemoryCacheStoreEvent = OCSPMemoryCacheStoreEvent;
class OCSPDiskCacheStoreEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPDiskCacheStoreEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPDiskCacheStoreEvent = OCSPDiskCacheStoreEvent;
class OCSPCacheUpdateCompleteEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPCacheUpdateCompleteEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
OCSPEvents.OCSPCacheUpdateCompleteEvent = OCSPCacheUpdateCompleteEvent;
class OCSPStapleReceivedEvent extends OCSPEvent {
  constructor() {
    super("OCSPStapleReceivedEvent", PlatformEvent_js_1.EventType.Debug, "");
  }
}
OCSPEvents.OCSPStapleReceivedEvent = OCSPStapleReceivedEvent;
class OCSPWSUpgradeStartedEvent extends OCSPEvent {
  constructor(serialNumber) {
    super("OCSPWSUpgradeStartedEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
  }
}
OCSPEvents.OCSPWSUpgradeStartedEvent = OCSPWSUpgradeStartedEvent;
class OCSPCacheEntryExpiredEvent extends OCSPEvent {
  constructor(serialNumber, expireTime) {
    super("OCSPCacheEntryExpiredEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privExpireTime = expireTime;
  }
}
OCSPEvents.OCSPCacheEntryExpiredEvent = OCSPCacheEntryExpiredEvent;
class OCSPCacheEntryNeedsRefreshEvent extends OCSPEvent {
  constructor(serialNumber, startTime, expireTime) {
    super("OCSPCacheEntryNeedsRefreshEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privExpireTime = expireTime;
    this.privStartTime = startTime;
  }
}
OCSPEvents.OCSPCacheEntryNeedsRefreshEvent = OCSPCacheEntryNeedsRefreshEvent;
class OCSPCacheHitEvent extends OCSPEvent {
  constructor(serialNumber, startTime, expireTime) {
    super("OCSPCacheHitEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privExpireTime = expireTime;
    this.privExpireTimeString = new Date(expireTime).toLocaleDateString();
    this.privStartTime = startTime;
    this.privStartTimeString = new Date(startTime).toLocaleTimeString();
  }
}
OCSPEvents.OCSPCacheHitEvent = OCSPCacheHitEvent;
class OCSPVerificationFailedEvent extends OCSPEvent {
  constructor(serialNumber, error) {
    super("OCSPVerificationFailedEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privError = error;
  }
}
OCSPEvents.OCSPVerificationFailedEvent = OCSPVerificationFailedEvent;
class OCSPCacheFetchErrorEvent extends OCSPEvent {
  constructor(serialNumber, error) {
    super("OCSPCacheFetchErrorEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privError = error;
  }
}
OCSPEvents.OCSPCacheFetchErrorEvent = OCSPCacheFetchErrorEvent;
class OCSPResponseRetrievedEvent extends OCSPEvent {
  constructor(serialNumber) {
    super("OCSPResponseRetrievedEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
  }
}
OCSPEvents.OCSPResponseRetrievedEvent = OCSPResponseRetrievedEvent;
class OCSPCacheUpdateErrorEvent extends OCSPEvent {
  constructor(serialNumber, error) {
    super("OCSPCacheUpdateErrorEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privError = error;
  }
}
OCSPEvents.OCSPCacheUpdateErrorEvent = OCSPCacheUpdateErrorEvent;
var BackgroundError = {};
var hasRequiredBackgroundError;
function requireBackgroundError() {
  if (hasRequiredBackgroundError) return BackgroundError;
  hasRequiredBackgroundError = 1;
  Object.defineProperty(BackgroundError, "__esModule", { value: true });
  BackgroundError.BackgroundEvent = void 0;
  const Exports_js_12 = requireExports$5();
  class BackgroundEvent extends Exports_js_12.PlatformEvent {
    constructor(error) {
      super("BackgroundEvent", Exports_js_12.EventType.Error);
      this.privError = error;
    }
    get error() {
      return this.privError;
    }
  }
  BackgroundError.BackgroundEvent = BackgroundEvent;
  return BackgroundError;
}
var hasRequiredExports$5;
function requireExports$5() {
  if (hasRequiredExports$5) return Exports$5;
  hasRequiredExports$5 = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !exports2.hasOwnProperty(p2)) __createBinding2(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(AudioSourceEvents, exports);
    __exportStar(ConnectionEvents, exports);
    __exportStar(ConnectionMessage$1, exports);
    __exportStar(ConnectionOpenResponse$1, exports);
    __exportStar(DeferralMap$1, exports);
    __exportStar(DialogEvents, exports);
    __exportStar(_Error, exports);
    __exportStar(Events$1, exports);
    __exportStar(EventSource$1, exports);
    __exportStar(Guid, exports);
    __exportStar(IAudioSource, exports);
    __exportStar(IConnection, exports);
    __exportStar(IDetachable, exports);
    __exportStar(IDictionary, exports);
    __exportStar(IDisposable, exports);
    __exportStar(IEventListener, exports);
    __exportStar(IEventSource, exports);
    __exportStar(IErrorMessages, exports);
    __exportStar(ITimer, exports);
    __exportStar(IWebsocketMessageFormatter, exports);
    __exportStar(List$1, exports);
    __exportStar(PlatformEvent, exports);
    __exportStar(_Promise, exports);
    __exportStar(Queue$1, exports);
    __exportStar(RawWebsocketMessage$1, exports);
    __exportStar(RiffPcmEncoder$1, exports);
    __exportStar(Stream$1, exports);
    var TranslationStatus_js_12 = TranslationStatus;
    Object.defineProperty(exports, "TranslationStatus", { enumerable: true, get: function() {
      return TranslationStatus_js_12.TranslationStatus;
    } });
    __exportStar(requireChunkedArrayBufferStream(), exports);
    __exportStar(IAudioDestination, exports);
    __exportStar(Timeout$1, exports);
    __exportStar(OCSPEvents, exports);
    __exportStar(requireBackgroundError(), exports);
  })(Exports$5);
  return Exports$5;
}
var HeaderNames$1 = {};
Object.defineProperty(HeaderNames$1, "__esModule", { value: true });
HeaderNames$1.HeaderNames = void 0;
class HeaderNames {
}
HeaderNames$1.HeaderNames = HeaderNames;
HeaderNames.AuthKey = "Ocp-Apim-Subscription-Key";
HeaderNames.Authorization = "Authorization";
HeaderNames.SpIDAuthKey = "Apim-Subscription-Id";
HeaderNames.ConnectionId = "X-ConnectionId";
HeaderNames.ContentType = "Content-Type";
HeaderNames.CustomCommandsAppId = "X-CommandsAppId";
HeaderNames.Path = "Path";
HeaderNames.RequestId = "X-RequestId";
HeaderNames.RequestStreamId = "X-StreamId";
HeaderNames.RequestTimestamp = "X-Timestamp";
var IAuthentication = {};
Object.defineProperty(IAuthentication, "__esModule", { value: true });
IAuthentication.AuthInfo = void 0;
class AuthInfo {
  constructor(headerName, token) {
    this.privHeaderName = headerName;
    this.privToken = token;
  }
  get headerName() {
    return this.privHeaderName;
  }
  get token() {
    return this.privToken;
  }
}
IAuthentication.AuthInfo = AuthInfo;
Object.defineProperty(CognitiveSubscriptionKeyAuthentication$1, "__esModule", { value: true });
CognitiveSubscriptionKeyAuthentication$1.CognitiveSubscriptionKeyAuthentication = void 0;
const Exports_js_1$d = requireExports$5();
const HeaderNames_js_1$3 = HeaderNames$1;
const IAuthentication_js_1$1 = IAuthentication;
class CognitiveSubscriptionKeyAuthentication {
  /**
   * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
   * @constructor
   * @param {string} subscriptionKey - The subscription key
   */
  constructor(subscriptionKey) {
    if (!subscriptionKey) {
      throw new Exports_js_1$d.ArgumentNullError("subscriptionKey");
    }
    this.privAuthInfo = new IAuthentication_js_1$1.AuthInfo(HeaderNames_js_1$3.HeaderNames.AuthKey, subscriptionKey);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetch(authFetchEventId) {
    return Promise.resolve(this.privAuthInfo);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetchOnExpiry(authFetchEventId) {
    return Promise.resolve(this.privAuthInfo);
  }
}
CognitiveSubscriptionKeyAuthentication$1.CognitiveSubscriptionKeyAuthentication = CognitiveSubscriptionKeyAuthentication;
var CognitiveTokenAuthentication$1 = {};
Object.defineProperty(CognitiveTokenAuthentication$1, "__esModule", { value: true });
CognitiveTokenAuthentication$1.CognitiveTokenAuthentication = void 0;
const Exports_js_1$c = requireExports$5();
const IAuthentication_js_1 = IAuthentication;
const HeaderNames_js_1$2 = HeaderNames$1;
class CognitiveTokenAuthentication {
  constructor(fetchCallback, fetchOnExpiryCallback) {
    if (!fetchCallback) {
      throw new Exports_js_1$c.ArgumentNullError("fetchCallback");
    }
    if (!fetchOnExpiryCallback) {
      throw new Exports_js_1$c.ArgumentNullError("fetchOnExpiryCallback");
    }
    this.privFetchCallback = fetchCallback;
    this.privFetchOnExpiryCallback = fetchOnExpiryCallback;
  }
  fetch(authFetchEventId) {
    return this.privFetchCallback(authFetchEventId).then((token) => new IAuthentication_js_1.AuthInfo(HeaderNames_js_1$2.HeaderNames.Authorization, token === void 0 ? void 0 : CognitiveTokenAuthentication.privTokenPrefix + token));
  }
  fetchOnExpiry(authFetchEventId) {
    return this.privFetchOnExpiryCallback(authFetchEventId).then((token) => new IAuthentication_js_1.AuthInfo(HeaderNames_js_1$2.HeaderNames.Authorization, token === void 0 ? void 0 : CognitiveTokenAuthentication.privTokenPrefix + token));
  }
}
CognitiveTokenAuthentication$1.CognitiveTokenAuthentication = CognitiveTokenAuthentication;
CognitiveTokenAuthentication.privTokenPrefix = "Bearer ";
var IConnectionFactory = {};
Object.defineProperty(IConnectionFactory, "__esModule", { value: true });
var ISynthesisConnectionFactory = {};
Object.defineProperty(ISynthesisConnectionFactory, "__esModule", { value: true });
var IntentConnectionFactory = {};
var Exports$4 = {};
var ConsoleLoggingListener$1 = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var LogLevel = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LogLevel = void 0;
  const Exports_js_12 = requireExports$5();
  Object.defineProperty(exports, "LogLevel", { enumerable: true, get: function() {
    return Exports_js_12.EventType;
  } });
})(LogLevel);
var Contracts$1 = {};
Object.defineProperty(Contracts$1, "__esModule", { value: true });
Contracts$1.Contracts = void 0;
class Contracts {
  static throwIfNullOrUndefined(param, name2) {
    if (param === void 0 || param === null) {
      throw new Error("throwIfNullOrUndefined:" + name2);
    }
  }
  static throwIfNull(param, name2) {
    if (param === null) {
      throw new Error("throwIfNull:" + name2);
    }
  }
  static throwIfNullOrWhitespace(param, name2) {
    Contracts.throwIfNullOrUndefined(param, name2);
    if (("" + param).trim().length < 1) {
      throw new Error("throwIfNullOrWhitespace:" + name2);
    }
  }
  static throwIfNullOrTooLong(param, name2, maxLength) {
    Contracts.throwIfNullOrUndefined(param, name2);
    if (("" + param).length > maxLength) {
      throw new Error("throwIfNullOrTooLong:" + name2 + " (more than " + maxLength.toString() + " characters)");
    }
  }
  static throwIfNullOrTooShort(param, name2, minLength) {
    Contracts.throwIfNullOrUndefined(param, name2);
    if (("" + param).length < minLength) {
      throw new Error("throwIfNullOrTooShort:" + name2 + " (less than " + minLength.toString() + " characters)");
    }
  }
  static throwIfDisposed(isDisposed) {
    if (isDisposed) {
      throw new Error("the object is already disposed");
    }
  }
  static throwIfArrayEmptyOrWhitespace(array, name2) {
    Contracts.throwIfNullOrUndefined(array, name2);
    if (array.length === 0) {
      throw new Error("throwIfArrayEmptyOrWhitespace:" + name2);
    }
    for (const item of array) {
      Contracts.throwIfNullOrWhitespace(item, name2);
    }
  }
  static throwIfFileDoesNotExist(param, name2) {
    Contracts.throwIfNullOrWhitespace(param, name2);
  }
  static throwIfNotUndefined(param, name2) {
    if (param !== void 0) {
      throw new Error("throwIfNotUndefined:" + name2);
    }
  }
}
Contracts$1.Contracts = Contracts;
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  Object.defineProperty(o, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o[k22] = m2[k2];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
  Object.defineProperty(o, "default", { enumerable: true, value: v2 });
} : function(o, v2) {
  o["default"] = v2;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding$2(result, mod, k2);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
Object.defineProperty(ConsoleLoggingListener$1, "__esModule", { value: true });
ConsoleLoggingListener$1.ConsoleLoggingListener = void 0;
const fs$1 = __importStar$2(require$$0);
const LogLevel_js_1 = LogLevel;
const Contracts_js_1$7 = Contracts$1;
class ConsoleLoggingListener {
  constructor(logLevelFilter = LogLevel_js_1.LogLevel.None) {
    this.privLogPath = void 0;
    this.privEnableConsoleOutput = true;
    this.privLogLevelFilter = logLevelFilter;
  }
  set logPath(path) {
    Contracts_js_1$7.Contracts.throwIfNullOrUndefined(fs$1.openSync, "\nFile System access not available");
    this.privLogPath = path;
  }
  set enableConsoleOutput(enableOutput) {
    this.privEnableConsoleOutput = enableOutput;
  }
  onEvent(event) {
    if (event.eventType >= this.privLogLevelFilter) {
      const log = this.toString(event);
      if (!!this.logCallback) {
        this.logCallback(log);
      }
      if (!!this.privLogPath) {
        fs$1.writeFileSync(this.privLogPath, log + "\n", { flag: "a+" });
      }
      if (this.privEnableConsoleOutput) {
        switch (event.eventType) {
          case LogLevel_js_1.LogLevel.Debug:
            console.debug(log);
            break;
          case LogLevel_js_1.LogLevel.Info:
            console.info(log);
            break;
          case LogLevel_js_1.LogLevel.Warning:
            console.warn(log);
            break;
          case LogLevel_js_1.LogLevel.Error:
            console.error(log);
            break;
          default:
            console.log(log);
            break;
        }
      }
    }
  }
  toString(event) {
    const logFragments = [
      `${event.eventTime}`,
      `${event.name}`
    ];
    const e = event;
    for (const prop in e) {
      if (prop && event.hasOwnProperty(prop) && prop !== "eventTime" && prop !== "eventType" && prop !== "eventId" && prop !== "name" && prop !== "constructor") {
        const value = e[prop];
        let valueToLog = "<NULL>";
        if (value !== void 0 && value !== null) {
          if (typeof value === "number" || typeof value === "string") {
            valueToLog = value.toString();
          } else {
            valueToLog = JSON.stringify(value);
          }
        }
        logFragments.push(`${prop}: ${valueToLog}`);
      }
    }
    return logFragments.join(" | ");
  }
}
ConsoleLoggingListener$1.ConsoleLoggingListener = ConsoleLoggingListener;
var IRecorder = {};
Object.defineProperty(IRecorder, "__esModule", { value: true });
var MicAudioSource = {};
var AudioStreamFormat = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AudioStreamFormatImpl = exports.AudioStreamFormat = exports.AudioFormatTag = void 0;
  var AudioFormatTag;
  (function(AudioFormatTag2) {
    AudioFormatTag2[AudioFormatTag2["PCM"] = 1] = "PCM";
    AudioFormatTag2[AudioFormatTag2["MuLaw"] = 2] = "MuLaw";
    AudioFormatTag2[AudioFormatTag2["Siren"] = 3] = "Siren";
    AudioFormatTag2[AudioFormatTag2["MP3"] = 4] = "MP3";
    AudioFormatTag2[AudioFormatTag2["SILKSkype"] = 5] = "SILKSkype";
    AudioFormatTag2[AudioFormatTag2["OGG_OPUS"] = 6] = "OGG_OPUS";
    AudioFormatTag2[AudioFormatTag2["WEBM_OPUS"] = 7] = "WEBM_OPUS";
    AudioFormatTag2[AudioFormatTag2["ALaw"] = 8] = "ALaw";
    AudioFormatTag2[AudioFormatTag2["FLAC"] = 9] = "FLAC";
    AudioFormatTag2[AudioFormatTag2["OPUS"] = 10] = "OPUS";
    AudioFormatTag2[AudioFormatTag2["AMR_WB"] = 11] = "AMR_WB";
    AudioFormatTag2[AudioFormatTag2["G722"] = 12] = "G722";
  })(AudioFormatTag = exports.AudioFormatTag || (exports.AudioFormatTag = {}));
  class AudioStreamFormat2 {
    /**
     * Creates an audio stream format object representing the default audio stream
     * format (16KHz 16bit mono PCM).
     * @member AudioStreamFormat.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getDefaultInputFormat() {
      return AudioStreamFormatImpl.getDefaultInputFormat();
    }
    /**
     * Creates an audio stream format object with the specified format characteristics.
     * @member AudioStreamFormat.getWaveFormat
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getWaveFormat(samplesPerSecond, bitsPerSample, channels, format) {
      return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels, format);
    }
    /**
     * Creates an audio stream format object with the specified pcm waveformat characteristics.
     * @member AudioStreamFormat.getWaveFormatPCM
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getWaveFormatPCM(samplesPerSecond, bitsPerSample, channels) {
      return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels);
    }
  }
  exports.AudioStreamFormat = AudioStreamFormat2;
  class AudioStreamFormatImpl extends AudioStreamFormat2 {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {number} channels - Number of channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     */
    constructor(samplesPerSec = 16e3, bitsPerSample = 16, channels = 1, format = AudioFormatTag.PCM) {
      super();
      let isWavFormat = true;
      switch (format) {
        case AudioFormatTag.PCM:
          this.formatTag = 1;
          break;
        case AudioFormatTag.ALaw:
          this.formatTag = 6;
          break;
        case AudioFormatTag.MuLaw:
          this.formatTag = 7;
          break;
        default:
          isWavFormat = false;
      }
      this.bitsPerSample = bitsPerSample;
      this.samplesPerSec = samplesPerSec;
      this.channels = channels;
      this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8);
      this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8);
      if (isWavFormat) {
        this.privHeader = new ArrayBuffer(44);
        const view = new DataView(this.privHeader);
        this.setString(view, 0, "RIFF");
        view.setUint32(4, 0, true);
        this.setString(view, 8, "WAVEfmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, this.formatTag, true);
        view.setUint16(22, this.channels, true);
        view.setUint32(24, this.samplesPerSec, true);
        view.setUint32(28, this.avgBytesPerSec, true);
        view.setUint16(32, this.channels * (this.bitsPerSample / 8), true);
        view.setUint16(34, this.bitsPerSample, true);
        this.setString(view, 36, "data");
        view.setUint32(40, 0, true);
      }
    }
    /**
     * Retrieves the default input format.
     * @member AudioStreamFormatImpl.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormatImpl} The default input format.
     */
    static getDefaultInputFormat() {
      return new AudioStreamFormatImpl();
    }
    /**
     * Creates an audio context appropriate to current browser
     * @member AudioStreamFormatImpl.getAudioContext
     * @function
     * @public
     * @returns {AudioContext} An audio context instance
     */
    /* eslint-disable */
    static getAudioContext(sampleRate) {
      const AudioContext2 = window.AudioContext || window.webkitAudioContext || false;
      if (!!AudioContext2) {
        if (sampleRate !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate) {
          return new AudioContext2({ sampleRate });
        } else {
          return new AudioContext2();
        }
      } else {
        throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
      }
    }
    /* eslint-enable */
    /**
     * Closes the configuration object.
     * @member AudioStreamFormatImpl.prototype.close
     * @function
     * @public
     */
    close() {
      return;
    }
    get header() {
      return this.privHeader;
    }
    setString(view, offset, str) {
      for (let i = 0; i < str.length; i++) {
        view.setUint8(offset + i, str.charCodeAt(i));
      }
    }
  }
  exports.AudioStreamFormatImpl = AudioStreamFormatImpl;
})(AudioStreamFormat);
var hasRequiredMicAudioSource;
function requireMicAudioSource() {
  if (hasRequiredMicAudioSource) return MicAudioSource;
  hasRequiredMicAudioSource = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MicAudioSource = exports.AudioWorkletSourceURLPropertyName = void 0;
    const Exports_js_12 = requireExports();
    const Exports_js_2 = requireExports$5();
    const AudioStreamFormat_js_12 = AudioStreamFormat;
    exports.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class MicAudioSource2 {
      constructor(privRecorder, deviceId, audioSourceId, mediaStream) {
        this.privRecorder = privRecorder;
        this.deviceId = deviceId;
        this.privStreams = {};
        this.privOutputChunkSize = MicAudioSource2.AUDIOFORMAT.avgBytesPerSec / 10;
        this.privId = audioSourceId ? audioSourceId : Exports_js_2.createNoDashGuid();
        this.privEvents = new Exports_js_2.EventSource();
        this.privMediaStream = mediaStream || null;
        this.privIsClosing = false;
      }
      get format() {
        return Promise.resolve(MicAudioSource2.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral) {
          return this.privInitializeDeferral.promise;
        }
        this.privInitializeDeferral = new Exports_js_2.Deferred();
        try {
          this.createAudioContext();
        } catch (error) {
          if (error instanceof Error) {
            const typedError = error;
            this.privInitializeDeferral.reject(typedError.name + ": " + typedError.message);
          } else {
            this.privInitializeDeferral.reject(error);
          }
          return this.privInitializeDeferral.promise;
        }
        const nav = window.navigator;
        let getUserMedia = (
          // eslint-disable-next-line
          nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia
        );
        if (!!nav.mediaDevices) {
          getUserMedia = (constraints, successCallback, errorCallback) => {
            nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);
          };
        }
        if (!getUserMedia) {
          const errorMsg = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(errorMsg);
          this.onEvent(new Exports_js_2.AudioSourceErrorEvent(errorMsg, ""));
        } else {
          const next = () => {
            this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId));
            if (this.privMediaStream && this.privMediaStream.active) {
              this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
              this.privInitializeDeferral.resolve();
            } else {
              getUserMedia({ audio: this.deviceId ? { deviceId: this.deviceId } : true, video: false }, (mediaStream) => {
                this.privMediaStream = mediaStream;
                this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
                this.privInitializeDeferral.resolve();
              }, (error) => {
                const errorMsg = `Error occurred during microphone initialization: ${error}`;
                this.privInitializeDeferral.reject(errorMsg);
                this.onEvent(new Exports_js_2.AudioSourceErrorEvent(this.privId, errorMsg));
              });
            }
          };
          if (this.privContext.state === "suspended") {
            this.privContext.resume().then(next).catch((reason) => {
              this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);
            });
          } else {
            next();
          }
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(audioNodeId) {
        this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
        return this.listen(audioNodeId).then((stream) => {
          this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
          return {
            detach: async () => {
              stream.readEnded();
              delete this.privStreams[audioNodeId];
              this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
              return this.turnOff();
            },
            id: () => audioNodeId,
            read: () => stream.read()
          };
        });
      }
      detach(audioNodeId) {
        if (audioNodeId && this.privStreams[audioNodeId]) {
          this.privStreams[audioNodeId].close();
          delete this.privStreams[audioNodeId];
          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
        }
      }
      async turnOff() {
        for (const streamId in this.privStreams) {
          if (streamId) {
            const stream = this.privStreams[streamId];
            if (stream) {
              stream.close();
            }
          }
        }
        this.onEvent(new Exports_js_2.AudioSourceOffEvent(this.privId));
        if (this.privInitializeDeferral) {
          await this.privInitializeDeferral;
          this.privInitializeDeferral = null;
        }
        await this.destroyAudioContext();
        return;
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((label) => ({
          bitspersample: MicAudioSource2.AUDIOFORMAT.bitsPerSample,
          channelcount: MicAudioSource2.AUDIOFORMAT.channels,
          connectivity: Exports_js_12.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: label,
          samplerate: MicAudioSource2.AUDIOFORMAT.samplesPerSec,
          type: Exports_js_12.type.Microphones
        }));
      }
      setProperty(name2, value) {
        if (name2 === exports.AudioWorkletSourceURLPropertyName) {
          this.privRecorder.setWorkletUrl(value);
        } else {
          throw new Error("Property '" + name2 + "' is not supported on Microphone.");
        }
      }
      getMicrophoneLabel() {
        const defaultMicrophoneName = "microphone";
        if (this.privMicrophoneLabel !== void 0) {
          return Promise.resolve(this.privMicrophoneLabel);
        }
        if (this.privMediaStream === void 0 || !this.privMediaStream.active) {
          return Promise.resolve(defaultMicrophoneName);
        }
        this.privMicrophoneLabel = defaultMicrophoneName;
        const microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (void 0 === microphoneDeviceId) {
          return Promise.resolve(this.privMicrophoneLabel);
        }
        const deferred = new Exports_js_2.Deferred();
        navigator.mediaDevices.enumerateDevices().then((devices) => {
          for (const device of devices) {
            if (device.deviceId === microphoneDeviceId) {
              this.privMicrophoneLabel = device.label;
              break;
            }
          }
          deferred.resolve(this.privMicrophoneLabel);
        }, () => deferred.resolve(this.privMicrophoneLabel));
        return deferred.promise;
      }
      async listen(audioNodeId) {
        await this.turnOn();
        const stream = new Exports_js_2.ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);
        this.privStreams[audioNodeId] = stream;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, stream);
        } catch (error) {
          this.onEvent(new Exports_js_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));
          throw error;
        }
        const result = stream;
        return result;
      }
      onEvent(event) {
        this.privEvents.onEvent(event);
        Exports_js_2.Events.instance.onEvent(event);
      }
      createAudioContext() {
        if (!!this.privContext) {
          return;
        }
        this.privContext = AudioStreamFormat_js_12.AudioStreamFormatImpl.getAudioContext(MicAudioSource2.AUDIOFORMAT.samplesPerSec);
      }
      async destroyAudioContext() {
        if (!this.privContext) {
          return;
        }
        this.privRecorder.releaseMediaResources(this.privContext);
        let hasClose = false;
        if ("close" in this.privContext) {
          hasClose = true;
        }
        if (hasClose) {
          if (!this.privIsClosing) {
            this.privIsClosing = true;
            await this.privContext.close();
            this.privContext = null;
            this.privIsClosing = false;
          }
        } else if (null !== this.privContext && this.privContext.state === "running") {
          await this.privContext.suspend();
        }
      }
    }
    exports.MicAudioSource = MicAudioSource2;
    MicAudioSource2.AUDIOFORMAT = AudioStreamFormat_js_12.AudioStreamFormat.getDefaultInputFormat();
  })(MicAudioSource);
  return MicAudioSource;
}
var FileAudioSource = {};
var hasRequiredFileAudioSource;
function requireFileAudioSource() {
  if (hasRequiredFileAudioSource) return FileAudioSource;
  hasRequiredFileAudioSource = 1;
  Object.defineProperty(FileAudioSource, "__esModule", { value: true });
  FileAudioSource.FileAudioSource = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const AudioStreamFormat_js_12 = AudioStreamFormat;
  let FileAudioSource$1 = class FileAudioSource {
    constructor(file, filename, audioSourceId) {
      this.privStreams = {};
      this.privHeaderEnd = 44;
      this.privId = audioSourceId ? audioSourceId : Exports_js_2.createNoDashGuid();
      this.privEvents = new Exports_js_2.EventSource();
      this.privSource = file;
      if (typeof window !== "undefined" && typeof Blob !== "undefined" && this.privSource instanceof Blob) {
        this.privFilename = file.name;
      } else {
        this.privFilename = filename || "unknown.wav";
      }
      this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const errorMsg = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        this.onEvent(new Exports_js_2.AudioSourceErrorEvent(errorMsg, ""));
        return Promise.reject(errorMsg);
      }
      this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId));
      this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
      return;
    }
    id() {
      return this.privId;
    }
    async attach(audioNodeId) {
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
      const stream = await this.upload(audioNodeId);
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
      return Promise.resolve({
        detach: async () => {
          stream.readEnded();
          delete this.privStreams[audioNodeId];
          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
          await this.turnOff();
        },
        id: () => audioNodeId,
        read: () => stream.read()
      });
    }
    detach(audioNodeId) {
      if (audioNodeId && this.privStreams[audioNodeId]) {
        this.privStreams[audioNodeId].close();
        delete this.privStreams[audioNodeId];
        this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
      }
    }
    turnOff() {
      for (const streamId in this.privStreams) {
        if (streamId) {
          const stream = this.privStreams[streamId];
          if (stream && !stream.isClosed) {
            stream.close();
          }
        }
      }
      this.onEvent(new Exports_js_2.AudioSourceOffEvent(this.privId));
      return Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((result) => Promise.resolve({
        bitspersample: result.bitsPerSample,
        channelcount: result.channels,
        connectivity: Exports_js_12.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: result.samplesPerSec,
        type: Exports_js_12.type.File
      }));
    }
    readHeader() {
      const maxHeaderSize = 4296;
      const header = this.privSource.slice(0, maxHeaderSize);
      const headerResult = new Exports_js_2.Deferred();
      const processHeader = (header2) => {
        const view = new DataView(header2);
        const getWord = (index2) => String.fromCharCode(view.getUint8(index2), view.getUint8(index2 + 1), view.getUint8(index2 + 2), view.getUint8(index2 + 3));
        if ("RIFF" !== getWord(0)) {
          headerResult.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if ("WAVE" !== getWord(8) || "fmt " !== getWord(12)) {
          headerResult.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const formatSize = view.getInt32(16, true);
        const channelCount = view.getUint16(22, true);
        const sampleRate = view.getUint32(24, true);
        const bitsPerSample = view.getUint16(34, true);
        let pos = 36 + Math.max(formatSize - 16, 0);
        for (; getWord(pos) !== "data"; pos += 2) {
          if (pos > maxHeaderSize - 8) {
            headerResult.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        }
        this.privHeaderEnd = pos + 8;
        headerResult.resolve(AudioStreamFormat_js_12.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));
      };
      if (typeof window !== "undefined" && typeof Blob !== "undefined" && header instanceof Blob) {
        const reader = new FileReader();
        reader.onload = (event) => {
          const header2 = event.target.result;
          processHeader(header2);
        };
        reader.readAsArrayBuffer(header);
      } else {
        const h = header;
        processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));
      }
      return headerResult.promise;
    }
    async upload(audioNodeId) {
      const onerror = (error) => {
        const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;
        this.onEvent(new Exports_js_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));
        throw new Error(errorMsg);
      };
      try {
        await this.turnOn();
        const format = await this.privAudioFormatPromise;
        const stream = new Exports_js_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);
        this.privStreams[audioNodeId] = stream;
        const chunk = this.privSource.slice(this.privHeaderEnd);
        const processFile = (buff) => {
          if (stream.isClosed) {
            return;
          }
          stream.writeStreamChunk({
            buffer: buff,
            isEnd: false,
            timeReceived: Date.now()
          });
          stream.close();
        };
        if (typeof window !== "undefined" && typeof Blob !== "undefined" && chunk instanceof Blob) {
          const reader = new FileReader();
          reader.onerror = (ev) => onerror(ev.toString());
          reader.onload = (event) => {
            const fileBuffer = event.target.result;
            processFile(fileBuffer);
          };
          reader.readAsArrayBuffer(chunk);
        } else {
          const c = chunk;
          processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));
        }
        return stream;
      } catch (e) {
        onerror(e);
      }
    }
    onEvent(event) {
      this.privEvents.onEvent(event);
      Exports_js_2.Events.instance.onEvent(event);
    }
  };
  FileAudioSource.FileAudioSource = FileAudioSource$1;
  return FileAudioSource;
}
var PCMRecorder = {};
Object.defineProperty(PCMRecorder, "__esModule", { value: true });
PCMRecorder.PcmRecorder = void 0;
const Exports_1 = requireExports$5();
class PcmRecorder {
  constructor(stopInputOnRelease) {
    this.privStopInputOnRelease = stopInputOnRelease;
  }
  record(context, mediaStream, outputStream) {
    const desiredSampleRate = 16e3;
    const waveStreamEncoder = new Exports_1.RiffPcmEncoder(context.sampleRate, desiredSampleRate);
    const micInput = context.createMediaStreamSource(mediaStream);
    const attachScriptProcessor = () => {
      const scriptNode = (() => {
        let bufferSize = 0;
        try {
          return context.createScriptProcessor(bufferSize, 1, 1);
        } catch (error) {
          bufferSize = 2048;
          let audioSampleRate = context.sampleRate;
          while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {
            bufferSize <<= 1;
            audioSampleRate >>= 1;
          }
          return context.createScriptProcessor(bufferSize, 1, 1);
        }
      })();
      scriptNode.onaudioprocess = (event) => {
        const inputFrame = event.inputBuffer.getChannelData(0);
        if (outputStream && !outputStream.isClosed) {
          const waveFrame = waveStreamEncoder.encode(inputFrame);
          if (!!waveFrame) {
            outputStream.writeStreamChunk({
              buffer: waveFrame,
              isEnd: false,
              timeReceived: Date.now()
            });
          }
        }
      };
      micInput.connect(scriptNode);
      scriptNode.connect(context.destination);
      this.privMediaResources = {
        scriptProcessorNode: scriptNode,
        source: micInput,
        stream: mediaStream
      };
    };
    const skipAudioWorklet = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
    if (!!context.audioWorklet && !skipAudioWorklet) {
      if (!this.privSpeechProcessorScript) {
        const workletScript = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`;
        const blob = new Blob([workletScript], { type: "application/javascript; charset=utf-8" });
        this.privSpeechProcessorScript = URL.createObjectURL(blob);
      }
      context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
        const workletNode = new AudioWorkletNode(context, "speech-processor");
        workletNode.port.onmessage = (ev) => {
          const inputFrame = ev.data;
          if (outputStream && !outputStream.isClosed) {
            const waveFrame = waveStreamEncoder.encode(inputFrame);
            if (!!waveFrame) {
              outputStream.writeStreamChunk({
                buffer: waveFrame,
                isEnd: false,
                timeReceived: Date.now()
              });
            }
          }
        };
        micInput.connect(workletNode);
        workletNode.connect(context.destination);
        this.privMediaResources = {
          scriptProcessorNode: workletNode,
          source: micInput,
          stream: mediaStream
        };
      }).catch(() => {
        attachScriptProcessor();
      });
    } else {
      try {
        attachScriptProcessor();
      } catch (err2) {
        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err2}`);
      }
    }
  }
  releaseMediaResources(context) {
    if (this.privMediaResources) {
      if (this.privMediaResources.scriptProcessorNode) {
        this.privMediaResources.scriptProcessorNode.disconnect(context.destination);
        this.privMediaResources.scriptProcessorNode = null;
      }
      if (this.privMediaResources.source) {
        this.privMediaResources.source.disconnect();
        if (this.privStopInputOnRelease) {
          this.privMediaResources.stream.getTracks().forEach((track) => track.stop());
        }
        this.privMediaResources.source = null;
      }
    }
  }
  setWorkletUrl(url) {
    this.privSpeechProcessorScript = url;
  }
}
PCMRecorder.PcmRecorder = PcmRecorder;
var WebsocketConnection$1 = {};
var WebsocketMessageAdapter$1 = {};
var __createBinding$1 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  Object.defineProperty(o, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o[k22] = m2[k2];
});
var __setModuleDefault$1 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
  Object.defineProperty(o, "default", { enumerable: true, value: v2 });
} : function(o, v2) {
  o["default"] = v2;
});
var __importStar$1 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding$1(result, mod, k2);
  }
  __setModuleDefault$1(result, mod);
  return result;
};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(WebsocketMessageAdapter$1, "__esModule", { value: true });
WebsocketMessageAdapter$1.WebsocketMessageAdapter = void 0;
const net = __importStar$1(require$$0);
const tls = __importStar$1(require$$0);
const agent_base_1 = __importDefault$1(require$$0);
const https_proxy_agent_1 = __importDefault$1(require$$0);
const ws_1 = __importDefault$1(require$$0);
const HeaderNames_js_1$1 = HeaderNames$1;
const Exports_js_1$b = requireExports$5();
class WebsocketMessageAdapter {
  constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {
    if (!uri) {
      throw new Exports_js_1$b.ArgumentNullError("uri");
    }
    if (!messageFormatter) {
      throw new Exports_js_1$b.ArgumentNullError("messageFormatter");
    }
    this.proxyInfo = proxyInfo;
    this.privConnectionEvents = new Exports_js_1$b.EventSource();
    this.privConnectionId = connectionId;
    this.privMessageFormatter = messageFormatter;
    this.privConnectionState = Exports_js_1$b.ConnectionState.None;
    this.privUri = uri;
    this.privHeaders = headers;
    this.privEnableCompression = enableCompression;
    this.privHeaders[HeaderNames_js_1$1.HeaderNames.ConnectionId] = this.privConnectionId;
    this.privLastErrorReceived = "";
  }
  get state() {
    return this.privConnectionState;
  }
  open() {
    if (this.privConnectionState === Exports_js_1$b.ConnectionState.Disconnected) {
      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
    }
    if (this.privConnectionEstablishDeferral) {
      return this.privConnectionEstablishDeferral.promise;
    }
    this.privConnectionEstablishDeferral = new Exports_js_1$b.Deferred();
    this.privCertificateValidatedDeferral = new Exports_js_1$b.Deferred();
    this.privConnectionState = Exports_js_1$b.ConnectionState.Connecting;
    try {
      if (typeof WebSocket !== "undefined" && !WebsocketMessageAdapter.forceNpmWebSocket) {
        this.privCertificateValidatedDeferral.resolve();
        this.privWebsocketClient = new WebSocket(this.privUri);
      } else {
        const options = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };
        this.privCertificateValidatedDeferral.resolve();
        options.agent = this.getAgent();
        const uri = new URL(this.privUri);
        let protocol = uri.protocol;
        if ((protocol == null ? void 0 : protocol.toLocaleLowerCase()) === "wss:") {
          protocol = "https:";
        } else if ((protocol == null ? void 0 : protocol.toLocaleLowerCase()) === "ws:") {
          protocol = "http:";
        }
        options.agent.protocol = protocol;
        this.privWebsocketClient = new ws_1.default(this.privUri, options);
      }
      this.privWebsocketClient.binaryType = "arraybuffer";
      this.privReceivingMessageQueue = new Exports_js_1$b.Queue();
      this.privDisconnectDeferral = new Exports_js_1$b.Deferred();
      this.privSendMessageQueue = new Exports_js_1$b.Queue();
      this.processSendQueue().catch((reason) => {
        Exports_js_1$b.Events.instance.onEvent(new Exports_js_1$b.BackgroundEvent(reason));
      });
    } catch (error) {
      this.privConnectionEstablishDeferral.resolve(new Exports_js_1$b.ConnectionOpenResponse(500, error));
      return this.privConnectionEstablishDeferral.promise;
    }
    this.onEvent(new Exports_js_1$b.ConnectionStartEvent(this.privConnectionId, this.privUri));
    this.privWebsocketClient.onopen = () => {
      this.privCertificateValidatedDeferral.promise.then(() => {
        this.privConnectionState = Exports_js_1$b.ConnectionState.Connected;
        this.onEvent(new Exports_js_1$b.ConnectionEstablishedEvent(this.privConnectionId));
        this.privConnectionEstablishDeferral.resolve(new Exports_js_1$b.ConnectionOpenResponse(200, ""));
      }, (error) => {
        this.privConnectionEstablishDeferral.reject(error);
      });
    };
    this.privWebsocketClient.onerror = (e) => {
      this.onEvent(new Exports_js_1$b.ConnectionErrorEvent(this.privConnectionId, e.message, e.type));
      this.privLastErrorReceived = e.message;
    };
    this.privWebsocketClient.onclose = (e) => {
      if (this.privConnectionState === Exports_js_1$b.ConnectionState.Connecting) {
        this.privConnectionState = Exports_js_1$b.ConnectionState.Disconnected;
        this.privConnectionEstablishDeferral.resolve(new Exports_js_1$b.ConnectionOpenResponse(e.code, e.reason + " " + this.privLastErrorReceived));
      } else {
        this.privConnectionState = Exports_js_1$b.ConnectionState.Disconnected;
        this.privWebsocketClient = null;
        this.onEvent(new Exports_js_1$b.ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));
      }
      this.onClose(e.code, e.reason).catch((reason) => {
        Exports_js_1$b.Events.instance.onEvent(new Exports_js_1$b.BackgroundEvent(reason));
      });
    };
    this.privWebsocketClient.onmessage = (e) => {
      const networkReceivedTime = (/* @__PURE__ */ new Date()).toISOString();
      if (this.privConnectionState === Exports_js_1$b.ConnectionState.Connected) {
        const deferred = new Exports_js_1$b.Deferred();
        this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);
        if (e.data instanceof ArrayBuffer) {
          const rawMessage = new Exports_js_1$b.RawWebsocketMessage(Exports_js_1$b.MessageType.Binary, e.data);
          this.privMessageFormatter.toConnectionMessage(rawMessage).then((connectionMessage) => {
            this.onEvent(new Exports_js_1$b.ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));
            deferred.resolve(connectionMessage);
          }, (error) => {
            deferred.reject(`Invalid binary message format. Error: ${error}`);
          });
        } else {
          const rawMessage = new Exports_js_1$b.RawWebsocketMessage(Exports_js_1$b.MessageType.Text, e.data);
          this.privMessageFormatter.toConnectionMessage(rawMessage).then((connectionMessage) => {
            this.onEvent(new Exports_js_1$b.ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));
            deferred.resolve(connectionMessage);
          }, (error) => {
            deferred.reject(`Invalid text message format. Error: ${error}`);
          });
        }
      }
    };
    return this.privConnectionEstablishDeferral.promise;
  }
  send(message) {
    if (this.privConnectionState !== Exports_js_1$b.ConnectionState.Connected) {
      return Promise.reject(`Cannot send on connection that is in ${Exports_js_1$b.ConnectionState[this.privConnectionState]} state`);
    }
    const messageSendStatusDeferral = new Exports_js_1$b.Deferred();
    const messageSendDeferral = new Exports_js_1$b.Deferred();
    this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);
    this.privMessageFormatter.fromConnectionMessage(message).then((rawMessage) => {
      messageSendDeferral.resolve({
        Message: message,
        RawWebsocketMessage: rawMessage,
        sendStatusDeferral: messageSendStatusDeferral
      });
    }, (error) => {
      messageSendDeferral.reject(`Error formatting the message. ${error}`);
    });
    return messageSendStatusDeferral.promise;
  }
  read() {
    if (this.privConnectionState !== Exports_js_1$b.ConnectionState.Connected) {
      return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);
    }
    return this.privReceivingMessageQueue.dequeue();
  }
  close(reason) {
    if (this.privWebsocketClient) {
      if (this.privConnectionState !== Exports_js_1$b.ConnectionState.Disconnected) {
        this.privWebsocketClient.close(1e3, reason ? reason : "Normal closure by client");
      }
    } else {
      return Promise.resolve();
    }
    return this.privDisconnectDeferral.promise;
  }
  get events() {
    return this.privConnectionEvents;
  }
  sendRawMessage(sendItem) {
    try {
      if (!sendItem) {
        return Promise.resolve();
      }
      this.onEvent(new Exports_js_1$b.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), sendItem.Message));
      if (this.isWebsocketOpen) {
        this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);
      } else {
        return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + sendItem.Message.id + " " + new Error().stack);
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(`websocket send error: ${e}`);
    }
  }
  async onClose(code2, reason) {
    const closeReason = `Connection closed. ${code2}: ${reason}`;
    this.privConnectionState = Exports_js_1$b.ConnectionState.Disconnected;
    this.privDisconnectDeferral.resolve();
    await this.privReceivingMessageQueue.drainAndDispose(() => {
    }, closeReason);
    await this.privSendMessageQueue.drainAndDispose((pendingSendItem) => {
      pendingSendItem.sendStatusDeferral.reject(closeReason);
    }, closeReason);
  }
  async processSendQueue() {
    while (true) {
      const itemToSend = this.privSendMessageQueue.dequeue();
      const sendItem = await itemToSend;
      if (!sendItem) {
        return;
      }
      try {
        await this.sendRawMessage(sendItem);
        sendItem.sendStatusDeferral.resolve();
      } catch (sendError) {
        sendItem.sendStatusDeferral.reject(sendError);
      }
    }
  }
  onEvent(event) {
    this.privConnectionEvents.onEvent(event);
    Exports_js_1$b.Events.instance.onEvent(event);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAgent() {
    const agent = new agent_base_1.default.Agent(this.createConnection);
    if (this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0) {
      agent.proxyInfo = this.proxyInfo;
    }
    return agent;
  }
  static GetProxyAgent(proxyInfo) {
    const httpProxyOptions = {
      host: proxyInfo.HostName,
      port: proxyInfo.Port
    };
    if (!!proxyInfo.UserName) {
      httpProxyOptions.headers = {
        "Proxy-Authentication": "Basic " + new Buffer(`${proxyInfo.UserName}:${proxyInfo.Password === void 0 ? "" : proxyInfo.Password}`).toString("base64")
      };
    } else {
      httpProxyOptions.headers = {};
    }
    httpProxyOptions.headers.requestOCSP = "true";
    const httpProxyAgent = new https_proxy_agent_1.default(httpProxyOptions);
    return httpProxyAgent;
  }
  createConnection(request, options) {
    let socketPromise;
    options = {
      ...options,
      ...{
        requestOCSP: true,
        servername: options.host
      }
    };
    if (!!this.proxyInfo) {
      const httpProxyAgent = WebsocketMessageAdapter.GetProxyAgent(this.proxyInfo);
      const baseAgent = httpProxyAgent;
      socketPromise = new Promise((resolve, reject) => {
        baseAgent.callback(request, options, (error, socket) => {
          if (!!error) {
            reject(error);
          } else {
            resolve(socket);
          }
        });
      });
    } else {
      if (!!options.secureEndpoint) {
        socketPromise = Promise.resolve(tls.connect(options));
      } else {
        socketPromise = Promise.resolve(net.connect(options));
      }
    }
    return socketPromise;
  }
  get isWebsocketOpen() {
    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
  }
}
WebsocketMessageAdapter$1.WebsocketMessageAdapter = WebsocketMessageAdapter;
WebsocketMessageAdapter.forceNpmWebSocket = false;
Object.defineProperty(WebsocketConnection$1, "__esModule", { value: true });
WebsocketConnection$1.WebsocketConnection = void 0;
const Exports_js_1$a = requireExports$5();
const WebsocketMessageAdapter_js_1 = WebsocketMessageAdapter$1;
class WebsocketConnection {
  constructor(uri, queryParameters, headers, messageFormatter, proxyInfo, enableCompression = false, connectionId) {
    this.privIsDisposed = false;
    if (!uri) {
      throw new Exports_js_1$a.ArgumentNullError("uri");
    }
    if (!messageFormatter) {
      throw new Exports_js_1$a.ArgumentNullError("messageFormatter");
    }
    this.privMessageFormatter = messageFormatter;
    let queryParams = "";
    let i = 0;
    if (queryParameters) {
      for (const paramName in queryParameters) {
        if (paramName) {
          queryParams += i === 0 && uri.indexOf("?") === -1 ? "?" : "&";
          const key = encodeURIComponent(paramName);
          queryParams += key;
          let val = queryParameters[paramName];
          if (val) {
            val = encodeURIComponent(val);
            queryParams += `=${val}`;
          }
          i++;
        }
      }
    }
    if (headers) {
      for (const headerName in headers) {
        if (headerName) {
          queryParams += i === 0 && uri.indexOf("?") === -1 ? "?" : "&";
          const val = encodeURIComponent(headers[headerName]);
          queryParams += `${headerName}=${val}`;
          i++;
        }
      }
    }
    this.privUri = uri + queryParams;
    this.privId = connectionId ? connectionId : Exports_js_1$a.createNoDashGuid();
    this.privConnectionMessageAdapter = new WebsocketMessageAdapter_js_1.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, proxyInfo, headers, enableCompression);
  }
  async dispose() {
    this.privIsDisposed = true;
    if (this.privConnectionMessageAdapter) {
      await this.privConnectionMessageAdapter.close();
    }
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  get id() {
    return this.privId;
  }
  get uri() {
    return this.privUri;
  }
  state() {
    return this.privConnectionMessageAdapter.state;
  }
  open() {
    return this.privConnectionMessageAdapter.open();
  }
  send(message) {
    return this.privConnectionMessageAdapter.send(message);
  }
  read() {
    return this.privConnectionMessageAdapter.read();
  }
  get events() {
    return this.privConnectionMessageAdapter.events;
  }
}
WebsocketConnection$1.WebsocketConnection = WebsocketConnection;
var ReplayableAudioNode$1 = {};
Object.defineProperty(ReplayableAudioNode$1, "__esModule", { value: true });
ReplayableAudioNode$1.ReplayableAudioNode = void 0;
class ReplayableAudioNode {
  constructor(audioSource, bytesPerSecond) {
    this.privBuffers = [];
    this.privReplayOffset = 0;
    this.privLastShrinkOffset = 0;
    this.privBufferStartOffset = 0;
    this.privBufferSerial = 0;
    this.privBufferedBytes = 0;
    this.privReplay = false;
    this.privLastChunkAcquiredTime = 0;
    this.privAudioNode = audioSource;
    this.privBytesPerSecond = bytesPerSecond;
  }
  id() {
    return this.privAudioNode.id();
  }
  // Reads and returns the next chunk of audio buffer.
  // If replay of existing buffers are needed, read() will first seek and replay
  // existing content, and upoin completion it will read new content from the underlying
  // audio node, saving that content into the replayable buffers.
  read() {
    if (!!this.privReplay && this.privBuffers.length !== 0) {
      const offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;
      let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
      if (0 !== bytesToSeek % 2) {
        bytesToSeek++;
      }
      let i = 0;
      while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {
        bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
      }
      if (i < this.privBuffers.length) {
        const retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);
        this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e7;
        if (i === this.privBuffers.length - 1) {
          this.privReplay = false;
        }
        return Promise.resolve({
          buffer: retVal,
          isEnd: false,
          timeReceived: this.privBuffers[i].chunk.timeReceived
        });
      }
    }
    return this.privAudioNode.read().then((result) => {
      if (result && result.buffer) {
        this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));
        this.privBufferedBytes += result.buffer.byteLength;
      }
      return result;
    });
  }
  detach() {
    this.privBuffers = void 0;
    return this.privAudioNode.detach();
  }
  replay() {
    if (this.privBuffers && 0 !== this.privBuffers.length) {
      this.privReplay = true;
      this.privReplayOffset = this.privLastShrinkOffset;
    }
  }
  // Shrinks the existing audio buffers to start at the new offset, or at the
  // beginning of the buffer closest to the requested offset.
  // A replay request will start from the last shrink point.
  shrinkBuffers(offset) {
    if (this.privBuffers === void 0 || this.privBuffers.length === 0) {
      return;
    }
    this.privLastShrinkOffset = offset;
    const offsetToSeek = offset - this.privBufferStartOffset;
    let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
    let i = 0;
    while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {
      bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
    }
    this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e7);
    this.privBuffers = this.privBuffers.slice(i);
  }
  // Finds the time a buffer of audio was first seen by offset.
  findTimeAtOffset(offset) {
    if (offset < this.privBufferStartOffset || this.privBuffers === void 0) {
      return 0;
    }
    for (const value of this.privBuffers) {
      const startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;
      const endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
      if (offset >= startOffset && offset <= endOffset) {
        return value.chunk.timeReceived;
      }
    }
    return 0;
  }
}
ReplayableAudioNode$1.ReplayableAudioNode = ReplayableAudioNode;
class BufferEntry {
  constructor(chunk, serial, byteOffset) {
    this.chunk = chunk;
    this.serial = serial;
    this.byteOffset = byteOffset;
  }
}
var ProxyInfo = {};
var Exports$3 = {};
var AudioConfig = {};
var AudioFileWriter$1 = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  Object.defineProperty(o, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
  Object.defineProperty(o, "default", { enumerable: true, value: v2 });
} : function(o, v2) {
  o["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(AudioFileWriter$1, "__esModule", { value: true });
AudioFileWriter$1.AudioFileWriter = void 0;
const fs = __importStar(require$$0);
const Contracts_js_1$6 = Contracts$1;
class AudioFileWriter {
  constructor(filename) {
    Contracts_js_1$6.Contracts.throwIfNullOrUndefined(fs.openSync, "\nFile System access not available, please use Push or PullAudioOutputStream");
    this.privFd = fs.openSync(filename, "w");
  }
  set format(format) {
    Contracts_js_1$6.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set");
    this.privAudioFormat = format;
    let headerOffset = 0;
    if (this.privAudioFormat.hasHeader) {
      headerOffset = this.privAudioFormat.header.byteLength;
    }
    if (this.privFd !== void 0) {
      this.privWriteStream = fs.createWriteStream("", { fd: this.privFd, start: headerOffset, autoClose: false });
    }
  }
  write(buffer) {
    Contracts_js_1$6.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing.");
    if (this.privWriteStream !== void 0) {
      this.privWriteStream.write(new Uint8Array(buffer.slice(0)));
    }
  }
  close() {
    if (this.privFd !== void 0) {
      this.privWriteStream.on("finish", () => {
        if (this.privAudioFormat.hasHeader) {
          this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten);
          fs.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0);
        }
        fs.closeSync(this.privFd);
        this.privFd = void 0;
      });
      this.privWriteStream.end();
    }
  }
  id() {
    return this.privId;
  }
}
AudioFileWriter$1.AudioFileWriter = AudioFileWriter;
var AudioInputStream = {};
var hasRequiredAudioInputStream;
function requireAudioInputStream() {
  if (hasRequiredAudioInputStream) return AudioInputStream;
  hasRequiredAudioInputStream = 1;
  Object.defineProperty(AudioInputStream, "__esModule", { value: true });
  AudioInputStream.PullAudioInputStreamImpl = AudioInputStream.PullAudioInputStream = AudioInputStream.PushAudioInputStreamImpl = AudioInputStream.PushAudioInputStream = AudioInputStream.AudioInputStream = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Guid_js_12 = Guid;
  const Exports_js_3 = requireExports$3();
  const AudioStreamFormat_js_12 = AudioStreamFormat;
  let AudioInputStream$1 = class AudioInputStream {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
      return;
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(format) {
      return PushAudioInputStream.create(format);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(callback, format) {
      return PullAudioInputStream.create(callback, format);
    }
  };
  AudioInputStream.AudioInputStream = AudioInputStream$1;
  class PushAudioInputStream extends AudioInputStream$1 {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(format) {
      return new PushAudioInputStreamImpl(format);
    }
  }
  AudioInputStream.PushAudioInputStream = PushAudioInputStream;
  class PushAudioInputStreamImpl extends PushAudioInputStream {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(format) {
      super();
      if (format === void 0) {
        this.privFormat = AudioStreamFormat_js_12.AudioStreamFormatImpl.getDefaultInputFormat();
      } else {
        this.privFormat = format;
      }
      this.privEvents = new Exports_js_2.EventSource();
      this.privId = Guid_js_12.createNoDashGuid();
      this.privStream = new Exports_js_2.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(dataBuffer) {
      this.privStream.writeStreamChunk({
        buffer: dataBuffer,
        isEnd: false,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId));
      this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
      return;
    }
    async attach(audioNodeId) {
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
      await this.turnOn();
      const stream = this.privStream;
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
      return {
        detach: async () => {
          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
          return this.turnOff();
        },
        id: () => audioNodeId,
        read: () => stream.read()
      };
    }
    detach(audioNodeId) {
      this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
    }
    turnOff() {
      return;
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: Exports_js_12.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: Exports_js_12.type.Stream
      });
    }
    onEvent(event) {
      this.privEvents.onEvent(event);
      Exports_js_2.Events.instance.onEvent(event);
    }
    toBuffer(arrayBuffer) {
      const buf = Buffer.alloc(arrayBuffer.byteLength);
      const view = new Uint8Array(arrayBuffer);
      for (let i = 0; i < buf.length; ++i) {
        buf[i] = view[i];
      }
      return buf;
    }
  }
  AudioInputStream.PushAudioInputStreamImpl = PushAudioInputStreamImpl;
  class PullAudioInputStream extends AudioInputStream$1 {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(callback, format) {
      return new PullAudioInputStreamImpl(callback, format);
    }
  }
  AudioInputStream.PullAudioInputStream = PullAudioInputStream;
  class PullAudioInputStreamImpl extends PullAudioInputStream {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(callback, format) {
      super();
      if (void 0 === format) {
        this.privFormat = Exports_js_3.AudioStreamFormat.getDefaultInputFormat();
      } else {
        this.privFormat = format;
      }
      this.privEvents = new Exports_js_2.EventSource();
      this.privId = Guid_js_12.createNoDashGuid();
      this.privCallback = callback;
      this.privIsClosed = false;
      this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = true;
      this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId));
      this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
      return;
    }
    async attach(audioNodeId) {
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
      await this.turnOn();
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
      return {
        detach: () => {
          this.privCallback.close();
          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
          return this.turnOff();
        },
        id: () => audioNodeId,
        read: () => {
          let totalBytes = 0;
          let transmitBuff;
          while (totalBytes < this.privBufferSize) {
            const readBuff = new ArrayBuffer(this.privBufferSize - totalBytes);
            const pulledBytes = this.privCallback.read(readBuff);
            if (void 0 === transmitBuff) {
              transmitBuff = readBuff;
            } else {
              const intView = new Int8Array(transmitBuff);
              intView.set(new Int8Array(readBuff), totalBytes);
            }
            if (0 === pulledBytes) {
              break;
            }
            totalBytes += pulledBytes;
          }
          return Promise.resolve({
            buffer: transmitBuff.slice(0, totalBytes),
            isEnd: this.privIsClosed || totalBytes === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(audioNodeId) {
      this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
    }
    turnOff() {
      return;
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: Exports_js_12.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: Exports_js_12.type.Stream
      });
    }
    onEvent(event) {
      this.privEvents.onEvent(event);
      Exports_js_2.Events.instance.onEvent(event);
    }
  }
  AudioInputStream.PullAudioInputStreamImpl = PullAudioInputStreamImpl;
  return AudioInputStream;
}
var AudioOutputStream$1 = {};
var AudioOutputFormat = {};
var SpeechSynthesisOutputFormat = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpeechSynthesisOutputFormat = void 0;
  (function(SpeechSynthesisOutputFormat2) {
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw8Khz8BitMonoMULaw"] = 0] = "Raw8Khz8BitMonoMULaw";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff16Khz16KbpsMonoSiren"] = 1] = "Riff16Khz16KbpsMonoSiren";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio16Khz16KbpsMonoSiren"] = 2] = "Audio16Khz16KbpsMonoSiren";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio16Khz32KBitRateMonoMp3"] = 3] = "Audio16Khz32KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio16Khz128KBitRateMonoMp3"] = 4] = "Audio16Khz128KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio16Khz64KBitRateMonoMp3"] = 5] = "Audio16Khz64KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio24Khz48KBitRateMonoMp3"] = 6] = "Audio24Khz48KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio24Khz96KBitRateMonoMp3"] = 7] = "Audio24Khz96KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio24Khz160KBitRateMonoMp3"] = 8] = "Audio24Khz160KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw16Khz16BitMonoTrueSilk"] = 9] = "Raw16Khz16BitMonoTrueSilk";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff16Khz16BitMonoPcm"] = 10] = "Riff16Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff8Khz16BitMonoPcm"] = 11] = "Riff8Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff24Khz16BitMonoPcm"] = 12] = "Riff24Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff8Khz8BitMonoMULaw"] = 13] = "Riff8Khz8BitMonoMULaw";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw16Khz16BitMonoPcm"] = 14] = "Raw16Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw24Khz16BitMonoPcm"] = 15] = "Raw24Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw8Khz16BitMonoPcm"] = 16] = "Raw8Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Ogg16Khz16BitMonoOpus"] = 17] = "Ogg16Khz16BitMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Ogg24Khz16BitMonoOpus"] = 18] = "Ogg24Khz16BitMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw48Khz16BitMonoPcm"] = 19] = "Raw48Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff48Khz16BitMonoPcm"] = 20] = "Riff48Khz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio48Khz96KBitRateMonoMp3"] = 21] = "Audio48Khz96KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio48Khz192KBitRateMonoMp3"] = 22] = "Audio48Khz192KBitRateMonoMp3";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Ogg48Khz16BitMonoOpus"] = 23] = "Ogg48Khz16BitMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Webm16Khz16BitMonoOpus"] = 24] = "Webm16Khz16BitMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Webm24Khz16BitMonoOpus"] = 25] = "Webm24Khz16BitMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw24Khz16BitMonoTrueSilk"] = 26] = "Raw24Khz16BitMonoTrueSilk";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw8Khz8BitMonoALaw"] = 27] = "Raw8Khz8BitMonoALaw";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff8Khz8BitMonoALaw"] = 28] = "Riff8Khz8BitMonoALaw";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Webm24Khz16Bit24KbpsMonoOpus"] = 29] = "Webm24Khz16Bit24KbpsMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio16Khz16Bit32KbpsMonoOpus"] = 30] = "Audio16Khz16Bit32KbpsMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio24Khz16Bit48KbpsMonoOpus"] = 31] = "Audio24Khz16Bit48KbpsMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Audio24Khz16Bit24KbpsMonoOpus"] = 32] = "Audio24Khz16Bit24KbpsMonoOpus";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw22050Hz16BitMonoPcm"] = 33] = "Raw22050Hz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff22050Hz16BitMonoPcm"] = 34] = "Riff22050Hz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Raw44100Hz16BitMonoPcm"] = 35] = "Raw44100Hz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["Riff44100Hz16BitMonoPcm"] = 36] = "Riff44100Hz16BitMonoPcm";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["AmrWb16000Hz"] = 37] = "AmrWb16000Hz";
    SpeechSynthesisOutputFormat2[SpeechSynthesisOutputFormat2["G72216Khz64Kbps"] = 38] = "G72216Khz64Kbps";
  })(exports.SpeechSynthesisOutputFormat || (exports.SpeechSynthesisOutputFormat = {}));
})(SpeechSynthesisOutputFormat);
Object.defineProperty(AudioOutputFormat, "__esModule", { value: true });
AudioOutputFormat.AudioOutputFormatImpl = void 0;
const SpeechSynthesisOutputFormat_js_1 = SpeechSynthesisOutputFormat;
const AudioStreamFormat_js_1$1 = AudioStreamFormat;
class AudioOutputFormatImpl extends AudioStreamFormat_js_1$1.AudioStreamFormatImpl {
  /**
   * Creates an instance with the given values.
   * @constructor
   * @param formatTag
   * @param {number} channels - Number of channels.
   * @param {number} samplesPerSec - Samples per second.
   * @param {number} avgBytesPerSec - Average bytes per second.
   * @param {number} blockAlign - Block alignment.
   * @param {number} bitsPerSample - Bits per sample.
   * @param {string} audioFormatString - Audio format string
   * @param {string} requestAudioFormatString - Audio format string sent to service.
   * @param {boolean} hasHeader - If the format has header or not.
   */
  constructor(formatTag, channels, samplesPerSec, avgBytesPerSec, blockAlign, bitsPerSample, audioFormatString, requestAudioFormatString, hasHeader) {
    super(samplesPerSec, bitsPerSample, channels, formatTag);
    this.formatTag = formatTag;
    this.avgBytesPerSec = avgBytesPerSec;
    this.blockAlign = blockAlign;
    this.priAudioFormatString = audioFormatString;
    this.priRequestAudioFormatString = requestAudioFormatString;
    this.priHasHeader = hasHeader;
  }
  static fromSpeechSynthesisOutputFormat(speechSynthesisOutputFormat) {
    if (speechSynthesisOutputFormat === void 0) {
      return AudioOutputFormatImpl.getDefaultOutputFormat();
    }
    return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString[speechSynthesisOutputFormat]);
  }
  static fromSpeechSynthesisOutputFormatString(speechSynthesisOutputFormatString) {
    switch (speechSynthesisOutputFormatString) {
      case "raw-8khz-8bit-mono-mulaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-16khz-16kbps-mono-siren":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, speechSynthesisOutputFormatString, "audio-16khz-16kbps-mono-siren", true);
      case "audio-16khz-16kbps-mono-siren":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-32kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 16e3, 32 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-128kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 16e3, 128 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-64kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 16e3, 64 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-48kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 24e3, 48 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-96kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 24e3, 96 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-160kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 24e3, 160 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-16khz-16bit-mono-truesilk":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-8khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", true);
      case "riff-24khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", true);
      case "riff-8khz-8bit-mono-mulaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-mulaw", true);
      case "raw-16khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, speechSynthesisOutputFormatString, "raw-16khz-16bit-mono-pcm", false);
      case "raw-24khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", false);
      case "raw-8khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", false);
      case "ogg-16khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "ogg-24khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-48khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", false);
      case "riff-48khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", true);
      case "audio-48khz-96kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 48e3, 96 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-48khz-192kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.MP3, 1, 48e3, 192 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "ogg-48khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "webm-16khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "webm-24khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "webm-24khz-16bit-24kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-16bit-32kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-16bit-48kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-16bit-24kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-16bit-mono-flac":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-48khz-16bit-mono-flac":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-24khz-16bit-mono-truesilk":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-8khz-8bit-mono-alaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-8khz-8bit-mono-alaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-alaw", true);
      case "raw-22050hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-22050hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, "raw-22050hz-16bit-mono-pcm", true);
      case "raw-44100hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-44100hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, "raw-44100hz-16bit-mono-pcm", true);
      case "amr-wb-16000h":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "g722-16khz-64kbps":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-16khz-16bit-mono-pcm":
      default:
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1$1.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", true);
    }
  }
  static getDefaultOutputFormat() {
    return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(typeof window !== "undefined" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
  }
  /**
   * Specifies if this audio output format has a header
   * @boolean AudioOutputFormatImpl.prototype.hasHeader
   * @function
   * @public
   */
  get hasHeader() {
    return this.priHasHeader;
  }
  /**
   * Specifies the header of this format
   * @ArrayBuffer AudioOutputFormatImpl.prototype.header
   * @function
   * @public
   */
  get header() {
    if (this.hasHeader) {
      return this.privHeader;
    }
    return void 0;
  }
  /**
   * Updates the header based on the audio length
   * @member AudioOutputFormatImpl.updateHeader
   * @function
   * @public
   * @param {number} audioLength - the audio length
   */
  updateHeader(audioLength) {
    if (this.priHasHeader) {
      const view = new DataView(this.privHeader);
      view.setUint32(4, audioLength + this.privHeader.byteLength - 8, true);
      view.setUint32(40, audioLength, true);
    }
  }
  /**
   * Specifies the audio format string to be sent to the service
   * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
   * @function
   * @public
   */
  get requestAudioFormatString() {
    return this.priRequestAudioFormatString;
  }
  /**
   * Adds audio header
   * @param audio the raw audio without header
   * @returns the audio with header if applicable
   */
  addHeader(audio) {
    if (!this.hasHeader) {
      return audio;
    }
    this.updateHeader(audio.byteLength);
    const tmp = new Uint8Array(audio.byteLength + this.header.byteLength);
    tmp.set(new Uint8Array(this.header), 0);
    tmp.set(new Uint8Array(audio), this.header.byteLength);
    return tmp.buffer;
  }
}
AudioOutputFormat.AudioOutputFormatImpl = AudioOutputFormatImpl;
AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString = {
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
};
Object.defineProperty(AudioOutputStream$1, "__esModule", { value: true });
AudioOutputStream$1.PushAudioOutputStreamImpl = AudioOutputStream$1.PushAudioOutputStream = AudioOutputStream$1.PullAudioOutputStreamImpl = AudioOutputStream$1.PullAudioOutputStream = AudioOutputStream$1.AudioOutputStream = void 0;
const Exports_js_1$9 = requireExports$5();
const Contracts_js_1$5 = Contracts$1;
const AudioOutputFormat_js_1$1 = AudioOutputFormat;
class AudioOutputStream {
  /**
   * Creates and initializes an instance.
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member AudioOutputStream.createPullStream
   * @function
   * @public
   * @returns {PullAudioOutputStream} The audio output stream being created.
   */
  static createPullStream() {
    return PullAudioOutputStream.create();
  }
}
AudioOutputStream$1.AudioOutputStream = AudioOutputStream;
class PullAudioOutputStream extends AudioOutputStream {
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member PullAudioOutputStream.create
   * @function
   * @public
   * @returns {PullAudioOutputStream} The push audio output stream being created.
   */
  static create() {
    return new PullAudioOutputStreamImpl();
  }
}
AudioOutputStream$1.PullAudioOutputStream = PullAudioOutputStream;
class PullAudioOutputStreamImpl extends PullAudioOutputStream {
  /**
   * Creates and initializes an instance with the given values.
   * @constructor
   */
  constructor() {
    super();
    this.privId = Exports_js_1$9.createNoDashGuid();
    this.privStream = new Exports_js_1$9.Stream();
  }
  /**
   * Sets the format information to the stream. For internal use only.
   * @param {AudioStreamFormat} format - the format to be set.
   */
  set format(format) {
    if (format === void 0 || format === null) {
      this.privFormat = AudioOutputFormat_js_1$1.AudioOutputFormatImpl.getDefaultOutputFormat();
    }
    this.privFormat = format;
  }
  /**
   * Format information for the audio
   */
  get format() {
    return this.privFormat;
  }
  /**
   * Checks if the stream is closed
   * @member PullAudioOutputStreamImpl.prototype.isClosed
   * @property
   * @public
   */
  get isClosed() {
    return this.privStream.isClosed;
  }
  /**
   * Gets the id of the stream
   * @member PullAudioOutputStreamImpl.prototype.id
   * @property
   * @public
   */
  id() {
    return this.privId;
  }
  /**
   * Reads audio data from the internal buffer.
   * @member PullAudioOutputStreamImpl.prototype.read
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
   * @returns {Promise<number>} - Audio buffer length has been read.
   */
  async read(dataBuffer) {
    const intView = new Int8Array(dataBuffer);
    let totalBytes = 0;
    if (this.privLastChunkView !== void 0) {
      if (this.privLastChunkView.length > dataBuffer.byteLength) {
        intView.set(this.privLastChunkView.slice(0, dataBuffer.byteLength));
        this.privLastChunkView = this.privLastChunkView.slice(dataBuffer.byteLength);
        return Promise.resolve(dataBuffer.byteLength);
      }
      intView.set(this.privLastChunkView);
      totalBytes = this.privLastChunkView.length;
      this.privLastChunkView = void 0;
    }
    while (totalBytes < dataBuffer.byteLength && !this.privStream.isReadEnded) {
      const chunk = await this.privStream.read();
      if (chunk !== void 0 && !chunk.isEnd) {
        let tmpBuffer;
        if (chunk.buffer.byteLength > dataBuffer.byteLength - totalBytes) {
          tmpBuffer = chunk.buffer.slice(0, dataBuffer.byteLength - totalBytes);
          this.privLastChunkView = new Int8Array(chunk.buffer.slice(dataBuffer.byteLength - totalBytes));
        } else {
          tmpBuffer = chunk.buffer;
        }
        intView.set(new Int8Array(tmpBuffer), totalBytes);
        totalBytes += tmpBuffer.byteLength;
      } else {
        this.privStream.readEnded();
      }
    }
    return totalBytes;
  }
  /**
   * Writes the audio data specified by making an internal copy of the data.
   * @member PullAudioOutputStreamImpl.prototype.write
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
   */
  write(dataBuffer) {
    Contracts_js_1$5.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing");
    this.privStream.writeStreamChunk({
      buffer: dataBuffer,
      isEnd: false,
      timeReceived: Date.now()
    });
  }
  /**
   * Closes the stream.
   * @member PullAudioOutputStreamImpl.prototype.close
   * @function
   * @public
   */
  close() {
    this.privStream.close();
  }
}
AudioOutputStream$1.PullAudioOutputStreamImpl = PullAudioOutputStreamImpl;
class PushAudioOutputStream extends AudioOutputStream {
  /**
   * Creates and initializes and instance.
   * @constructor
   */
  constructor() {
    super();
  }
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * write() and close() methods.
   * @member PushAudioOutputStream.create
   * @function
   * @public
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   * @returns {PushAudioOutputStream} The push audio output stream being created.
   */
  static create(callback) {
    return new PushAudioOutputStreamImpl(callback);
  }
}
AudioOutputStream$1.PushAudioOutputStream = PushAudioOutputStream;
class PushAudioOutputStreamImpl extends PushAudioOutputStream {
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * read() and close() methods.
   * @constructor
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   */
  constructor(callback) {
    super();
    this.privId = Exports_js_1$9.createNoDashGuid();
    this.privCallback = callback;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  set format(format) {
  }
  write(buffer) {
    if (!!this.privCallback.write) {
      this.privCallback.write(buffer);
    }
  }
  close() {
    if (!!this.privCallback.close) {
      this.privCallback.close();
    }
  }
  id() {
    return this.privId;
  }
}
AudioOutputStream$1.PushAudioOutputStreamImpl = PushAudioOutputStreamImpl;
var hasRequiredAudioConfig;
function requireAudioConfig() {
  if (hasRequiredAudioConfig) return AudioConfig;
  hasRequiredAudioConfig = 1;
  Object.defineProperty(AudioConfig, "__esModule", { value: true });
  AudioConfig.AudioOutputConfigImpl = AudioConfig.AudioConfigImpl = AudioConfig.AudioConfig = void 0;
  const Exports_js_12 = requireExports$2();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  const AudioFileWriter_js_1 = AudioFileWriter$1;
  const AudioInputStream_js_1 = requireAudioInputStream();
  const AudioOutputStream_js_12 = AudioOutputStream$1;
  let AudioConfig$1 = class AudioConfig2 {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const pcmRecorder = new Exports_js_12.PcmRecorder(true);
      return new AudioConfigImpl(new Exports_js_12.MicAudioSource(pcmRecorder));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(deviceId) {
      const pcmRecorder = new Exports_js_12.PcmRecorder(true);
      return new AudioConfigImpl(new Exports_js_12.MicAudioSource(pcmRecorder, deviceId));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(file, name2 = "unnamedBuffer.wav") {
      return new AudioConfigImpl(new Exports_js_12.FileAudioSource(file, name2));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(audioStream) {
      if (audioStream instanceof Exports_js_2.PullAudioInputStreamCallback) {
        return new AudioConfigImpl(new AudioInputStream_js_1.PullAudioInputStreamImpl(audioStream));
      }
      if (audioStream instanceof Exports_js_2.AudioInputStream) {
        return new AudioConfigImpl(audioStream);
      }
      if (typeof MediaStream !== "undefined" && audioStream instanceof MediaStream) {
        const pcmRecorder = new Exports_js_12.PcmRecorder(false);
        return new AudioConfigImpl(new Exports_js_12.MicAudioSource(pcmRecorder, null, null, audioStream));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new AudioOutputConfigImpl(new Exports_js_2.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(player) {
      if (player === void 0) {
        return AudioConfig2.fromDefaultSpeakerOutput();
      }
      if (player instanceof Exports_js_2.SpeakerAudioDestination) {
        return new AudioOutputConfigImpl(player);
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(filename) {
      return new AudioOutputConfigImpl(new AudioFileWriter_js_1.AudioFileWriter(filename));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(audioStream) {
      if (audioStream instanceof Exports_js_2.PushAudioOutputStreamCallback) {
        return new AudioOutputConfigImpl(new AudioOutputStream_js_12.PushAudioOutputStreamImpl(audioStream));
      }
      if (audioStream instanceof Exports_js_2.PushAudioOutputStream) {
        return new AudioOutputConfigImpl(audioStream);
      }
      if (audioStream instanceof Exports_js_2.PullAudioOutputStream) {
        return new AudioOutputConfigImpl(audioStream);
      }
      throw new Error("Not Supported Type");
    }
  };
  AudioConfig.AudioConfig = AudioConfig$1;
  class AudioConfigImpl extends AudioConfig$1 {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(source) {
      super();
      this.privSource = source;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(cb2, err2) {
      this.privSource.turnOff().then(() => {
        if (!!cb2) {
          cb2();
        }
      }, (error) => {
        if (!!err2) {
          err2(error);
        }
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(audioNodeId) {
      return this.privSource.attach(audioNodeId);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(audioNodeId) {
      return this.privSource.detach(audioNodeId);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(name2, value) {
      Contracts_js_12.Contracts.throwIfNull(value, "value");
      if (void 0 !== this.privSource.setProperty) {
        this.privSource.setProperty(name2, value);
      } else {
        throw new Error("This AudioConfig instance does not support setting properties.");
      }
    }
    getProperty(name2, def) {
      if (void 0 !== this.privSource.getProperty) {
        return this.privSource.getProperty(name2, def);
      } else {
        throw new Error("This AudioConfig instance does not support getting properties.");
      }
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  AudioConfig.AudioConfigImpl = AudioConfigImpl;
  class AudioOutputConfigImpl extends AudioConfig$1 {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(destination) {
      super();
      this.privDestination = destination;
    }
    set format(format) {
      this.privDestination.format = format;
    }
    write(buffer) {
      this.privDestination.write(buffer);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  AudioConfig.AudioOutputConfigImpl = AudioOutputConfigImpl;
  return AudioConfig;
}
var CancellationReason = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationReason = void 0;
  (function(CancellationReason2) {
    CancellationReason2[CancellationReason2["Error"] = 0] = "Error";
    CancellationReason2[CancellationReason2["EndOfStream"] = 1] = "EndOfStream";
  })(exports.CancellationReason || (exports.CancellationReason = {}));
})(CancellationReason);
var PullAudioInputStreamCallback$1 = {};
Object.defineProperty(PullAudioInputStreamCallback$1, "__esModule", { value: true });
PullAudioInputStreamCallback$1.PullAudioInputStreamCallback = void 0;
class PullAudioInputStreamCallback {
}
PullAudioInputStreamCallback$1.PullAudioInputStreamCallback = PullAudioInputStreamCallback;
var PushAudioOutputStreamCallback$1 = {};
Object.defineProperty(PushAudioOutputStreamCallback$1, "__esModule", { value: true });
PushAudioOutputStreamCallback$1.PushAudioOutputStreamCallback = void 0;
class PushAudioOutputStreamCallback {
}
PushAudioOutputStreamCallback$1.PushAudioOutputStreamCallback = PushAudioOutputStreamCallback;
var KeywordRecognitionModel$1 = {};
Object.defineProperty(KeywordRecognitionModel$1, "__esModule", { value: true });
KeywordRecognitionModel$1.KeywordRecognitionModel = void 0;
const Contracts_js_1$4 = Contracts$1;
class KeywordRecognitionModel {
  /**
   * Create and initializes a new instance.
   * @constructor
   */
  constructor() {
    this.privDisposed = false;
    return;
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromFile
   * @function
   * @public
   * @param {string} fileName - A string that represents file name for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model
   * will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromFile(fileName) {
    Contracts_js_1$4.Contracts.throwIfFileDoesNotExist(fileName, "fileName");
    throw new Error("Not yet implemented.");
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromStream
   * @function
   * @public
   * @param {string} file - A File that represents file for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromStream(file) {
    Contracts_js_1$4.Contracts.throwIfNull(file, "file");
    throw new Error("Not yet implemented.");
  }
  /**
   * Dispose of associated resources.
   * @member KeywordRecognitionModel.prototype.close
   * @function
   * @public
   */
  close() {
    if (this.privDisposed) {
      return;
    }
    this.privDisposed = true;
  }
}
KeywordRecognitionModel$1.KeywordRecognitionModel = KeywordRecognitionModel;
var SessionEventArgs$1 = {};
Object.defineProperty(SessionEventArgs$1, "__esModule", { value: true });
SessionEventArgs$1.SessionEventArgs = void 0;
class SessionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionId - The session id.
   */
  constructor(sessionId) {
    this.privSessionId = sessionId;
  }
  /**
   * Represents the session identifier.
   * @member SessionEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} Represents the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
}
SessionEventArgs$1.SessionEventArgs = SessionEventArgs;
var RecognitionEventArgs = {};
var hasRequiredRecognitionEventArgs;
function requireRecognitionEventArgs() {
  if (hasRequiredRecognitionEventArgs) return RecognitionEventArgs;
  hasRequiredRecognitionEventArgs = 1;
  Object.defineProperty(RecognitionEventArgs, "__esModule", { value: true });
  RecognitionEventArgs.RecognitionEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let RecognitionEventArgs$1 = class RecognitionEventArgs extends Exports_js_12.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(offset, sessionId) {
      super(sessionId);
      this.privOffset = offset;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  RecognitionEventArgs.RecognitionEventArgs = RecognitionEventArgs$1;
  return RecognitionEventArgs;
}
var OutputFormat = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OutputFormat = void 0;
  (function(OutputFormat2) {
    OutputFormat2[OutputFormat2["Simple"] = 0] = "Simple";
    OutputFormat2[OutputFormat2["Detailed"] = 1] = "Detailed";
  })(exports.OutputFormat || (exports.OutputFormat = {}));
})(OutputFormat);
var IntentRecognitionEventArgs = {};
var hasRequiredIntentRecognitionEventArgs;
function requireIntentRecognitionEventArgs() {
  if (hasRequiredIntentRecognitionEventArgs) return IntentRecognitionEventArgs;
  hasRequiredIntentRecognitionEventArgs = 1;
  Object.defineProperty(IntentRecognitionEventArgs, "__esModule", { value: true });
  IntentRecognitionEventArgs.IntentRecognitionEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let IntentRecognitionEventArgs$1 = class IntentRecognitionEventArgs extends Exports_js_12.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(result, offset, sessionId) {
      super(offset, sessionId);
      this.privResult = result;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  IntentRecognitionEventArgs.IntentRecognitionEventArgs = IntentRecognitionEventArgs$1;
  return IntentRecognitionEventArgs;
}
var RecognitionResult$1 = {};
Object.defineProperty(RecognitionResult$1, "__esModule", { value: true });
RecognitionResult$1.RecognitionResult = void 0;
class RecognitionResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
    this.privResultId = resultId;
    this.privReason = reason;
    this.privText = text2;
    this.privDuration = duration;
    this.privOffset = offset;
    this.privLanguage = language;
    this.privLanguageDetectionConfidence = languageDetectionConfidence;
    this.privErrorDetails = errorDetails;
    this.privJson = json;
    this.privProperties = properties;
  }
  /**
   * Specifies the result identifier.
   * @member RecognitionResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member RecognitionResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * Presents the recognized text in the result.
   * @member RecognitionResult.prototype.text
   * @function
   * @public
   * @returns {string} Presents the recognized text in the result.
   */
  get text() {
    return this.privText;
  }
  /**
   * Duration of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.duration
   * @function
   * @public
   * @returns {number} Duration of recognized speech in 100 nano second increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Offset of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.offset
   * @function
   * @public
   * @returns {number} Offset of recognized speech in 100 nano second increments.
   */
  get offset() {
    return this.privOffset;
  }
  /**
   * Primary Language detected.
   * @member RecognitionResult.prototype.language
   * @function
   * @public
   * @returns {string} language detected.
   */
  get language() {
    return this.privLanguage;
  }
  /**
   * Primary Language detection confidence (Unknown, Low, Medium, High).
   * @member RecognitionResult.prototype.languageDetectionConfidence
   * @function
   * @public
   * @returns {string} detection confidence strength.
   */
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member RecognitionResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * A string containing Json serialized recognition result as it was received from the service.
   * @member RecognitionResult.prototype.json
   * @function
   * @private
   * @returns {string} Json serialized representation of the result.
   */
  get json() {
    return this.privJson;
  }
  /**
   * The set of properties exposed in the result.
   * @member RecognitionResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
RecognitionResult$1.RecognitionResult = RecognitionResult;
var SpeechRecognitionResult = {};
var hasRequiredSpeechRecognitionResult;
function requireSpeechRecognitionResult() {
  if (hasRequiredSpeechRecognitionResult) return SpeechRecognitionResult;
  hasRequiredSpeechRecognitionResult = 1;
  Object.defineProperty(SpeechRecognitionResult, "__esModule", { value: true });
  SpeechRecognitionResult.SpeechRecognitionResult = void 0;
  const Exports_js_12 = requireExports$3();
  let SpeechRecognitionResult$1 = class SpeechRecognitionResult extends Exports_js_12.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
      super(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties);
      this.privSpeakerId = speakerId;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  SpeechRecognitionResult.SpeechRecognitionResult = SpeechRecognitionResult$1;
  return SpeechRecognitionResult;
}
var IntentRecognitionResult = {};
var hasRequiredIntentRecognitionResult;
function requireIntentRecognitionResult() {
  if (hasRequiredIntentRecognitionResult) return IntentRecognitionResult;
  hasRequiredIntentRecognitionResult = 1;
  Object.defineProperty(IntentRecognitionResult, "__esModule", { value: true });
  IntentRecognitionResult.IntentRecognitionResult = void 0;
  const Exports_js_12 = requireExports$3();
  let IntentRecognitionResult$1 = class IntentRecognitionResult extends Exports_js_12.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(intentId, resultId, reason, text2, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
      super(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, void 0, errorDetails, json, properties);
      this.privIntentId = intentId;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  IntentRecognitionResult.IntentRecognitionResult = IntentRecognitionResult$1;
  return IntentRecognitionResult;
}
var LanguageUnderstandingModel$1 = {};
Object.defineProperty(LanguageUnderstandingModel$1, "__esModule", { value: true });
LanguageUnderstandingModel$1.LanguageUnderstandingModelImpl = LanguageUnderstandingModel$1.LanguageUnderstandingModel = void 0;
const Contracts_js_1$3 = Contracts$1;
class LanguageUnderstandingModel {
  /**
   * Creates and initializes a new instance
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Creates an language understanding model using the specified endpoint.
   * @member LanguageUnderstandingModel.fromEndpoint
   * @function
   * @public
   * @param {URL} uri - A String that represents the endpoint of the language understanding model.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromEndpoint(uri) {
    Contracts_js_1$3.Contracts.throwIfNull(uri, "uri");
    Contracts_js_1$3.Contracts.throwIfNullOrWhitespace(uri.hostname, "uri");
    const langModelImp = new LanguageUnderstandingModelImpl();
    const firstDot = uri.host.indexOf(".");
    if (-1 === firstDot) {
      throw new Error("Could not determine region from endpoint");
    }
    langModelImp.region = uri.host.substr(0, firstDot);
    const lastSegment = uri.pathname.lastIndexOf("/") + 1;
    if (-1 === lastSegment) {
      throw new Error("Could not determine appId from endpoint");
    }
    langModelImp.appId = uri.pathname.substr(lastSegment);
    langModelImp.subscriptionKey = uri.searchParams.get("subscription-key");
    if (void 0 === langModelImp.subscriptionKey) {
      throw new Error("Could not determine subscription key from endpoint");
    }
    return langModelImp;
  }
  /**
   * Creates an language understanding model using the application id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromAppId
   * @function
   * @public
   * @param {string} appId - A String that represents the application id of Language Understanding service.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromAppId(appId) {
    Contracts_js_1$3.Contracts.throwIfNullOrWhitespace(appId, "appId");
    const langModelImp = new LanguageUnderstandingModelImpl();
    langModelImp.appId = appId;
    return langModelImp;
  }
  /**
   * Creates a language understanding model using hostname, subscription key and application
   * id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromSubscription
   * @function
   * @public
   * @param {string} subscriptionKey - A String that represents the subscription key of
   * Language Understanding service.
   * @param {string} appId - A String that represents the application id of Language
   * Understanding service.
   * @param {LanguageUnderstandingModel} region - A String that represents the region
   * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromSubscription(subscriptionKey, appId, region) {
    Contracts_js_1$3.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
    Contracts_js_1$3.Contracts.throwIfNullOrWhitespace(appId, "appId");
    Contracts_js_1$3.Contracts.throwIfNullOrWhitespace(region, "region");
    const langModelImp = new LanguageUnderstandingModelImpl();
    langModelImp.appId = appId;
    langModelImp.region = region;
    langModelImp.subscriptionKey = subscriptionKey;
    return langModelImp;
  }
}
LanguageUnderstandingModel$1.LanguageUnderstandingModel = LanguageUnderstandingModel;
class LanguageUnderstandingModelImpl extends LanguageUnderstandingModel {
}
LanguageUnderstandingModel$1.LanguageUnderstandingModelImpl = LanguageUnderstandingModelImpl;
var SpeechRecognitionEventArgs = {};
var hasRequiredSpeechRecognitionEventArgs;
function requireSpeechRecognitionEventArgs() {
  if (hasRequiredSpeechRecognitionEventArgs) return SpeechRecognitionEventArgs;
  hasRequiredSpeechRecognitionEventArgs = 1;
  Object.defineProperty(SpeechRecognitionEventArgs, "__esModule", { value: true });
  SpeechRecognitionEventArgs.MeetingTranscriptionEventArgs = SpeechRecognitionEventArgs.ConversationTranscriptionEventArgs = SpeechRecognitionEventArgs.SpeechRecognitionEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let SpeechRecognitionEventArgs$1 = class SpeechRecognitionEventArgs extends Exports_js_12.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(result, offset, sessionId) {
      super(offset, sessionId);
      this.privResult = result;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  SpeechRecognitionEventArgs.SpeechRecognitionEventArgs = SpeechRecognitionEventArgs$1;
  class ConversationTranscriptionEventArgs extends Exports_js_12.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(result, offset, sessionId) {
      super(offset, sessionId);
      this.privResult = result;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  SpeechRecognitionEventArgs.ConversationTranscriptionEventArgs = ConversationTranscriptionEventArgs;
  class MeetingTranscriptionEventArgs extends SpeechRecognitionEventArgs$1 {
  }
  SpeechRecognitionEventArgs.MeetingTranscriptionEventArgs = MeetingTranscriptionEventArgs;
  return SpeechRecognitionEventArgs;
}
var SpeechRecognitionCanceledEventArgs = {};
var CancellationEventArgsBase = {};
var hasRequiredCancellationEventArgsBase;
function requireCancellationEventArgsBase() {
  if (hasRequiredCancellationEventArgsBase) return CancellationEventArgsBase;
  hasRequiredCancellationEventArgsBase = 1;
  Object.defineProperty(CancellationEventArgsBase, "__esModule", { value: true });
  CancellationEventArgsBase.CancellationEventArgsBase = void 0;
  const Exports_js_12 = requireExports$3();
  let CancellationEventArgsBase$1 = class CancellationEventArgsBase extends Exports_js_12.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(reason, errorDetails, errorCode, offset, sessionId) {
      super(offset, sessionId);
      this.privReason = reason;
      this.privErrorDetails = errorDetails;
      this.privErrorCode = errorCode;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  CancellationEventArgsBase.CancellationEventArgsBase = CancellationEventArgsBase$1;
  return CancellationEventArgsBase;
}
var hasRequiredSpeechRecognitionCanceledEventArgs;
function requireSpeechRecognitionCanceledEventArgs() {
  if (hasRequiredSpeechRecognitionCanceledEventArgs) return SpeechRecognitionCanceledEventArgs;
  hasRequiredSpeechRecognitionCanceledEventArgs = 1;
  Object.defineProperty(SpeechRecognitionCanceledEventArgs, "__esModule", { value: true });
  SpeechRecognitionCanceledEventArgs.SpeechRecognitionCanceledEventArgs = void 0;
  const CancellationEventArgsBase_js_1 = requireCancellationEventArgsBase();
  let SpeechRecognitionCanceledEventArgs$1 = class SpeechRecognitionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {
  };
  SpeechRecognitionCanceledEventArgs.SpeechRecognitionCanceledEventArgs = SpeechRecognitionCanceledEventArgs$1;
  return SpeechRecognitionCanceledEventArgs;
}
var TranslationRecognitionEventArgs = {};
var hasRequiredTranslationRecognitionEventArgs;
function requireTranslationRecognitionEventArgs() {
  if (hasRequiredTranslationRecognitionEventArgs) return TranslationRecognitionEventArgs;
  hasRequiredTranslationRecognitionEventArgs = 1;
  Object.defineProperty(TranslationRecognitionEventArgs, "__esModule", { value: true });
  TranslationRecognitionEventArgs.TranslationRecognitionEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let TranslationRecognitionEventArgs$1 = class TranslationRecognitionEventArgs extends Exports_js_12.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(result, offset, sessionId) {
      super(offset, sessionId);
      this.privResult = result;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  TranslationRecognitionEventArgs.TranslationRecognitionEventArgs = TranslationRecognitionEventArgs$1;
  return TranslationRecognitionEventArgs;
}
var TranslationSynthesisEventArgs = {};
var hasRequiredTranslationSynthesisEventArgs;
function requireTranslationSynthesisEventArgs() {
  if (hasRequiredTranslationSynthesisEventArgs) return TranslationSynthesisEventArgs;
  hasRequiredTranslationSynthesisEventArgs = 1;
  Object.defineProperty(TranslationSynthesisEventArgs, "__esModule", { value: true });
  TranslationSynthesisEventArgs.TranslationSynthesisEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let TranslationSynthesisEventArgs$1 = class TranslationSynthesisEventArgs extends Exports_js_12.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(result, sessionId) {
      super(sessionId);
      this.privResult = result;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  TranslationSynthesisEventArgs.TranslationSynthesisEventArgs = TranslationSynthesisEventArgs$1;
  return TranslationSynthesisEventArgs;
}
var TranslationRecognitionResult = {};
var hasRequiredTranslationRecognitionResult;
function requireTranslationRecognitionResult() {
  if (hasRequiredTranslationRecognitionResult) return TranslationRecognitionResult;
  hasRequiredTranslationRecognitionResult = 1;
  Object.defineProperty(TranslationRecognitionResult, "__esModule", { value: true });
  TranslationRecognitionResult.TranslationRecognitionResult = void 0;
  const Exports_js_12 = requireExports$3();
  let TranslationRecognitionResult$1 = class TranslationRecognitionResult2 extends Exports_js_12.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(translations, resultId, reason, text2, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
      super(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, void 0, errorDetails, json, properties);
      this.privTranslations = translations;
    }
    static fromSpeechRecognitionResult(result) {
      return new TranslationRecognitionResult2(void 0, result.resultId, result.reason, result.text, result.duration, result.offset, result.language, result.languageDetectionConfidence, result.errorDetails, result.json, result.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  TranslationRecognitionResult.TranslationRecognitionResult = TranslationRecognitionResult$1;
  return TranslationRecognitionResult;
}
var TranslationSynthesisResult$1 = {};
Object.defineProperty(TranslationSynthesisResult$1, "__esModule", { value: true });
TranslationSynthesisResult$1.TranslationSynthesisResult = void 0;
class TranslationSynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {ResultReason} reason - The synthesis reason.
   * @param {ArrayBuffer} audio - The audio data.
   */
  constructor(reason, audio) {
    this.privReason = reason;
    this.privAudio = audio;
  }
  /**
   * Translated text in the target language.
   * @member TranslationSynthesisResult.prototype.audio
   * @function
   * @public
   * @returns {ArrayBuffer} Translated audio in the target language.
   */
  get audio() {
    return this.privAudio;
  }
  /**
   * The synthesis status.
   * @member TranslationSynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} The synthesis status.
   */
  get reason() {
    return this.privReason;
  }
}
TranslationSynthesisResult$1.TranslationSynthesisResult = TranslationSynthesisResult;
var ResultReason = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ResultReason = void 0;
  (function(ResultReason2) {
    ResultReason2[ResultReason2["NoMatch"] = 0] = "NoMatch";
    ResultReason2[ResultReason2["Canceled"] = 1] = "Canceled";
    ResultReason2[ResultReason2["RecognizingSpeech"] = 2] = "RecognizingSpeech";
    ResultReason2[ResultReason2["RecognizedSpeech"] = 3] = "RecognizedSpeech";
    ResultReason2[ResultReason2["RecognizedKeyword"] = 4] = "RecognizedKeyword";
    ResultReason2[ResultReason2["RecognizingIntent"] = 5] = "RecognizingIntent";
    ResultReason2[ResultReason2["RecognizedIntent"] = 6] = "RecognizedIntent";
    ResultReason2[ResultReason2["TranslatingSpeech"] = 7] = "TranslatingSpeech";
    ResultReason2[ResultReason2["TranslatedSpeech"] = 8] = "TranslatedSpeech";
    ResultReason2[ResultReason2["SynthesizingAudio"] = 9] = "SynthesizingAudio";
    ResultReason2[ResultReason2["SynthesizingAudioCompleted"] = 10] = "SynthesizingAudioCompleted";
    ResultReason2[ResultReason2["SynthesizingAudioStarted"] = 11] = "SynthesizingAudioStarted";
    ResultReason2[ResultReason2["EnrollingVoiceProfile"] = 12] = "EnrollingVoiceProfile";
    ResultReason2[ResultReason2["EnrolledVoiceProfile"] = 13] = "EnrolledVoiceProfile";
    ResultReason2[ResultReason2["RecognizedSpeakers"] = 14] = "RecognizedSpeakers";
    ResultReason2[ResultReason2["RecognizedSpeaker"] = 15] = "RecognizedSpeaker";
    ResultReason2[ResultReason2["ResetVoiceProfile"] = 16] = "ResetVoiceProfile";
    ResultReason2[ResultReason2["DeletedVoiceProfile"] = 17] = "DeletedVoiceProfile";
    ResultReason2[ResultReason2["VoicesListRetrieved"] = 18] = "VoicesListRetrieved";
    ResultReason2[ResultReason2["TranslatingParticipantSpeech"] = 19] = "TranslatingParticipantSpeech";
    ResultReason2[ResultReason2["TranslatedParticipantSpeech"] = 20] = "TranslatedParticipantSpeech";
    ResultReason2[ResultReason2["TranslatedInstantMessage"] = 21] = "TranslatedInstantMessage";
    ResultReason2[ResultReason2["TranslatedParticipantInstantMessage"] = 22] = "TranslatedParticipantInstantMessage";
  })(exports.ResultReason || (exports.ResultReason = {}));
})(ResultReason);
var SpeechConfig = {};
var hasRequiredSpeechConfig;
function requireSpeechConfig() {
  if (hasRequiredSpeechConfig) return SpeechConfig;
  hasRequiredSpeechConfig = 1;
  Object.defineProperty(SpeechConfig, "__esModule", { value: true });
  SpeechConfig.SpeechConfigImpl = SpeechConfig.SpeechConfig = void 0;
  const Exports_js_12 = requireExports();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  let SpeechConfig$1 = class SpeechConfig {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
      return;
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(subscriptionKey, region) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const speechImpl = new SpeechConfigImpl();
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_IntentRegion, region);
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      return speechImpl;
    }
    /**
     * Creates an instance of the speech config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * For example, if language is defined in the uri as query parameter "language=de-DE", and also set by
     * SpeechConfig.speechRecognitionLanguage = "en-US", the language setting in uri takes precedence,
     * and the effective language is "de-DE". Only the parameters that are not specified in the
     * endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromEndpoint(endpoint, subscriptionKey) {
      Contracts_js_12.Contracts.throwIfNull(endpoint, "endpoint");
      const speechImpl = new SpeechConfigImpl();
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);
      if (void 0 !== subscriptionKey) {
        speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      }
      return speechImpl;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(hostName, subscriptionKey) {
      Contracts_js_12.Contracts.throwIfNull(hostName, "hostName");
      const speechImpl = new SpeechConfigImpl();
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + (hostName.port === "" ? "" : ":" + hostName.port));
      if (void 0 !== subscriptionKey) {
        speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      }
      return speechImpl;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(authorizationToken, region) {
      Contracts_js_12.Contracts.throwIfNull(authorizationToken, "authorizationToken");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const speechImpl = new SpeechConfigImpl();
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_IntentRegion, region);
      speechImpl.authorizationToken = authorizationToken;
      return speechImpl;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  SpeechConfig.SpeechConfig = SpeechConfig$1;
  class SpeechConfigImpl extends SpeechConfig$1 {
    constructor() {
      super();
      this.privProperties = new Exports_js_2.PropertyCollection();
      this.speechRecognitionLanguage = "en-US";
      this.outputFormat = Exports_js_2.OutputFormat.Simple;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(value) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, value);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(value) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, value);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(value) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, value);
    }
    get outputFormat() {
      return Exports_js_2.OutputFormat[this.privProperties.getProperty(Exports_js_12.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(value) {
      this.privProperties.setProperty(Exports_js_12.OutputFormatPropertyName, Exports_js_2.OutputFormat[value]);
    }
    get endpointId() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(value) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, value);
    }
    setProperty(name2, value) {
      Contracts_js_12.Contracts.throwIfNull(value, "value");
      this.privProperties.setProperty(name2, value);
    }
    getProperty(name2, def) {
      return this.privProperties.getProperty(name2, def);
    }
    setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
    }
    setServiceProperty(name2, value) {
      const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_12.ServicePropertiesPropertyName, "{}"));
      currentProperties[name2] = value;
      this.privProperties.setProperty(Exports_js_12.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
    }
    setProfanity(profanity) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, Exports_js_2.ProfanityOption[profanity]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privProperties.setProperty(Exports_js_12.ForceDictationPropertyName, "true");
    }
    clone() {
      const ret = new SpeechConfigImpl();
      ret.privProperties = this.privProperties.clone();
      return ret;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(language) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage, language);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(voice) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice, voice);
    }
    get speechSynthesisOutputFormat() {
      return Exports_js_2.SpeechSynthesisOutputFormat[this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(format) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, Exports_js_2.SpeechSynthesisOutputFormat[format]);
    }
  }
  SpeechConfig.SpeechConfigImpl = SpeechConfigImpl;
  return SpeechConfig;
}
var SpeechTranslationConfig = {};
var hasRequiredSpeechTranslationConfig;
function requireSpeechTranslationConfig() {
  if (hasRequiredSpeechTranslationConfig) return SpeechTranslationConfig;
  hasRequiredSpeechTranslationConfig = 1;
  Object.defineProperty(SpeechTranslationConfig, "__esModule", { value: true });
  SpeechTranslationConfig.SpeechTranslationConfigImpl = SpeechTranslationConfig.SpeechTranslationConfig = void 0;
  const Exports_js_12 = requireExports();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  let SpeechTranslationConfig$1 = class SpeechTranslationConfig extends Exports_js_2.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(subscriptionKey, region) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const ret = new SpeechTranslationConfigImpl();
      ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
      return ret;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(authorizationToken, region) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const ret = new SpeechTranslationConfigImpl();
      ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
      ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
      return ret;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(hostName, subscriptionKey) {
      Contracts_js_12.Contracts.throwIfNull(hostName, "hostName");
      const speechImpl = new SpeechTranslationConfigImpl();
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + (hostName.port === "" ? "" : ":" + hostName.port));
      if (void 0 !== subscriptionKey) {
        speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      }
      return speechImpl;
    }
    /**
     * Creates an instance of the speech translation config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or paramters.
     * Note: The query properties specified in the endpoint URL are not changed, even if they are
     * set by any other APIs. For example, if language is defined in the uri as query parameter
     * "language=de-DE", and also set by the speechRecognitionLanguage property, the language
     * setting in uri takes precedence, and the effective language is "de-DE".
     * Only the properties that are not specified in the endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechTranslationConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key.
     * @returns {SpeechTranslationConfig} A speech config instance.
     */
    static fromEndpoint(endpoint, subscriptionKey) {
      Contracts_js_12.Contracts.throwIfNull(endpoint, "endpoint");
      Contracts_js_12.Contracts.throwIfNull(subscriptionKey, "subscriptionKey");
      const ret = new SpeechTranslationConfigImpl();
      ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);
      ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      return ret;
    }
  };
  SpeechTranslationConfig.SpeechTranslationConfig = SpeechTranslationConfig$1;
  class SpeechTranslationConfigImpl extends SpeechTranslationConfig$1 {
    constructor() {
      super();
      this.privSpeechProperties = new Exports_js_2.PropertyCollection();
      this.outputFormat = Exports_js_2.OutputFormat.Simple;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "value");
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, value);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "value");
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, value);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return Exports_js_2.OutputFormat[this.privSpeechProperties.getProperty(Exports_js_12.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(value) {
      this.privSpeechProperties.setProperty(Exports_js_12.OutputFormatPropertyName, Exports_js_2.OutputFormat[value]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(value) {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, value);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "value");
      const languages = this.targetLanguages;
      if (!languages.includes(value)) {
        languages.push(value);
        this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
      }
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      if (this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
      } else {
        return [];
      }
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "value");
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationVoice, value);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
    }
    setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);
      this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(name2, def) {
      return this.privSpeechProperties.getProperty(name2, def);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(name2, value) {
      this.privSpeechProperties.setProperty(name2, value);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
      return;
    }
    setServiceProperty(name2, value) {
      const currentProperties = JSON.parse(this.privSpeechProperties.getProperty(Exports_js_12.ServicePropertiesPropertyName, "{}"));
      currentProperties[name2] = value;
      this.privSpeechProperties.setProperty(Exports_js_12.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
    }
    setProfanity(profanity) {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, Exports_js_2.ProfanityOption[profanity]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(Exports_js_12.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(language) {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage, language);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(voice) {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice, voice);
    }
    get speechSynthesisOutputFormat() {
      return Exports_js_2.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(format) {
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, Exports_js_2.SpeechSynthesisOutputFormat[format]);
    }
  }
  SpeechTranslationConfig.SpeechTranslationConfigImpl = SpeechTranslationConfigImpl;
  return SpeechTranslationConfig;
}
var PropertyCollection = {};
var hasRequiredPropertyCollection;
function requirePropertyCollection() {
  if (hasRequiredPropertyCollection) return PropertyCollection;
  hasRequiredPropertyCollection = 1;
  Object.defineProperty(PropertyCollection, "__esModule", { value: true });
  PropertyCollection.PropertyCollection = void 0;
  const Exports_js_12 = requireExports$3();
  let PropertyCollection$1 = class PropertyCollection2 {
    constructor() {
      this.privKeys = [];
      this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(key, def) {
      let keyToUse;
      if (typeof key === "string") {
        keyToUse = key;
      } else {
        keyToUse = Exports_js_12.PropertyId[key];
      }
      for (let n2 = 0; n2 < this.privKeys.length; n2++) {
        if (this.privKeys[n2] === keyToUse) {
          return this.privValues[n2];
        }
      }
      if (def === void 0) {
        return void 0;
      }
      return String(def);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(key, value) {
      let keyToUse;
      if (typeof key === "string") {
        keyToUse = key;
      } else {
        keyToUse = Exports_js_12.PropertyId[key];
      }
      for (let n2 = 0; n2 < this.privKeys.length; n2++) {
        if (this.privKeys[n2] === keyToUse) {
          this.privValues[n2] = value;
          return;
        }
      }
      this.privKeys.push(keyToUse);
      this.privValues.push(value);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const clonedMap = new PropertyCollection2();
      for (let n2 = 0; n2 < this.privKeys.length; n2++) {
        clonedMap.privKeys.push(this.privKeys[n2]);
        clonedMap.privValues.push(this.privValues[n2]);
      }
      return clonedMap;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(destinationCollection) {
      this.privKeys.forEach((key) => {
        if (destinationCollection.getProperty(key, void 0) === void 0) {
          const value = this.getProperty(key);
          destinationCollection.setProperty(key, value);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  PropertyCollection.PropertyCollection = PropertyCollection$1;
  return PropertyCollection;
}
var PropertyId = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PropertyId = void 0;
  (function(PropertyId2) {
    PropertyId2[PropertyId2["SpeechServiceConnection_Key"] = 0] = "SpeechServiceConnection_Key";
    PropertyId2[PropertyId2["SpeechServiceConnection_Endpoint"] = 1] = "SpeechServiceConnection_Endpoint";
    PropertyId2[PropertyId2["SpeechServiceConnection_Region"] = 2] = "SpeechServiceConnection_Region";
    PropertyId2[PropertyId2["SpeechServiceAuthorization_Token"] = 3] = "SpeechServiceAuthorization_Token";
    PropertyId2[PropertyId2["SpeechServiceAuthorization_Type"] = 4] = "SpeechServiceAuthorization_Type";
    PropertyId2[PropertyId2["SpeechServiceConnection_EndpointId"] = 5] = "SpeechServiceConnection_EndpointId";
    PropertyId2[PropertyId2["SpeechServiceConnection_TranslationToLanguages"] = 6] = "SpeechServiceConnection_TranslationToLanguages";
    PropertyId2[PropertyId2["SpeechServiceConnection_TranslationVoice"] = 7] = "SpeechServiceConnection_TranslationVoice";
    PropertyId2[PropertyId2["SpeechServiceConnection_TranslationFeatures"] = 8] = "SpeechServiceConnection_TranslationFeatures";
    PropertyId2[PropertyId2["SpeechServiceConnection_IntentRegion"] = 9] = "SpeechServiceConnection_IntentRegion";
    PropertyId2[PropertyId2["SpeechServiceConnection_ProxyHostName"] = 10] = "SpeechServiceConnection_ProxyHostName";
    PropertyId2[PropertyId2["SpeechServiceConnection_ProxyPort"] = 11] = "SpeechServiceConnection_ProxyPort";
    PropertyId2[PropertyId2["SpeechServiceConnection_ProxyUserName"] = 12] = "SpeechServiceConnection_ProxyUserName";
    PropertyId2[PropertyId2["SpeechServiceConnection_ProxyPassword"] = 13] = "SpeechServiceConnection_ProxyPassword";
    PropertyId2[PropertyId2["SpeechServiceConnection_RecoMode"] = 14] = "SpeechServiceConnection_RecoMode";
    PropertyId2[PropertyId2["SpeechServiceConnection_RecoLanguage"] = 15] = "SpeechServiceConnection_RecoLanguage";
    PropertyId2[PropertyId2["Speech_SessionId"] = 16] = "Speech_SessionId";
    PropertyId2[PropertyId2["SpeechServiceConnection_SynthLanguage"] = 17] = "SpeechServiceConnection_SynthLanguage";
    PropertyId2[PropertyId2["SpeechServiceConnection_SynthVoice"] = 18] = "SpeechServiceConnection_SynthVoice";
    PropertyId2[PropertyId2["SpeechServiceConnection_SynthOutputFormat"] = 19] = "SpeechServiceConnection_SynthOutputFormat";
    PropertyId2[PropertyId2["SpeechServiceConnection_AutoDetectSourceLanguages"] = 20] = "SpeechServiceConnection_AutoDetectSourceLanguages";
    PropertyId2[PropertyId2["SpeechServiceResponse_RequestDetailedResultTrueFalse"] = 21] = "SpeechServiceResponse_RequestDetailedResultTrueFalse";
    PropertyId2[PropertyId2["SpeechServiceResponse_RequestProfanityFilterTrueFalse"] = 22] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse";
    PropertyId2[PropertyId2["SpeechServiceResponse_JsonResult"] = 23] = "SpeechServiceResponse_JsonResult";
    PropertyId2[PropertyId2["SpeechServiceResponse_JsonErrorDetails"] = 24] = "SpeechServiceResponse_JsonErrorDetails";
    PropertyId2[PropertyId2["CancellationDetails_Reason"] = 25] = "CancellationDetails_Reason";
    PropertyId2[PropertyId2["CancellationDetails_ReasonText"] = 26] = "CancellationDetails_ReasonText";
    PropertyId2[PropertyId2["CancellationDetails_ReasonDetailedText"] = 27] = "CancellationDetails_ReasonDetailedText";
    PropertyId2[PropertyId2["LanguageUnderstandingServiceResponse_JsonResult"] = 28] = "LanguageUnderstandingServiceResponse_JsonResult";
    PropertyId2[PropertyId2["SpeechServiceConnection_Url"] = 29] = "SpeechServiceConnection_Url";
    PropertyId2[PropertyId2["SpeechServiceConnection_InitialSilenceTimeoutMs"] = 30] = "SpeechServiceConnection_InitialSilenceTimeoutMs";
    PropertyId2[PropertyId2["SpeechServiceConnection_EndSilenceTimeoutMs"] = 31] = "SpeechServiceConnection_EndSilenceTimeoutMs";
    PropertyId2[PropertyId2["Speech_SegmentationSilenceTimeoutMs"] = 32] = "Speech_SegmentationSilenceTimeoutMs";
    PropertyId2[PropertyId2["SpeechServiceConnection_EnableAudioLogging"] = 33] = "SpeechServiceConnection_EnableAudioLogging";
    PropertyId2[PropertyId2["SpeechServiceConnection_LanguageIdMode"] = 34] = "SpeechServiceConnection_LanguageIdMode";
    PropertyId2[PropertyId2["SpeechServiceConnection_RecognitionEndpointVersion"] = 35] = "SpeechServiceConnection_RecognitionEndpointVersion";
    PropertyId2[PropertyId2["SpeechServiceConnection_SpeakerIdMode"] = 36] = "SpeechServiceConnection_SpeakerIdMode";
    PropertyId2[PropertyId2["SpeechServiceResponse_ProfanityOption"] = 37] = "SpeechServiceResponse_ProfanityOption";
    PropertyId2[PropertyId2["SpeechServiceResponse_PostProcessingOption"] = 38] = "SpeechServiceResponse_PostProcessingOption";
    PropertyId2[PropertyId2["SpeechServiceResponse_RequestWordLevelTimestamps"] = 39] = "SpeechServiceResponse_RequestWordLevelTimestamps";
    PropertyId2[PropertyId2["SpeechServiceResponse_StablePartialResultThreshold"] = 40] = "SpeechServiceResponse_StablePartialResultThreshold";
    PropertyId2[PropertyId2["SpeechServiceResponse_OutputFormatOption"] = 41] = "SpeechServiceResponse_OutputFormatOption";
    PropertyId2[PropertyId2["SpeechServiceResponse_TranslationRequestStablePartialResult"] = 42] = "SpeechServiceResponse_TranslationRequestStablePartialResult";
    PropertyId2[PropertyId2["SpeechServiceResponse_RequestWordBoundary"] = 43] = "SpeechServiceResponse_RequestWordBoundary";
    PropertyId2[PropertyId2["SpeechServiceResponse_RequestPunctuationBoundary"] = 44] = "SpeechServiceResponse_RequestPunctuationBoundary";
    PropertyId2[PropertyId2["SpeechServiceResponse_RequestSentenceBoundary"] = 45] = "SpeechServiceResponse_RequestSentenceBoundary";
    PropertyId2[PropertyId2["Conversation_ApplicationId"] = 46] = "Conversation_ApplicationId";
    PropertyId2[PropertyId2["Conversation_DialogType"] = 47] = "Conversation_DialogType";
    PropertyId2[PropertyId2["Conversation_Initial_Silence_Timeout"] = 48] = "Conversation_Initial_Silence_Timeout";
    PropertyId2[PropertyId2["Conversation_From_Id"] = 49] = "Conversation_From_Id";
    PropertyId2[PropertyId2["Conversation_Conversation_Id"] = 50] = "Conversation_Conversation_Id";
    PropertyId2[PropertyId2["Conversation_Custom_Voice_Deployment_Ids"] = 51] = "Conversation_Custom_Voice_Deployment_Ids";
    PropertyId2[PropertyId2["Conversation_Speech_Activity_Template"] = 52] = "Conversation_Speech_Activity_Template";
    PropertyId2[PropertyId2["Conversation_Request_Bot_Status_Messages"] = 53] = "Conversation_Request_Bot_Status_Messages";
    PropertyId2[PropertyId2["Conversation_Agent_Connection_Id"] = 54] = "Conversation_Agent_Connection_Id";
    PropertyId2[PropertyId2["SpeechServiceConnection_Host"] = 55] = "SpeechServiceConnection_Host";
    PropertyId2[PropertyId2["ConversationTranslator_Host"] = 56] = "ConversationTranslator_Host";
    PropertyId2[PropertyId2["ConversationTranslator_Name"] = 57] = "ConversationTranslator_Name";
    PropertyId2[PropertyId2["ConversationTranslator_CorrelationId"] = 58] = "ConversationTranslator_CorrelationId";
    PropertyId2[PropertyId2["ConversationTranslator_Token"] = 59] = "ConversationTranslator_Token";
    PropertyId2[PropertyId2["PronunciationAssessment_ReferenceText"] = 60] = "PronunciationAssessment_ReferenceText";
    PropertyId2[PropertyId2["PronunciationAssessment_GradingSystem"] = 61] = "PronunciationAssessment_GradingSystem";
    PropertyId2[PropertyId2["PronunciationAssessment_Granularity"] = 62] = "PronunciationAssessment_Granularity";
    PropertyId2[PropertyId2["PronunciationAssessment_EnableMiscue"] = 63] = "PronunciationAssessment_EnableMiscue";
    PropertyId2[PropertyId2["PronunciationAssessment_Json"] = 64] = "PronunciationAssessment_Json";
    PropertyId2[PropertyId2["PronunciationAssessment_Params"] = 65] = "PronunciationAssessment_Params";
    PropertyId2[PropertyId2["SpeakerRecognition_Api_Version"] = 66] = "SpeakerRecognition_Api_Version";
    PropertyId2[PropertyId2["WebWorkerLoadType"] = 67] = "WebWorkerLoadType";
    PropertyId2[PropertyId2["TalkingAvatarService_WebRTC_SDP"] = 68] = "TalkingAvatarService_WebRTC_SDP";
  })(exports.PropertyId || (exports.PropertyId = {}));
})(PropertyId);
var Recognizer = {};
var hasRequiredRecognizer;
function requireRecognizer() {
  if (hasRequiredRecognizer) return Recognizer;
  hasRequiredRecognizer = 1;
  Object.defineProperty(Recognizer, "__esModule", { value: true });
  Recognizer.Recognizer = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let Recognizer$1 = class Recognizer2 {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(audioConfig, properties, connectionFactory) {
      this.audioConfig = audioConfig !== void 0 ? audioConfig : Exports_js_3.AudioConfig.fromDefaultMicrophoneInput();
      this.privDisposed = false;
      this.privProperties = properties.clone();
      this.privConnectionFactory = connectionFactory;
      this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(cb2, errorCb) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, errorCb);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(disposing) {
      if (this.privDisposed) {
        return;
      }
      this.privDisposed = true;
      if (disposing) {
        if (this.privReco) {
          await this.privReco.audioSource.turnOff();
          await this.privReco.dispose();
        }
      }
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return Exports_js_12.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(enabled) {
      Exports_js_12.ServiceRecognizerBase.telemetryDataEnabled = enabled;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let osPlatform = typeof window !== "undefined" ? "Browser" : "Node";
      let osName = "unknown";
      let osVersion = "unknown";
      if (typeof navigator !== "undefined") {
        osPlatform = osPlatform + "/" + navigator.platform;
        osName = navigator.userAgent;
        osVersion = navigator.appVersion;
      }
      const recognizerConfig = this.createRecognizerConfig(new Exports_js_12.SpeechServiceConfig(new Exports_js_12.Context(new Exports_js_12.OS(osPlatform, osName, osVersion))));
      this.privReco = this.createServiceRecognizer(Recognizer2.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, recognizerConfig);
    }
    async recognizeOnceAsyncImpl(recognitionMode) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
      const ret = new Exports_js_2.Deferred();
      await this.implRecognizerStop();
      await this.privReco.recognize(recognitionMode, ret.resolve, ret.reject);
      const result = await ret.promise;
      await this.implRecognizerStop();
      return result;
    }
    async startContinuousRecognitionAsyncImpl(recognitionMode) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
      await this.implRecognizerStop();
      await this.privReco.recognize(recognitionMode, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
      await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      if (this.privReco) {
        await this.privReco.stopRecognizing();
      }
      return;
    }
    static getAuthFromProperties(properties) {
      const subscriptionKey = properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Key, void 0);
      const authentication = subscriptionKey && subscriptionKey !== "" ? new Exports_js_12.CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new Exports_js_12.CognitiveTokenAuthentication(() => {
        const authorizationToken = properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(authorizationToken);
      }, () => {
        const authorizationToken = properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(authorizationToken);
      });
      return authentication;
    }
  };
  Recognizer.Recognizer = Recognizer$1;
  return Recognizer;
}
var SpeechRecognizer = {};
var hasRequiredSpeechRecognizer;
function requireSpeechRecognizer() {
  if (hasRequiredSpeechRecognizer) return SpeechRecognizer;
  hasRequiredSpeechRecognizer = 1;
  Object.defineProperty(SpeechRecognizer, "__esModule", { value: true });
  SpeechRecognizer.SpeechRecognizer = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let SpeechRecognizer$1 = class SpeechRecognizer2 extends Exports_js_3.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(speechConfig, audioConfig) {
      const speechConfigImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
      super(audioConfig, speechConfigImpl.properties, new Exports_js_12.SpeechConnectionFactory());
      this.privDisposedRecognizer = false;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
      const speechConfigImpl = speechConfig;
      autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
      const recognizer = new SpeechRecognizer2(speechConfig, audioConfig);
      return recognizer;
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      if (this.properties.getProperty(Exports_js_12.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) === Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) {
        return Exports_js_3.OutputFormat.Simple;
      } else {
        return Exports_js_3.OutputFormat.Detailed;
      }
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_12.RecognitionMode.Interactive), cb2, err2);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_12.RecognitionMode.Conversation), cb2, err2);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb2, err2);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(model, cb2, err2) {
      Contracts_js_12.Contracts.throwIfNull(model, "model");
      if (!!err2) {
        err2("Not yet implemented.");
      }
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(cb2) {
      if (!!cb2) {
        cb2();
      }
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(cb2, errorCb) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, errorCb);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(disposing) {
      if (this.privDisposedRecognizer) {
        return;
      }
      if (disposing) {
        this.privDisposedRecognizer = true;
        await this.implRecognizerStop();
      }
      await super.dispose(disposing);
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const configImpl = audioConfig;
      return new Exports_js_12.SpeechServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    }
  };
  SpeechRecognizer.SpeechRecognizer = SpeechRecognizer$1;
  return SpeechRecognizer;
}
var IntentRecognizer = {};
var hasRequiredIntentRecognizer;
function requireIntentRecognizer() {
  if (hasRequiredIntentRecognizer) return IntentRecognizer;
  hasRequiredIntentRecognizer = 1;
  Object.defineProperty(IntentRecognizer, "__esModule", { value: true });
  IntentRecognizer.IntentRecognizer = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let IntentRecognizer$1 = class IntentRecognizer extends Exports_js_3.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(speechConfig, audioConfig) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
      const configImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(configImpl, "speechConfig");
      super(audioConfig, configImpl.properties, new Exports_js_12.IntentConnectionFactory());
      this.privAddedIntents = [];
      this.privAddedLmIntents = {};
      this.privDisposedIntentRecognizer = false;
      this.privProperties = configImpl.properties;
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(value) {
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, value);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(cb2, err2) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
      if (Object.keys(this.privAddedLmIntents).length !== 0 || void 0 !== this.privUmbrellaIntent) {
        const context = this.buildSpeechContext();
        this.privReco.speechContext.setSection("intent", context.Intent);
        this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);
        const intentReco = this.privReco;
        intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_12.RecognitionMode.Interactive), cb2, err2);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(cb2, err2) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || void 0 !== this.privUmbrellaIntent) {
        const context = this.buildSpeechContext();
        this.privReco.speechContext.setSection("intent", context.Intent);
        this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);
        const intentReco = this.privReco;
        intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_12.RecognitionMode.Conversation), cb2, err2);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb2, err2);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(model, cb2, err2) {
      Contracts_js_12.Contracts.throwIfNull(model, "model");
      if (!!err2) {
        err2("Not yet implemented.");
      }
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(cb2, err2) {
      if (!!cb2) {
        try {
          cb2();
        } catch (e) {
          if (!!err2) {
            err2(e);
          }
        }
      }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(simplePhrase, intentId) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(intentId, "intentId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(simplePhrase, "simplePhrase");
      this.privAddedIntents.push([intentId, simplePhrase]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(intentId, model, intentName) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(intentId, "intentId");
      Contracts_js_12.Contracts.throwIfNull(model, "model");
      const modelImpl = model;
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(modelImpl.appId, "model.appId");
      this.privAddedLmIntents[intentId] = new Exports_js_12.AddedLmIntent(modelImpl, intentName);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(model, intentId) {
      Contracts_js_12.Contracts.throwIfNull(model, "model");
      const modelImpl = model;
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(modelImpl.appId, "model.appId");
      this.privUmbrellaIntent = new Exports_js_12.AddedLmIntent(modelImpl, intentId);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(cb2, errorCb) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, errorCb);
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const audioImpl = audioConfig;
      return new Exports_js_12.IntentServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
    }
    async dispose(disposing) {
      if (this.privDisposedIntentRecognizer) {
        return;
      }
      if (disposing) {
        this.privDisposedIntentRecognizer = true;
        await super.dispose(disposing);
      }
    }
    buildSpeechContext() {
      let appId;
      let region;
      let subscriptionKey;
      const refGrammers = [];
      if (void 0 !== this.privUmbrellaIntent) {
        appId = this.privUmbrellaIntent.modelImpl.appId;
        region = this.privUmbrellaIntent.modelImpl.region;
        subscriptionKey = this.privUmbrellaIntent.modelImpl.subscriptionKey;
      }
      for (const intentId of Object.keys(this.privAddedLmIntents)) {
        const addedLmIntent = this.privAddedLmIntents[intentId];
        if (appId === void 0) {
          appId = addedLmIntent.modelImpl.appId;
        } else {
          if (appId !== addedLmIntent.modelImpl.appId) {
            throw new Error("Intents must all be from the same LUIS model");
          }
        }
        if (region === void 0) {
          region = addedLmIntent.modelImpl.region;
        } else {
          if (region !== addedLmIntent.modelImpl.region) {
            throw new Error("Intents must all be from the same LUIS model in a single region");
          }
        }
        if (subscriptionKey === void 0) {
          subscriptionKey = addedLmIntent.modelImpl.subscriptionKey;
        } else {
          if (subscriptionKey !== addedLmIntent.modelImpl.subscriptionKey) {
            throw new Error("Intents must all use the same subscription key");
          }
        }
        const grammer = "luis/" + appId + "-PRODUCTION#" + intentId;
        refGrammers.push(grammer);
      }
      return {
        Intent: {
          id: appId,
          key: subscriptionKey === void 0 ? this.privProperties.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key]) : subscriptionKey,
          provider: "LUIS"
        },
        ReferenceGrammars: void 0 === this.privUmbrellaIntent ? refGrammers : ["luis/" + appId + "-PRODUCTION"]
      };
    }
  };
  IntentRecognizer.IntentRecognizer = IntentRecognizer$1;
  return IntentRecognizer;
}
var VoiceProfileType = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VoiceProfileType = void 0;
  (function(VoiceProfileType2) {
    VoiceProfileType2[VoiceProfileType2["TextIndependentIdentification"] = 0] = "TextIndependentIdentification";
    VoiceProfileType2[VoiceProfileType2["TextDependentVerification"] = 1] = "TextDependentVerification";
    VoiceProfileType2[VoiceProfileType2["TextIndependentVerification"] = 2] = "TextIndependentVerification";
  })(exports.VoiceProfileType || (exports.VoiceProfileType = {}));
})(VoiceProfileType);
var TranslationRecognizer = {};
var Connection = {};
var ConnectionMessage = {};
var hasRequiredConnectionMessage;
function requireConnectionMessage() {
  if (hasRequiredConnectionMessage) return ConnectionMessage;
  hasRequiredConnectionMessage = 1;
  Object.defineProperty(ConnectionMessage, "__esModule", { value: true });
  ConnectionMessage.ConnectionMessageImpl = ConnectionMessage.ConnectionMessage = void 0;
  const HeaderNames_js_12 = HeaderNames$1;
  const Exports_js_12 = requireExports$5();
  const PropertyCollection_js_1 = requirePropertyCollection();
  const PropertyId_js_1 = PropertyId;
  let ConnectionMessage$12 = class ConnectionMessage {
  };
  ConnectionMessage.ConnectionMessage = ConnectionMessage$12;
  class ConnectionMessageImpl {
    constructor(message) {
      this.privConnectionMessage = message;
      this.privProperties = new PropertyCollection_js_1.PropertyCollection();
      if (!!this.privConnectionMessage.headers[HeaderNames_js_12.HeaderNames.ConnectionId]) {
        this.privProperties.setProperty(PropertyId_js_1.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames_js_12.HeaderNames.ConnectionId]);
      }
      Object.keys(this.privConnectionMessage.headers).forEach((header) => {
        this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key) => key.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === Exports_js_12.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === Exports_js_12.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  ConnectionMessage.ConnectionMessageImpl = ConnectionMessageImpl;
  return ConnectionMessage;
}
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return Connection;
  hasRequiredConnection = 1;
  Object.defineProperty(Connection, "__esModule", { value: true });
  Connection.Connection = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const ConnectionMessage_js_12 = requireConnectionMessage();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let Connection$1 = class Connection2 {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(recognizer) {
      const recoBase = recognizer.internalData;
      const ret = new Connection2();
      ret.privInternalData = recoBase;
      ret.setupEvents();
      return ret;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(synthesizer) {
      const synthBase = synthesizer.internalData;
      const ret = new Connection2();
      ret.privInternalData = synthBase;
      ret.setupEvents();
      return ret;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.connect(), cb2, err2);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(cb2, err2) {
      if (this.privInternalData instanceof Exports_js_12.SynthesisAdapterBase) {
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      } else {
        Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb2, err2);
      }
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(path, propertyName, propertyValue) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(propertyName, "propertyName");
      if (this.privInternalData instanceof Exports_js_12.ServiceRecognizerBase) {
        if (path.toLowerCase() !== "speech.context") {
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        } else {
          this.privInternalData.speechContext.setSection(propertyName, propertyValue);
        }
      } else if (this.privInternalData instanceof Exports_js_12.SynthesisAdapterBase) {
        if (path.toLowerCase() !== "synthesis.context") {
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        } else {
          this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);
        }
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(path, payload, success, error) {
      Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((connectionEvent) => {
        if (connectionEvent.name === "ConnectionEstablishedEvent") {
          if (!!this.connected) {
            this.connected(new Exports_js_3.ConnectionEventArgs(connectionEvent.connectionId));
          }
        } else if (connectionEvent.name === "ConnectionClosedEvent") {
          if (!!this.disconnected) {
            this.disconnected(new Exports_js_3.ConnectionEventArgs(connectionEvent.connectionId));
          }
        } else if (connectionEvent.name === "ConnectionMessageSentEvent") {
          if (!!this.messageSent) {
            this.messageSent(new Exports_js_3.ConnectionMessageEventArgs(new ConnectionMessage_js_12.ConnectionMessageImpl(connectionEvent.message)));
          }
        } else if (connectionEvent.name === "ConnectionMessageReceivedEvent") {
          if (!!this.messageReceived) {
            this.messageReceived(new Exports_js_3.ConnectionMessageEventArgs(new ConnectionMessage_js_12.ConnectionMessageImpl(connectionEvent.message)));
          }
        }
      });
      this.privServiceEventListener = this.privInternalData.serviceEvents.attach((e) => {
        if (!!this.receivedServiceMessage) {
          this.receivedServiceMessage(new Exports_js_3.ServiceEventArgs(e.jsonString, e.name));
        }
      });
    }
  };
  Connection.Connection = Connection$1;
  return Connection;
}
var hasRequiredTranslationRecognizer;
function requireTranslationRecognizer() {
  if (hasRequiredTranslationRecognizer) return TranslationRecognizer;
  hasRequiredTranslationRecognizer = 1;
  Object.defineProperty(TranslationRecognizer, "__esModule", { value: true });
  TranslationRecognizer.TranslationRecognizer = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Connection_js_1 = requireConnection();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let TranslationRecognizer$1 = class TranslationRecognizer2 extends Exports_js_3.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(speechConfig, audioConfig, connectionFactory) {
      const configImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(configImpl, "speechConfig");
      super(audioConfig, configImpl.properties, connectionFactory || new Exports_js_12.TranslationConnectionFactory());
      this.privDisposedTranslationRecognizer = false;
      if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0) {
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice]);
      }
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages]);
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(speechTranslationConfig, autoDetectSourceLanguageConfig, audioConfig) {
      const speechTranslationConfigImpl = speechTranslationConfig;
      autoDetectSourceLanguageConfig.properties.mergeTo(speechTranslationConfigImpl.properties);
      return new TranslationRecognizer2(speechTranslationConfig, audioConfig);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(value) {
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, value);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(cb2, err2) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
      Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_12.RecognitionMode.Interactive), cb2, err2);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_12.RecognitionMode.Conversation), cb2, err2);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb2, err2);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(lang) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(lang, "language to be removed");
      if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const languages = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
        const index2 = languages.indexOf(lang);
        if (index2 > -1) {
          languages.splice(index2, 1);
          this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
          this.updateLanguages(languages);
        }
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(lang) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(lang, "language to be added");
      let languages = [];
      if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        languages = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
        if (!languages.includes(lang)) {
          languages.push(lang);
          this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
        }
      } else {
        this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, lang);
        languages = [lang];
      }
      this.updateLanguages(languages);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(cb2, errorCb) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, errorCb);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(disposing) {
      if (this.privDisposedTranslationRecognizer) {
        return;
      }
      this.privDisposedTranslationRecognizer = true;
      if (disposing) {
        await this.implRecognizerStop();
        await super.dispose(disposing);
      }
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const configImpl = audioConfig;
      return new Exports_js_12.TranslationServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    }
    updateLanguages(languages) {
      const conn = Connection_js_1.Connection.fromRecognizer(this);
      if (!!conn) {
        conn.setMessageProperty("speech.context", "translationcontext", { to: languages });
        conn.sendMessageAsync("event", JSON.stringify({
          id: "translation",
          name: "updateLanguage",
          to: languages
        }));
      }
    }
  };
  TranslationRecognizer.TranslationRecognizer = TranslationRecognizer$1;
  return TranslationRecognizer;
}
var Translations = {};
var hasRequiredTranslations;
function requireTranslations() {
  if (hasRequiredTranslations) return Translations;
  hasRequiredTranslations = 1;
  Object.defineProperty(Translations, "__esModule", { value: true });
  Translations.Translations = void 0;
  const Exports_js_12 = requireExports$3();
  let Translations$1 = class Translations {
    constructor() {
      this.privMap = new Exports_js_12.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(key, def) {
      return this.privMap.getProperty(key, def);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(key, value) {
      this.privMap.setProperty(key, value);
    }
  };
  Translations.Translations = Translations$1;
  return Translations;
}
var NoMatchReason = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoMatchReason = void 0;
  (function(NoMatchReason2) {
    NoMatchReason2[NoMatchReason2["NotRecognized"] = 0] = "NotRecognized";
    NoMatchReason2[NoMatchReason2["InitialSilenceTimeout"] = 1] = "InitialSilenceTimeout";
    NoMatchReason2[NoMatchReason2["InitialBabbleTimeout"] = 2] = "InitialBabbleTimeout";
  })(exports.NoMatchReason || (exports.NoMatchReason = {}));
})(NoMatchReason);
var NoMatchDetails = {};
var hasRequiredNoMatchDetails;
function requireNoMatchDetails() {
  if (hasRequiredNoMatchDetails) return NoMatchDetails;
  hasRequiredNoMatchDetails = 1;
  Object.defineProperty(NoMatchDetails, "__esModule", { value: true });
  NoMatchDetails.NoMatchDetails = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$3();
  let NoMatchDetails$1 = class NoMatchDetails2 {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(reason) {
      this.privReason = reason;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(result) {
      const simpleSpeech = Exports_js_12.SimpleSpeechPhrase.fromJSON(result.json);
      let reason = Exports_js_2.NoMatchReason.NotRecognized;
      switch (simpleSpeech.RecognitionStatus) {
        case Exports_js_12.RecognitionStatus.BabbleTimeout:
          reason = Exports_js_2.NoMatchReason.InitialBabbleTimeout;
          break;
        case Exports_js_12.RecognitionStatus.InitialSilenceTimeout:
          reason = Exports_js_2.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          reason = Exports_js_2.NoMatchReason.NotRecognized;
          break;
      }
      return new NoMatchDetails2(reason);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  NoMatchDetails.NoMatchDetails = NoMatchDetails$1;
  return NoMatchDetails;
}
var TranslationRecognitionCanceledEventArgs$1 = {};
Object.defineProperty(TranslationRecognitionCanceledEventArgs$1, "__esModule", { value: true });
TranslationRecognitionCanceledEventArgs$1.TranslationRecognitionCanceledEventArgs = void 0;
class TranslationRecognitionCanceledEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionid - The session id.
   * @param {CancellationReason} cancellationReason - The cancellation reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {TranslationRecognitionResult} result - The result.
   */
  constructor(sessionid, cancellationReason, errorDetails, errorCode, result) {
    this.privCancelReason = cancellationReason;
    this.privErrorDetails = errorDetails;
    this.privResult = result;
    this.privSessionId = sessionid;
    this.privErrorCode = errorCode;
  }
  /**
   * Specifies the recognition result.
   * @member TranslationRecognitionCanceledEventArgs.prototype.result
   * @function
   * @public
   * @returns {TranslationRecognitionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
  /**
   * Specifies the session identifier.
   * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
  /**
   * The reason the recognition was canceled.
   * @member TranslationRecognitionCanceledEventArgs.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privCancelReason;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get errorCode() {
    return this.privErrorCode;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
}
TranslationRecognitionCanceledEventArgs$1.TranslationRecognitionCanceledEventArgs = TranslationRecognitionCanceledEventArgs;
var IntentRecognitionCanceledEventArgs = {};
var hasRequiredIntentRecognitionCanceledEventArgs;
function requireIntentRecognitionCanceledEventArgs() {
  if (hasRequiredIntentRecognitionCanceledEventArgs) return IntentRecognitionCanceledEventArgs;
  hasRequiredIntentRecognitionCanceledEventArgs = 1;
  Object.defineProperty(IntentRecognitionCanceledEventArgs, "__esModule", { value: true });
  IntentRecognitionCanceledEventArgs.IntentRecognitionCanceledEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let IntentRecognitionCanceledEventArgs$1 = class IntentRecognitionCanceledEventArgs extends Exports_js_12.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(reason, errorDetails, errorCode, result, offset, sessionId) {
      super(result, offset, sessionId);
      this.privReason = reason;
      this.privErrorDetails = errorDetails;
      this.privErrorCode = errorCode;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  IntentRecognitionCanceledEventArgs.IntentRecognitionCanceledEventArgs = IntentRecognitionCanceledEventArgs$1;
  return IntentRecognitionCanceledEventArgs;
}
var CancellationDetailsBase$1 = {};
Object.defineProperty(CancellationDetailsBase$1, "__esModule", { value: true });
CancellationDetailsBase$1.CancellationDetailsBase = void 0;
class CancellationDetailsBase {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {CancellationReason} reason - The cancellation reason.
   * @param {string} errorDetails - The error details, if provided.
   */
  constructor(reason, errorDetails, errorCode) {
    this.privReason = reason;
    this.privErrorDetails = errorDetails;
    this.privErrorCode = errorCode;
  }
  /**
   * The reason the recognition was canceled.
   * @member CancellationDetailsBase.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member CancellationDetailsBase.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get ErrorCode() {
    return this.privErrorCode;
  }
}
CancellationDetailsBase$1.CancellationDetailsBase = CancellationDetailsBase;
var CancellationDetails = {};
var hasRequiredCancellationDetails;
function requireCancellationDetails() {
  if (hasRequiredCancellationDetails) return CancellationDetails;
  hasRequiredCancellationDetails = 1;
  Object.defineProperty(CancellationDetails, "__esModule", { value: true });
  CancellationDetails.CancellationDetails = void 0;
  const Exports_js_12 = requireExports();
  const CancellationDetailsBase_js_1 = CancellationDetailsBase$1;
  const Exports_js_2 = requireExports$3();
  let CancellationDetails$1 = class CancellationDetails2 extends CancellationDetailsBase_js_1.CancellationDetailsBase {
    constructor(reason, errorDetails, errorCode) {
      super(reason, errorDetails, errorCode);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(result) {
      let reason = Exports_js_2.CancellationReason.Error;
      let errorCode = Exports_js_2.CancellationErrorCode.NoError;
      if (result instanceof Exports_js_2.RecognitionResult && !!result.json) {
        const simpleSpeech = Exports_js_12.SimpleSpeechPhrase.fromJSON(result.json);
        reason = Exports_js_12.EnumTranslation.implTranslateCancelResult(simpleSpeech.RecognitionStatus);
      }
      if (!!result.properties) {
        errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])];
      }
      return new CancellationDetails2(reason, result.errorDetails || Exports_js_12.EnumTranslation.implTranslateErrorDetails(errorCode), errorCode);
    }
  };
  CancellationDetails.CancellationDetails = CancellationDetails$1;
  return CancellationDetails;
}
var CancellationErrorCodes = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancellationErrorCode = void 0;
  (function(CancellationErrorCode) {
    CancellationErrorCode[CancellationErrorCode["NoError"] = 0] = "NoError";
    CancellationErrorCode[CancellationErrorCode["AuthenticationFailure"] = 1] = "AuthenticationFailure";
    CancellationErrorCode[CancellationErrorCode["BadRequestParameters"] = 2] = "BadRequestParameters";
    CancellationErrorCode[CancellationErrorCode["TooManyRequests"] = 3] = "TooManyRequests";
    CancellationErrorCode[CancellationErrorCode["ConnectionFailure"] = 4] = "ConnectionFailure";
    CancellationErrorCode[CancellationErrorCode["ServiceTimeout"] = 5] = "ServiceTimeout";
    CancellationErrorCode[CancellationErrorCode["ServiceError"] = 6] = "ServiceError";
    CancellationErrorCode[CancellationErrorCode["RuntimeError"] = 7] = "RuntimeError";
    CancellationErrorCode[CancellationErrorCode["Forbidden"] = 8] = "Forbidden";
  })(exports.CancellationErrorCode || (exports.CancellationErrorCode = {}));
})(CancellationErrorCodes);
var ConnectionEventArgs = {};
var hasRequiredConnectionEventArgs;
function requireConnectionEventArgs() {
  if (hasRequiredConnectionEventArgs) return ConnectionEventArgs;
  hasRequiredConnectionEventArgs = 1;
  Object.defineProperty(ConnectionEventArgs, "__esModule", { value: true });
  ConnectionEventArgs.ConnectionEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let ConnectionEventArgs$1 = class ConnectionEventArgs extends Exports_js_12.SessionEventArgs {
  };
  ConnectionEventArgs.ConnectionEventArgs = ConnectionEventArgs$1;
  return ConnectionEventArgs;
}
var ServiceEventArgs = {};
var hasRequiredServiceEventArgs;
function requireServiceEventArgs() {
  if (hasRequiredServiceEventArgs) return ServiceEventArgs;
  hasRequiredServiceEventArgs = 1;
  Object.defineProperty(ServiceEventArgs, "__esModule", { value: true });
  ServiceEventArgs.ServiceEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let ServiceEventArgs$1 = class ServiceEventArgs extends Exports_js_12.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(json, name2, sessionId) {
      super(sessionId);
      this.privJsonResult = json;
      this.privEventName = name2;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  ServiceEventArgs.ServiceEventArgs = ServiceEventArgs$1;
  return ServiceEventArgs;
}
var PhraseListGrammar$1 = {};
Object.defineProperty(PhraseListGrammar$1, "__esModule", { value: true });
PhraseListGrammar$1.PhraseListGrammar = void 0;
class PhraseListGrammar {
  constructor(recogBase) {
    this.privGrammerBuilder = recogBase.dynamicGrammar;
  }
  /**
   * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
   * @param recognizer The recognizer to add phrase lists to.
   */
  static fromRecognizer(recognizer) {
    const recoBase = recognizer.internalData;
    return new PhraseListGrammar(recoBase);
  }
  /**
   * Adds a single phrase to the current recognizer.
   * @param phrase Phrase to add.
   */
  addPhrase(phrase) {
    this.privGrammerBuilder.addPhrase(phrase);
  }
  /**
   * Adds multiple phrases to the current recognizer.
   * @param phrases Array of phrases to add.
   */
  addPhrases(phrases) {
    this.privGrammerBuilder.addPhrase(phrases);
  }
  /**
   * Clears all phrases added to the current recognizer.
   */
  clear() {
    this.privGrammerBuilder.clearPhrases();
  }
}
PhraseListGrammar$1.PhraseListGrammar = PhraseListGrammar;
var DialogServiceConfig = {};
var hasRequiredDialogServiceConfig;
function requireDialogServiceConfig() {
  if (hasRequiredDialogServiceConfig) return DialogServiceConfig;
  hasRequiredDialogServiceConfig = 1;
  Object.defineProperty(DialogServiceConfig, "__esModule", { value: true });
  DialogServiceConfig.DialogServiceConfigImpl = DialogServiceConfig.DialogServiceConfig = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  let DialogServiceConfig$1 = class DialogServiceConfig {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
      return;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(value) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  DialogServiceConfig.DialogServiceConfig = DialogServiceConfig$1;
  class DialogServiceConfigImpl extends DialogServiceConfig$1 {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super();
      this.privSpeechConfig = new Exports_js_12.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "value");
      this.privSpeechConfig.speechRecognitionLanguage = value;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(value) {
      this.privSpeechConfig.outputFormat = value;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(name2, value) {
      this.privSpeechConfig.setProperty(name2, value);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(name2, def) {
      return this.privSpeechConfig.getProperty(name2);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
      this.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyHostName, proxyHostName);
      this.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyPort, `${proxyPort}`);
      if (proxyUserName) {
        this.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyUserName, proxyUserName);
      }
      if (proxyPassword) {
        this.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyPassword, proxyPassword);
      }
    }
    setServiceProperty(name2, value, channel) {
      this.privSpeechConfig.setServiceProperty(name2, value);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
      return;
    }
  }
  DialogServiceConfig.DialogServiceConfigImpl = DialogServiceConfigImpl;
  return DialogServiceConfig;
}
var BotFrameworkConfig = {};
var hasRequiredBotFrameworkConfig;
function requireBotFrameworkConfig() {
  if (hasRequiredBotFrameworkConfig) return BotFrameworkConfig;
  hasRequiredBotFrameworkConfig = 1;
  Object.defineProperty(BotFrameworkConfig, "__esModule", { value: true });
  BotFrameworkConfig.BotFrameworkConfig = void 0;
  const Contracts_js_12 = Contracts$1;
  const DialogServiceConfig_js_1 = requireDialogServiceConfig();
  const Exports_js_12 = requireExports$3();
  let BotFrameworkConfig$1 = class BotFrameworkConfig extends DialogServiceConfig_js_1.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(subscription, region, botId) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(subscription, "subscription");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Key, subscription);
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Region, region);
      if (botId) {
        botFrameworkConfig.setProperty(Exports_js_12.PropertyId.Conversation_ApplicationId, botId);
      }
      return botFrameworkConfig;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(authorizationToken, region, botId) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Region, region);
      if (botId) {
        botFrameworkConfig.setProperty(Exports_js_12.PropertyId.Conversation_ApplicationId, botId);
      }
      return botFrameworkConfig;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(host, subscriptionKey, botId) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(host, "host");
      const resolvedHost = host instanceof URL ? host : new URL(`wss://${host}.convai.speech.azure.us`);
      Contracts_js_12.Contracts.throwIfNullOrUndefined(resolvedHost, "resolvedHost");
      const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Host, resolvedHost.toString());
      if (void 0 !== subscriptionKey) {
        botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      }
      return botFrameworkConfig;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(endpoint, subscriptionKey) {
      Contracts_js_12.Contracts.throwIfNull(endpoint, "endpoint");
      const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
      botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Endpoint, endpoint.toString());
      if (void 0 !== subscriptionKey) {
        botFrameworkConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
      }
      return botFrameworkConfig;
    }
  };
  BotFrameworkConfig.BotFrameworkConfig = BotFrameworkConfig$1;
  return BotFrameworkConfig;
}
var CustomCommandsConfig = {};
var hasRequiredCustomCommandsConfig;
function requireCustomCommandsConfig() {
  if (hasRequiredCustomCommandsConfig) return CustomCommandsConfig;
  hasRequiredCustomCommandsConfig = 1;
  Object.defineProperty(CustomCommandsConfig, "__esModule", { value: true });
  CustomCommandsConfig.CustomCommandsConfig = void 0;
  const Contracts_js_12 = Contracts$1;
  const DialogServiceConfig_js_1 = requireDialogServiceConfig();
  const Exports_js_12 = requireExports$3();
  let CustomCommandsConfig$1 = class CustomCommandsConfig extends DialogServiceConfig_js_1.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(applicationId, subscription, region) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(applicationId, "applicationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(subscription, "subscription");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const customCommandsConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.CustomCommands);
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.Conversation_ApplicationId, applicationId);
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Key, subscription);
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Region, region);
      return customCommandsConfig;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(applicationId, authorizationToken, region) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(applicationId, "applicationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(region, "region");
      const customCommandsConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.CustomCommands);
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.Conversation_ApplicationId, applicationId);
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
      customCommandsConfig.setProperty(Exports_js_12.PropertyId.SpeechServiceConnection_Region, region);
      return customCommandsConfig;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "value");
      this.setProperty(Exports_js_12.PropertyId.Conversation_ApplicationId, value);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(Exports_js_12.PropertyId.Conversation_ApplicationId);
    }
  };
  CustomCommandsConfig.CustomCommandsConfig = CustomCommandsConfig$1;
  return CustomCommandsConfig;
}
var DialogServiceConnector = {};
var DialogConnectorFactory = {};
var ConnectionFactoryBase = {};
var QueryParameterNames$1 = {};
Object.defineProperty(QueryParameterNames$1, "__esModule", { value: true });
QueryParameterNames$1.QueryParameterNames = void 0;
class QueryParameterNames {
}
QueryParameterNames$1.QueryParameterNames = QueryParameterNames;
QueryParameterNames.BotId = "botid";
QueryParameterNames.CustomSpeechDeploymentId = "cid";
QueryParameterNames.CustomVoiceDeploymentId = "deploymentId";
QueryParameterNames.EnableAudioLogging = "storeAudio";
QueryParameterNames.EnableLanguageId = "lidEnabled";
QueryParameterNames.EnableWordLevelTimestamps = "wordLevelTimestamps";
QueryParameterNames.EndSilenceTimeoutMs = "endSilenceTimeoutMs";
QueryParameterNames.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs";
QueryParameterNames.Format = "format";
QueryParameterNames.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs";
QueryParameterNames.Language = "language";
QueryParameterNames.Profanity = "profanity";
QueryParameterNames.RequestBotStatusMessages = "enableBotMessageStatus";
QueryParameterNames.StableIntermediateThreshold = "stableIntermediateThreshold";
QueryParameterNames.StableTranslation = "stableTranslation";
QueryParameterNames.TestHooks = "testhooks";
QueryParameterNames.Postprocessing = "postprocessing";
QueryParameterNames.CtsMeetingId = "meetingId";
QueryParameterNames.CtsDeviceId = "deviceId";
QueryParameterNames.CtsIsParticipant = "isParticipant";
QueryParameterNames.EnableAvatar = "enableTalkingAvatar";
var hasRequiredConnectionFactoryBase;
function requireConnectionFactoryBase() {
  if (hasRequiredConnectionFactoryBase) return ConnectionFactoryBase;
  hasRequiredConnectionFactoryBase = 1;
  Object.defineProperty(ConnectionFactoryBase, "__esModule", { value: true });
  ConnectionFactoryBase.ConnectionFactoryBase = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$3();
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  let ConnectionFactoryBase$1 = class ConnectionFactoryBase {
    static getHostSuffix(region) {
      if (!!region) {
        if (region.toLowerCase().startsWith("china")) {
          return ".azure.cn";
        }
        if (region.toLowerCase().startsWith("usgov")) {
          return ".azure.us";
        }
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(config, queryParams, endpoint) {
      const propertyIdToParameterMap = /* @__PURE__ */ new Map([
        [Exports_js_2.PropertyId.Speech_SegmentationSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames_js_1.QueryParameterNames.EnableAudioLogging],
        [Exports_js_2.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.EndSilenceTimeoutMs],
        [Exports_js_2.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.InitialSilenceTimeoutMs],
        [Exports_js_2.PropertyId.SpeechServiceResponse_PostProcessingOption, QueryParameterNames_js_1.QueryParameterNames.Postprocessing],
        [Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames_js_1.QueryParameterNames.Profanity],
        [Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, QueryParameterNames_js_1.QueryParameterNames.EnableWordLevelTimestamps],
        [Exports_js_2.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames_js_1.QueryParameterNames.StableIntermediateThreshold]
      ]);
      propertyIdToParameterMap.forEach((parameterName, propertyId) => {
        this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
      });
      const serviceProperties = JSON.parse(config.parameters.getProperty(Exports_js_12.ServicePropertiesPropertyName, "{}"));
      Object.keys(serviceProperties).forEach((value) => {
        queryParams[value] = serviceProperties[value];
      });
    }
    setUrlParameter(propId, parameterName, config, queryParams, endpoint) {
      const value = config.parameters.getProperty(propId, void 0);
      if (value && (!endpoint || endpoint.search(parameterName) === -1)) {
        queryParams[parameterName] = value.toLocaleLowerCase();
      }
    }
  };
  ConnectionFactoryBase.ConnectionFactoryBase = ConnectionFactoryBase$1;
  return ConnectionFactoryBase;
}
var hasRequiredDialogConnectorFactory;
function requireDialogConnectorFactory() {
  if (hasRequiredDialogConnectorFactory) return DialogConnectorFactory;
  hasRequiredDialogConnectorFactory = 1;
  Object.defineProperty(DialogConnectorFactory, "__esModule", { value: true });
  DialogConnectorFactory.DialogConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports();
  const Exports_js_3 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_4 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  class DialogConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    create(config, authInfo, connectionId) {
      const applicationId = config.parameters.getProperty(Exports_js_3.PropertyId.Conversation_ApplicationId, "");
      const dialogType = config.parameters.getProperty(Exports_js_3.PropertyId.Conversation_DialogType);
      const region = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Region);
      const language = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US");
      const requestTurnStatus = config.parameters.getProperty(Exports_js_3.PropertyId.Conversation_Request_Bot_Status_Messages, "true");
      const queryParams = {};
      queryParams[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = config.parameters.getProperty(Exports_js_2.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]).toLowerCase();
      queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
      queryParams[QueryParameterNames_js_1.QueryParameterNames.RequestBotStatusMessages] = requestTurnStatus;
      if (applicationId) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.BotId] = applicationId;
        if (dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands) {
          queryParams[HeaderNames_js_12.HeaderNames.CustomCommandsAppId] = applicationId;
        }
      }
      const resourceInfix = dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "";
      const version2 = dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0";
      const headers = {};
      if (authInfo.token != null && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      let endpoint = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!endpoint) {
        const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
        const host = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Host, `wss://${region}.${DialogConnectionFactory.BaseUrl}${hostSuffix}`);
        const standardizedHost = host.endsWith("/") ? host : host + "/";
        endpoint = `${standardizedHost}${resourceInfix}${DialogConnectionFactory.ApiKey}/${version2}`;
      }
      this.setCommonUrlParams(config, queryParams, endpoint);
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_4.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
  }
  DialogConnectorFactory.DialogConnectionFactory = DialogConnectionFactory;
  DialogConnectionFactory.ApiKey = "api";
  DialogConnectionFactory.BaseUrl = "convai.speech";
  return DialogConnectorFactory;
}
var hasRequiredDialogServiceConnector;
function requireDialogServiceConnector() {
  if (hasRequiredDialogServiceConnector) return DialogServiceConnector;
  hasRequiredDialogServiceConnector = 1;
  Object.defineProperty(DialogServiceConnector, "__esModule", { value: true });
  DialogServiceConnector.DialogServiceConnector = void 0;
  const DialogConnectorFactory_js_1 = requireDialogConnectorFactory();
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  const PropertyId_js_1 = PropertyId;
  let DialogServiceConnector$1 = class DialogServiceConnector extends Exports_js_3.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(dialogConfig, audioConfig) {
      const dialogServiceConfigImpl = dialogConfig;
      Contracts_js_12.Contracts.throwIfNull(dialogConfig, "dialogConfig");
      super(audioConfig, dialogServiceConfigImpl.properties, new DialogConnectorFactory_js_1.DialogConnectionFactory());
      this.isTurnComplete = true;
      this.privIsDisposed = false;
      this.privProperties = dialogServiceConfigImpl.properties.clone();
      const agentConfig = this.buildAgentConfig();
      this.privReco.agentConfig.set(agentConfig);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.privReco.connect(), cb2, err2);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.privReco.disconnect(), cb2, err2);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(PropertyId_js_1.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(PropertyId_js_1.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(speechActivityTemplate) {
      this.properties.setProperty(PropertyId_js_1.PropertyId.Conversation_Speech_Activity_Template, speechActivityTemplate);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(cb2, err2) {
      if (this.isTurnComplete) {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        const callbackHolder = async () => {
          await this.privReco.connect();
          await this.implRecognizerStop();
          this.isTurnComplete = false;
          const ret = new Exports_js_2.Deferred();
          await this.privReco.recognize(Exports_js_12.RecognitionMode.Conversation, ret.resolve, ret.reject);
          const e = await ret.promise;
          await this.implRecognizerStop();
          return e;
        };
        const retPromise = callbackHolder();
        retPromise.catch(() => {
          this.dispose(true).catch(() => {
          });
        });
        Exports_js_2.marshalPromiseToCallbacks(retPromise.finally(() => {
          this.isTurnComplete = true;
        }), cb2, err2);
      }
    }
    sendActivityAsync(activity, cb2, errCb) {
      Exports_js_2.marshalPromiseToCallbacks(this.privReco.sendMessage(activity), cb2, errCb);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(cb2, err2) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, err2);
    }
    async dispose(disposing) {
      if (this.privIsDisposed) {
        return;
      }
      if (disposing) {
        this.privIsDisposed = true;
        await this.implRecognizerStop();
        await super.dispose(disposing);
      }
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const audioSource = audioConfig;
      return new Exports_js_12.DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
    }
    buildAgentConfig() {
      const communicationType = this.properties.getProperty("Conversation_Communication_Type", "Default");
      return {
        botInfo: {
          commType: communicationType,
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(PropertyId_js_1.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  DialogServiceConnector.DialogServiceConnector = DialogServiceConnector$1;
  return DialogServiceConnector;
}
var ActivityReceivedEventArgs$1 = {};
Object.defineProperty(ActivityReceivedEventArgs$1, "__esModule", { value: true });
ActivityReceivedEventArgs$1.ActivityReceivedEventArgs = void 0;
class ActivityReceivedEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {any} activity - The activity..
   */
  constructor(activity, audioStream) {
    this.privActivity = activity;
    this.privAudioStream = audioStream;
  }
  /**
   * Gets the received activity
   * @member ActivityReceivedEventArgs.prototype.activity
   * @function
   * @public
   * @returns {any} the received activity.
   */
  get activity() {
    return this.privActivity;
  }
  get audioStream() {
    return this.privAudioStream;
  }
}
ActivityReceivedEventArgs$1.ActivityReceivedEventArgs = ActivityReceivedEventArgs;
var TurnStatusReceivedEventArgs$1 = {};
var TurnStatusPayload = {};
Object.defineProperty(TurnStatusPayload, "__esModule", { value: true });
TurnStatusPayload.TurnStatusResponsePayload = void 0;
class TurnStatusResponsePayload {
  constructor(json) {
    this.privMessageStatusResponse = JSON.parse(json);
  }
  static fromJSON(json) {
    return new TurnStatusResponsePayload(json);
  }
  get interactionId() {
    return this.privMessageStatusResponse.interactionId;
  }
  get conversationId() {
    return this.privMessageStatusResponse.conversationId;
  }
  get statusCode() {
    switch (this.privMessageStatusResponse.statusCode) {
      case "Success":
        return 200;
      case "Failed":
        return 400;
      case "TimedOut":
        return 429;
      default:
        return this.privMessageStatusResponse.statusCode;
    }
  }
}
TurnStatusPayload.TurnStatusResponsePayload = TurnStatusResponsePayload;
Object.defineProperty(TurnStatusReceivedEventArgs$1, "__esModule", { value: true });
TurnStatusReceivedEventArgs$1.TurnStatusReceivedEventArgs = void 0;
const TurnStatusPayload_js_1 = TurnStatusPayload;
class TurnStatusReceivedEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} turnStatus - The JSON-encoded turn status message.
   */
  constructor(turnStatus) {
    this.privTurnStatus = TurnStatusPayload_js_1.TurnStatusResponsePayload.fromJSON(turnStatus);
  }
  /**
   * Gets the interaction identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.interactionId
   * @function
   * @public
   * @returns {any} the received interaction id.
   */
  get interactionId() {
    return this.privTurnStatus.interactionId;
  }
  /**
   * Gets the conversation identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.conversationId
   * @function
   * @public
   * @returns {any} the received conversation id.
   */
  get conversationId() {
    return this.privTurnStatus.conversationId;
  }
  /**
   * Gets the received turn status code.
   * @member TurnStatusReceivedEventArgs.prototype.statusCode
   * @function
   * @public
   * @returns {number} the received turn status.
   */
  get statusCode() {
    return this.privTurnStatus.statusCode;
  }
}
TurnStatusReceivedEventArgs$1.TurnStatusReceivedEventArgs = TurnStatusReceivedEventArgs;
var ServicePropertyChannel = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServicePropertyChannel = void 0;
  (function(ServicePropertyChannel2) {
    ServicePropertyChannel2[ServicePropertyChannel2["UriQueryParameter"] = 0] = "UriQueryParameter";
  })(exports.ServicePropertyChannel || (exports.ServicePropertyChannel = {}));
})(ServicePropertyChannel);
var ProfanityOption = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProfanityOption = void 0;
  (function(ProfanityOption2) {
    ProfanityOption2[ProfanityOption2["Masked"] = 0] = "Masked";
    ProfanityOption2[ProfanityOption2["Removed"] = 1] = "Removed";
    ProfanityOption2[ProfanityOption2["Raw"] = 2] = "Raw";
  })(exports.ProfanityOption || (exports.ProfanityOption = {}));
})(ProfanityOption);
var BaseAudioPlayer = {};
var hasRequiredBaseAudioPlayer;
function requireBaseAudioPlayer() {
  if (hasRequiredBaseAudioPlayer) return BaseAudioPlayer;
  hasRequiredBaseAudioPlayer = 1;
  Object.defineProperty(BaseAudioPlayer, "__esModule", { value: true });
  BaseAudioPlayer.BaseAudioPlayer = void 0;
  const Error_js_12 = _Error;
  const Exports_js_12 = requireExports$3();
  const AudioStreamFormat_js_12 = AudioStreamFormat;
  let BaseAudioPlayer$1 = class BaseAudioPlayer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(audioFormat) {
      this.audioContext = null;
      this.gainNode = null;
      this.autoUpdateBufferTimer = 0;
      if (audioFormat === void 0) {
        audioFormat = Exports_js_12.AudioStreamFormat.getDefaultInputFormat();
      }
      this.init(audioFormat);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(newAudioData, cb2, err2) {
      try {
        this.ensureInitializedContext();
        const audioData = this.formatAudioData(newAudioData);
        const newSamplesData = new Float32Array(this.samples.length + audioData.length);
        newSamplesData.set(this.samples, 0);
        newSamplesData.set(audioData, this.samples.length);
        this.samples = newSamplesData;
        if (!!cb2) {
          cb2();
        }
      } catch (e) {
        if (!!err2) {
          err2(e);
        }
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(cb2, err2) {
      if (this.audioContext !== null) {
        this.samples = new Float32Array();
        clearInterval(this.autoUpdateBufferTimer);
        this.audioContext.close().then(() => {
          if (!!cb2) {
            cb2();
          }
        }, (error) => {
          if (!!err2) {
            err2(error);
          }
        });
        this.audioContext = null;
      }
    }
    init(audioFormat) {
      this.audioFormat = audioFormat;
      this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const timerPeriod = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, timerPeriod);
      }
    }
    createAudioContext() {
      this.audioContext = AudioStreamFormat_js_12.AudioStreamFormatImpl.getAudioContext();
      this.gainNode = this.audioContext.createGain();
      this.gainNode.gain.value = 1;
      this.gainNode.connect(this.audioContext.destination);
      this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(audioData) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(audioData), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(audioData), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);
        default:
          throw new Error_js_12.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(audioData, maxValue) {
      const float32Data = new Float32Array(audioData.length);
      for (let i = 0; i < audioData.length; i++) {
        float32Data[i] = audioData[i] / maxValue;
      }
      return float32Data;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0) {
        return;
      }
      const channelCount = this.audioFormat.channels;
      const bufferSource = this.audioContext.createBufferSource();
      const frameCount = this.samples.length / channelCount;
      const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);
      for (let channel = 0; channel < channelCount; channel++) {
        let channelOffset = channel;
        const audioData = audioBuffer.getChannelData(channel);
        for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {
          audioData[i] = this.samples[channelOffset];
        }
      }
      if (this.startTime < this.audioContext.currentTime) {
        this.startTime = this.audioContext.currentTime;
      }
      bufferSource.buffer = audioBuffer;
      bufferSource.connect(this.gainNode);
      bufferSource.start(this.startTime);
      this.startTime += audioBuffer.duration;
      this.samples = new Float32Array();
    }
    async playAudio(audioData) {
      if (this.audioContext === null) {
        this.createAudioContext();
      }
      const source = this.audioContext.createBufferSource();
      const destination = this.audioContext.destination;
      await this.audioContext.decodeAudioData(audioData, (newBuffer) => {
        source.buffer = newBuffer;
        source.connect(destination);
        source.start(0);
      });
    }
  };
  BaseAudioPlayer.BaseAudioPlayer = BaseAudioPlayer$1;
  return BaseAudioPlayer;
}
var ConnectionMessageEventArgs$1 = {};
Object.defineProperty(ConnectionMessageEventArgs$1, "__esModule", { value: true });
ConnectionMessageEventArgs$1.ConnectionMessageEventArgs = void 0;
class ConnectionMessageEventArgs {
  constructor(message) {
    this.privConnectionMessage = message;
  }
  /**
   * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
   */
  get message() {
    return this.privConnectionMessage;
  }
  /**
   * Returns a string that represents the connection message event.
   */
  toString() {
    return "Message: " + this.privConnectionMessage.toString();
  }
}
ConnectionMessageEventArgs$1.ConnectionMessageEventArgs = ConnectionMessageEventArgs;
var VoiceProfile$1 = {};
Object.defineProperty(VoiceProfile$1, "__esModule", { value: true });
VoiceProfile$1.VoiceProfile = void 0;
class VoiceProfile {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} profileId - profileId of this Voice Profile.
   * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
   */
  constructor(profileId, profileType) {
    this.privId = profileId;
    this.privProfileType = profileType;
  }
  /**
   * profileId of this Voice Profile instance
   * @member VoiceProfile.prototype.profileId
   * @function
   * @public
   * @returns {string} profileId of this Voice Profile instance.
   */
  get profileId() {
    return this.privId;
  }
  /**
   * profileType of this Voice Profile instance
   * @member VoiceProfile.prototype.profileType
   * @function
   * @public
   * @returns {VoiceProfileType} profile type of this Voice Profile instance.
   */
  get profileType() {
    return this.privProfileType;
  }
}
VoiceProfile$1.VoiceProfile = VoiceProfile;
var VoiceProfileEnrollmentResult = {};
var hasRequiredVoiceProfileEnrollmentResult;
function requireVoiceProfileEnrollmentResult() {
  if (hasRequiredVoiceProfileEnrollmentResult) return VoiceProfileEnrollmentResult;
  hasRequiredVoiceProfileEnrollmentResult = 1;
  Object.defineProperty(VoiceProfileEnrollmentResult, "__esModule", { value: true });
  VoiceProfileEnrollmentResult.VoiceProfileEnrollmentCancellationDetails = VoiceProfileEnrollmentResult.VoiceProfileEnrollmentResult = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$3();
  let VoiceProfileEnrollmentResult$1 = class VoiceProfileEnrollmentResult2 {
    constructor(reason, json, statusText) {
      this.privReason = reason;
      this.privProperties = new Exports_js_2.PropertyCollection();
      if (this.privReason !== Exports_js_2.ResultReason.Canceled) {
        if (!!json) {
          this.privDetails = JSON.parse(json);
          if (this.privDetails.enrollmentStatus.toLowerCase() === "enrolling") {
            this.privReason = Exports_js_2.ResultReason.EnrollingVoiceProfile;
          }
        }
      } else {
        this.privErrorDetails = statusText;
        this.privProperties.setProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.ServiceError]);
      }
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(json) {
      const results = [];
      for (const item of json.value) {
        const reason = item.enrollmentStatus.toLowerCase() === "enrolling" ? Exports_js_2.ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === "enrolled" ? Exports_js_2.ResultReason.EnrolledVoiceProfile : Exports_js_2.ResultReason.Canceled;
        const result = new VoiceProfileEnrollmentResult2(reason, null, null);
        result.privDetails = this.getIdentificationDetails(item);
        results.push(result);
      }
      return results;
    }
    static FromVerificationProfileList(json) {
      const results = [];
      for (const item of json.value) {
        const reason = item.enrollmentStatus.toLowerCase() === "enrolling" ? Exports_js_2.ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === "enrolled" ? Exports_js_2.ResultReason.EnrolledVoiceProfile : Exports_js_2.ResultReason.Canceled;
        const result = new VoiceProfileEnrollmentResult2(reason, null, null);
        result.privDetails = this.getVerificationDetails(item);
        results.push(result);
      }
      return results;
    }
    static getIdentificationDetails(json) {
      return {
        audioLength: json.audioLength ? parseFloat(json.audioLength) : 0,
        audioSpeechLength: json.audioSpeechLength ? parseFloat(json.audioSpeechLength) : 0,
        enrollmentStatus: json.enrollmentStatus,
        enrollmentsCount: json.enrollmentsCount || 0,
        enrollmentsLength: json.enrollmentsLength ? parseFloat(json.enrollmentsLength) : 0,
        enrollmentsSpeechLength: json.enrollmentsSpeechLength ? parseFloat(json.enrollmentsSpeechLength) : 0,
        profileId: json.profileId || json.identificationProfileId,
        remainingEnrollmentsSpeechLength: json.remainingEnrollmentsSpeechLength ? parseFloat(json.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(json) {
      return {
        audioLength: json.audioLength ? parseFloat(json.audioLength) : 0,
        audioSpeechLength: json.audioSpeechLength ? parseFloat(json.audioSpeechLength) : 0,
        enrollmentStatus: json.enrollmentStatus,
        enrollmentsCount: json.enrollmentsCount,
        enrollmentsLength: json.enrollmentsLength ? parseFloat(json.enrollmentsLength) : 0,
        enrollmentsSpeechLength: json.enrollmentsSpeechLength ? parseFloat(json.enrollmentsSpeechLength) : 0,
        profileId: json.profileId || json.verificationProfileId,
        remainingEnrollmentsCount: json.remainingEnrollments || json.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: json.remainingEnrollmentsSpeechLength ? parseFloat(json.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  VoiceProfileEnrollmentResult.VoiceProfileEnrollmentResult = VoiceProfileEnrollmentResult$1;
  class VoiceProfileEnrollmentCancellationDetails extends Exports_js_2.CancellationDetailsBase {
    constructor(reason, errorDetails, errorCode) {
      super(reason, errorDetails, errorCode);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(result) {
      const reason = Exports_js_2.CancellationReason.Error;
      let errorCode = Exports_js_2.CancellationErrorCode.NoError;
      if (!!result.properties) {
        errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])];
      }
      return new VoiceProfileEnrollmentCancellationDetails(reason, result.errorDetails, errorCode);
    }
  }
  VoiceProfileEnrollmentResult.VoiceProfileEnrollmentCancellationDetails = VoiceProfileEnrollmentCancellationDetails;
  return VoiceProfileEnrollmentResult;
}
var VoiceProfileResult = {};
var hasRequiredVoiceProfileResult;
function requireVoiceProfileResult() {
  if (hasRequiredVoiceProfileResult) return VoiceProfileResult;
  hasRequiredVoiceProfileResult = 1;
  Object.defineProperty(VoiceProfileResult, "__esModule", { value: true });
  VoiceProfileResult.VoiceProfileCancellationDetails = VoiceProfileResult.VoiceProfileResult = void 0;
  const Exports_js_12 = requireExports();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  let VoiceProfileResult$1 = class VoiceProfileResult {
    constructor(reason, statusText) {
      this.privReason = reason;
      this.privProperties = new Exports_js_2.PropertyCollection();
      if (reason === Exports_js_2.ResultReason.Canceled) {
        Contracts_js_12.Contracts.throwIfNullOrUndefined(statusText, "statusText");
        this.privErrorDetails = statusText;
        this.privProperties.setProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.ServiceError]);
      }
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  VoiceProfileResult.VoiceProfileResult = VoiceProfileResult$1;
  class VoiceProfileCancellationDetails extends Exports_js_2.CancellationDetailsBase {
    constructor(reason, errorDetails, errorCode) {
      super(reason, errorDetails, errorCode);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(result) {
      const reason = Exports_js_2.CancellationReason.Error;
      let errorCode = Exports_js_2.CancellationErrorCode.NoError;
      if (!!result.properties) {
        errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])];
      }
      return new VoiceProfileCancellationDetails(reason, result.errorDetails, errorCode);
    }
  }
  VoiceProfileResult.VoiceProfileCancellationDetails = VoiceProfileCancellationDetails;
  return VoiceProfileResult;
}
var VoiceProfilePhraseResult = {};
var hasRequiredVoiceProfilePhraseResult;
function requireVoiceProfilePhraseResult() {
  if (hasRequiredVoiceProfilePhraseResult) return VoiceProfilePhraseResult;
  hasRequiredVoiceProfilePhraseResult = 1;
  Object.defineProperty(VoiceProfilePhraseResult, "__esModule", { value: true });
  VoiceProfilePhraseResult.VoiceProfilePhraseResult = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  let VoiceProfilePhraseResult$1 = class VoiceProfilePhraseResult extends Exports_js_12.VoiceProfileResult {
    constructor(reason, statusText, type, phraseArray) {
      super(reason, statusText);
      this.privPhrases = [];
      Contracts_js_12.Contracts.throwIfNullOrUndefined(phraseArray, "phrase array");
      this.privType = type;
      if (!!phraseArray && !!phraseArray[0]) {
        this.privPhrases = phraseArray;
      }
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  VoiceProfilePhraseResult.VoiceProfilePhraseResult = VoiceProfilePhraseResult$1;
  return VoiceProfilePhraseResult;
}
var VoiceProfileClient = {};
var hasRequiredVoiceProfileClient;
function requireVoiceProfileClient() {
  if (hasRequiredVoiceProfileClient) return VoiceProfileClient;
  hasRequiredVoiceProfileClient = 1;
  Object.defineProperty(VoiceProfileClient, "__esModule", { value: true });
  VoiceProfileClient.VoiceProfileClient = void 0;
  const Exports_js_12 = requireExports();
  const AudioConfig_js_1 = requireAudioConfig();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  let VoiceProfileClient$1 = class VoiceProfileClient extends Exports_js_2.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(speechConfig) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
      const speechConfigImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
      super(AudioConfig_js_1.AudioConfig.fromStreamInput(Exports_js_2.AudioInputStream.createPushStream()), speechConfigImpl.properties, new Exports_js_12.VoiceProfileConnectionFactory());
      this.privProperties = speechConfigImpl.properties.clone();
      this.privVoiceAdapter = this.privReco;
      this.privDisposedVoiceAdapter = false;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(profileType, lang) {
      const profileIds = await this.privVoiceAdapter.createProfile(profileType, lang);
      return new Exports_js_2.VoiceProfile(profileIds[0], profileType);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(profile) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(profile);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(profileType) {
      return this.privVoiceAdapter.getAllProfiles(profileType);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(profileType, lang) {
      return this.privVoiceAdapter.getActivationPhrases(profileType, lang);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(profile, audioConfig) {
      const configImpl = audioConfig;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(configImpl, "audioConfig");
      this.audioConfig = audioConfig;
      this.privVoiceAdapter.SpeakerAudioSource = configImpl;
      return this.privVoiceAdapter.enrollProfile(profile);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(profile) {
      return this.privVoiceAdapter.deleteProfile(profile);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(profile) {
      return this.privVoiceAdapter.resetProfile(profile);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(true);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const audioImpl = audioConfig;
      return new Exports_js_12.VoiceServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
    }
    async dispose(disposing) {
      if (this.privDisposedVoiceAdapter) {
        return;
      }
      this.privDisposedVoiceAdapter = true;
      if (disposing) {
        await super.dispose(disposing);
      }
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.properties);
    }
    getResult(result, successReason) {
      const response = new Exports_js_2.VoiceProfileResult(result.ok ? successReason : Exports_js_2.ResultReason.Canceled, result.statusText);
      return response;
    }
  };
  VoiceProfileClient.VoiceProfileClient = VoiceProfileClient$1;
  return VoiceProfileClient;
}
var SpeakerRecognizer = {};
var hasRequiredSpeakerRecognizer;
function requireSpeakerRecognizer() {
  if (hasRequiredSpeakerRecognizer) return SpeakerRecognizer;
  hasRequiredSpeakerRecognizer = 1;
  Object.defineProperty(SpeakerRecognizer, "__esModule", { value: true });
  SpeakerRecognizer.SpeakerRecognizer = void 0;
  const Exports_js_12 = requireExports();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  let SpeakerRecognizer$1 = class SpeakerRecognizer extends Exports_js_2.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(speechConfig, audioConfig) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
      const configImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(configImpl, "speechConfig");
      super(audioConfig, configImpl.properties, new Exports_js_12.SpeakerRecognitionConnectionFactory());
      this.privAudioConfigImpl = audioConfig;
      Contracts_js_12.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig");
      this.privDisposedSpeakerRecognizer = false;
      this.privProperties = configImpl.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(model) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
      return this.recognizeSpeakerOnceAsyncImpl(model);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
      await this.dispose(true);
    }
    async recognizeSpeakerOnceAsyncImpl(model) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
      await this.implRecognizerStop();
      const result = await this.privReco.recognizeSpeaker(model);
      await this.implRecognizerStop();
      return result;
    }
    async implRecognizerStop() {
      if (this.privReco) {
        await this.privReco.stopRecognizing();
      }
      return;
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const audioImpl = audioConfig;
      return new Exports_js_12.SpeakerServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
    }
    async dispose(disposing) {
      if (this.privDisposedSpeakerRecognizer) {
        return;
      }
      if (disposing) {
        this.privDisposedSpeakerRecognizer = true;
        await super.dispose(disposing);
      }
    }
  };
  SpeakerRecognizer.SpeakerRecognizer = SpeakerRecognizer$1;
  return SpeakerRecognizer;
}
var SpeakerIdentificationModel = {};
var hasRequiredSpeakerIdentificationModel;
function requireSpeakerIdentificationModel() {
  if (hasRequiredSpeakerIdentificationModel) return SpeakerIdentificationModel;
  hasRequiredSpeakerIdentificationModel = 1;
  Object.defineProperty(SpeakerIdentificationModel, "__esModule", { value: true });
  SpeakerIdentificationModel.SpeakerIdentificationModel = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  let SpeakerIdentificationModel$1 = class SpeakerIdentificationModel2 {
    constructor(profiles) {
      this.privVoiceProfiles = [];
      this.privProfileIds = [];
      Contracts_js_12.Contracts.throwIfNullOrUndefined(profiles, "VoiceProfiles");
      if (profiles.length === 0) {
        throw new Error("Empty Voice Profiles array");
      }
      for (const profile of profiles) {
        if (profile.profileType !== Exports_js_12.VoiceProfileType.TextIndependentIdentification) {
          throw new Error("Identification model can only be created from Identification profile: " + profile.profileId);
        }
        this.privVoiceProfiles.push(profile);
        this.privProfileIds.push(profile.profileId);
      }
    }
    static fromProfiles(profiles) {
      return new SpeakerIdentificationModel2(profiles);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  SpeakerIdentificationModel.SpeakerIdentificationModel = SpeakerIdentificationModel$1;
  return SpeakerIdentificationModel;
}
var SpeakerVerificationModel = {};
var hasRequiredSpeakerVerificationModel;
function requireSpeakerVerificationModel() {
  if (hasRequiredSpeakerVerificationModel) return SpeakerVerificationModel;
  hasRequiredSpeakerVerificationModel = 1;
  Object.defineProperty(SpeakerVerificationModel, "__esModule", { value: true });
  SpeakerVerificationModel.SpeakerVerificationModel = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  let SpeakerVerificationModel$1 = class SpeakerVerificationModel2 {
    constructor(profile) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(profile, "VoiceProfile");
      if (profile.profileType === Exports_js_12.VoiceProfileType.TextIndependentIdentification) {
        throw new Error("Verification model cannot be created from Identification profile");
      }
      this.privVoiceProfile = profile;
    }
    static fromProfile(profile) {
      return new SpeakerVerificationModel2(profile);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      if (this.voiceProfile.profileType === Exports_js_12.VoiceProfileType.TextDependentVerification) {
        return "TextDependentVerification";
      } else {
        return "TextIndependentVerification";
      }
    }
  };
  SpeakerVerificationModel.SpeakerVerificationModel = SpeakerVerificationModel$1;
  return SpeakerVerificationModel;
}
var AutoDetectSourceLanguageConfig = {};
var LanguageIdMode = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LanguageIdMode = void 0;
  (function(LanguageIdMode2) {
    LanguageIdMode2[LanguageIdMode2["AtStart"] = 0] = "AtStart";
    LanguageIdMode2[LanguageIdMode2["Continuous"] = 1] = "Continuous";
  })(exports.LanguageIdMode || (exports.LanguageIdMode = {}));
})(LanguageIdMode);
var hasRequiredAutoDetectSourceLanguageConfig;
function requireAutoDetectSourceLanguageConfig() {
  if (hasRequiredAutoDetectSourceLanguageConfig) return AutoDetectSourceLanguageConfig;
  hasRequiredAutoDetectSourceLanguageConfig = 1;
  Object.defineProperty(AutoDetectSourceLanguageConfig, "__esModule", { value: true });
  AutoDetectSourceLanguageConfig.AutoDetectSourceLanguageConfig = void 0;
  const Exports_js_12 = requireExports();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  const LanguageIdMode_js_1 = LanguageIdMode;
  let AutoDetectSourceLanguageConfig$1 = class AutoDetectSourceLanguageConfig2 {
    constructor() {
      this.privProperties = new Exports_js_2.PropertyCollection();
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart");
      this.privLanguageIdMode = LanguageIdMode_js_1.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const config = new AutoDetectSourceLanguageConfig2();
      config.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, Exports_js_12.AutoDetectSourceLanguagesOpenRangeOptionName);
      return config;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(languages) {
      Contracts_js_12.Contracts.throwIfArrayEmptyOrWhitespace(languages, "languages");
      const config = new AutoDetectSourceLanguageConfig2();
      config.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());
      return config;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(configs) {
      if (configs.length < 1) {
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      }
      const autoConfig = new AutoDetectSourceLanguageConfig2();
      const langs = [];
      configs.forEach((config) => {
        langs.push(config.language);
        if (config.endpointId !== void 0 && config.endpointId !== "") {
          const customProperty = config.language + Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId.toString();
          autoConfig.properties.setProperty(customProperty, config.endpointId);
        }
      });
      autoConfig.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());
      return autoConfig;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(mode) {
      if (mode === LanguageIdMode_js_1.LanguageIdMode.Continuous) {
        this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
        this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous");
      } else {
        this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1");
        this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart");
      }
      this.privLanguageIdMode = mode;
    }
  };
  AutoDetectSourceLanguageConfig.AutoDetectSourceLanguageConfig = AutoDetectSourceLanguageConfig$1;
  return AutoDetectSourceLanguageConfig;
}
var AutoDetectSourceLanguageResult$1 = {};
Object.defineProperty(AutoDetectSourceLanguageResult$1, "__esModule", { value: true });
AutoDetectSourceLanguageResult$1.AutoDetectSourceLanguageResult = void 0;
const Contracts_js_1$2 = Contracts$1;
class AutoDetectSourceLanguageResult {
  constructor(language, languageDetectionConfidence) {
    Contracts_js_1$2.Contracts.throwIfNullOrUndefined(language, "language");
    Contracts_js_1$2.Contracts.throwIfNullOrUndefined(languageDetectionConfidence, "languageDetectionConfidence");
    this.privLanguage = language;
    this.privLanguageDetectionConfidence = languageDetectionConfidence;
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
   * @member AutoDetectSourceLanguageResult.fromResult
   * @function
   * @public
   * @param {SpeechRecognitionResult} result - The recognition result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromResult(result) {
    return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
   * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
   * @function
   * @public
   * @param {ConversationTranscriptionResult} result - The transcription result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromConversationTranscriptionResult(result) {
    return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);
  }
  get language() {
    return this.privLanguage;
  }
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
}
AutoDetectSourceLanguageResult$1.AutoDetectSourceLanguageResult = AutoDetectSourceLanguageResult;
var SourceLanguageConfig$1 = {};
Object.defineProperty(SourceLanguageConfig$1, "__esModule", { value: true });
SourceLanguageConfig$1.SourceLanguageConfig = void 0;
const Contracts_js_1$1 = Contracts$1;
class SourceLanguageConfig {
  constructor(language, endpointId) {
    Contracts_js_1$1.Contracts.throwIfNullOrUndefined(language, "language");
    this.privLanguage = language;
    this.privEndpointId = endpointId;
  }
  /**
   * @member SourceLanguageConfig.fromLanguage
   * @function
   * @public
   * @param {string} language language (eg. "en-US") value of config.
   * @param {string?} endpointId endpointId of model bound to given language of config.
   * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
   * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
   * Added in version 1.13.0.
   */
  static fromLanguage(language, endpointId) {
    return new SourceLanguageConfig(language, endpointId);
  }
  get language() {
    return this.privLanguage;
  }
  get endpointId() {
    return this.privEndpointId;
  }
}
SourceLanguageConfig$1.SourceLanguageConfig = SourceLanguageConfig;
var SpeakerRecognitionResult = {};
var hasRequiredSpeakerRecognitionResult;
function requireSpeakerRecognitionResult() {
  if (hasRequiredSpeakerRecognitionResult) return SpeakerRecognitionResult;
  hasRequiredSpeakerRecognitionResult = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpeakerRecognitionCancellationDetails = exports.SpeakerRecognitionResult = exports.SpeakerRecognitionResultType = void 0;
    const Exports_js_12 = requireExports();
    const Exports_js_2 = requireExports$3();
    var SpeakerRecognitionResultType;
    (function(SpeakerRecognitionResultType2) {
      SpeakerRecognitionResultType2[SpeakerRecognitionResultType2["Verify"] = 0] = "Verify";
      SpeakerRecognitionResultType2[SpeakerRecognitionResultType2["Identify"] = 1] = "Identify";
    })(SpeakerRecognitionResultType = exports.SpeakerRecognitionResultType || (exports.SpeakerRecognitionResultType = {}));
    class SpeakerRecognitionResult2 {
      constructor(response, resultReason = Exports_js_2.ResultReason.RecognizedSpeaker, cancellationErrorCode = Exports_js_2.CancellationErrorCode.NoError, errorDetails = "") {
        this.privProperties = new Exports_js_2.PropertyCollection();
        const resultType = response.scenario === "TextIndependentIdentification" ? SpeakerRecognitionResultType.Identify : SpeakerRecognitionResultType.Verify;
        this.privReason = resultReason;
        if (this.privReason !== Exports_js_2.ResultReason.Canceled) {
          if (resultType === SpeakerRecognitionResultType.Identify) {
            this.privProfileId = response.identificationResult.identifiedProfile.profileId;
            this.privScore = response.identificationResult.identifiedProfile.score;
            this.privReason = Exports_js_2.ResultReason.RecognizedSpeakers;
          } else {
            this.privScore = response.verificationResult.score;
            if (response.verificationResult.recognitionResult.toLowerCase() !== "accept") {
              this.privReason = Exports_js_2.ResultReason.NoMatch;
            }
            if (response.verificationResult.profileId !== void 0 && response.verificationResult.profileId !== "") {
              this.privProfileId = response.verificationResult.profileId;
            }
          }
        } else {
          this.privErrorDetails = errorDetails;
          this.privProperties.setProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[cancellationErrorCode]);
        }
        this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(response));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    exports.SpeakerRecognitionResult = SpeakerRecognitionResult2;
    class SpeakerRecognitionCancellationDetails extends Exports_js_2.CancellationDetailsBase {
      constructor(reason, errorDetails, errorCode) {
        super(reason, errorDetails, errorCode);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(result) {
        const reason = Exports_js_2.CancellationReason.Error;
        let errorCode = Exports_js_2.CancellationErrorCode.NoError;
        if (!!result.properties) {
          errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_12.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])];
        }
        return new SpeakerRecognitionCancellationDetails(reason, result.errorDetails, errorCode);
      }
    }
    exports.SpeakerRecognitionCancellationDetails = SpeakerRecognitionCancellationDetails;
  })(SpeakerRecognitionResult);
  return SpeakerRecognitionResult;
}
var Exports$2 = {};
var Conversation = {};
var hasRequiredConversation;
function requireConversation() {
  if (hasRequiredConversation) return Conversation;
  hasRequiredConversation = 1;
  Object.defineProperty(Conversation, "__esModule", { value: true });
  Conversation.ConversationImpl = Conversation.Conversation = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let Conversation$1 = class Conversation {
    constructor() {
      return;
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(speechConfig, arg2, arg3, arg4) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig, Exports_js_12.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config"));
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_js_12.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region"));
      if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceAuthorization_Token])) {
        Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_js_12.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      }
      let conversationImpl;
      let cb2;
      let err2;
      if (typeof arg2 === "string") {
        conversationImpl = new ConversationImpl(speechConfig, arg2);
        Exports_js_2.marshalPromiseToCallbacks((async () => {
        })(), arg3, arg4);
      } else {
        conversationImpl = new ConversationImpl(speechConfig);
        cb2 = arg2;
        err2 = arg3;
        conversationImpl.createConversationAsync(() => {
          if (!!cb2) {
            cb2();
          }
        }, (error) => {
          if (!!err2) {
            err2(error);
          }
        });
      }
      return conversationImpl;
    }
  };
  Conversation.Conversation = Conversation$1;
  class ConversationImpl extends Conversation$1 {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(speechConfig, id2) {
      super();
      this.privErrors = Exports_js_12.ConversationConnectionConfig.restErrors;
      this.onConnected = (e) => {
        var _a2;
        this.privIsConnected = true;
        try {
          if (!!((_a2 = this.privConversationTranslator) == null ? void 0 : _a2.sessionStarted)) {
            this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);
          }
        } catch (e2) {
        }
      };
      this.onDisconnected = (e) => {
        var _a2;
        try {
          if (!!((_a2 = this.privConversationTranslator) == null ? void 0 : _a2.sessionStopped)) {
            this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);
          }
        } catch (e2) {
        } finally {
          void this.close(false);
        }
      };
      this.onCanceled = (r2, e) => {
        var _a2;
        try {
          if (!!((_a2 = this.privConversationTranslator) == null ? void 0 : _a2.canceled)) {
            this.privConversationTranslator.canceled(this.privConversationTranslator, e);
          }
        } catch (e2) {
        }
      };
      this.onParticipantUpdateCommandReceived = (r2, e) => {
        try {
          const updatedParticipant = this.privParticipants.getParticipant(e.id);
          if (updatedParticipant !== void 0) {
            switch (e.key) {
              case Exports_js_12.ConversationTranslatorCommandTypes.changeNickname:
                updatedParticipant.displayName = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setUseTTS:
                updatedParticipant.isUsingTts = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setProfanityFiltering:
                updatedParticipant.profanity = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setMute:
                updatedParticipant.isMuted = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                updatedParticipant.translateToLanguages = e.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(updatedParticipant);
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));
            }
          }
        } catch (e2) {
        }
      };
      this.onLockRoomCommandReceived = () => {
      };
      this.onMuteAllCommandReceived = (r2, e) => {
        try {
          this.privParticipants.participants.forEach((p2) => p2.isMuted = p2.isHost ? false : e.isMuted);
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));
          }
        } catch (e2) {
        }
      };
      this.onParticipantJoinCommandReceived = (r2, e) => {
        try {
          const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);
          if (newParticipant !== void 0) {
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));
            }
          }
        } catch (e2) {
        }
      };
      this.onParticipantLeaveCommandReceived = (r2, e) => {
        try {
          const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);
          if (ejectedParticipant !== void 0) {
            this.privParticipants.deleteParticipant(e.participant.id);
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));
            }
          }
        } catch (e2) {
        }
      };
      this.onTranslationReceived = (r2, e) => {
        try {
          switch (e.command) {
            case Exports_js_12.ConversationTranslatorMessageTypes.final:
              if (!!this.privConversationTranslator) {
                this.privConversationTranslator.transcribed(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, void 0, e.sessionId));
              }
              break;
            case Exports_js_12.ConversationTranslatorMessageTypes.partial:
              if (!!this.privConversationTranslator) {
                this.privConversationTranslator.transcribing(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, void 0, e.sessionId));
              }
              break;
            case Exports_js_12.ConversationTranslatorMessageTypes.instantMessage:
              if (!!this.privConversationTranslator) {
                this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, void 0, e.sessionId));
              }
              break;
          }
        } catch (e2) {
        }
      };
      this.onParticipantsListReceived = (r2, e) => {
        var _a2;
        try {
          if (e.sessionToken !== void 0 && e.sessionToken !== null) {
            this.privRoom.token = e.sessionToken;
          }
          this.privParticipants.participants = [...e.participants];
          if (this.privParticipants.me !== void 0) {
            this.privIsReady = true;
          }
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));
          }
          if (this.me.isHost) {
            const nickname = (_a2 = this.privConversationTranslator) == null ? void 0 : _a2.properties.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Name);
            if (nickname !== void 0 && nickname.length > 0 && nickname !== this.me.displayName) {
              this.changeNicknameAsync(nickname);
            }
          }
        } catch (e2) {
        }
      };
      this.onConversationExpiration = (r2, e) => {
        try {
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);
          }
        } catch (e2) {
        }
      };
      this.privIsConnected = false;
      this.privIsDisposed = false;
      this.privConversationId = "";
      this.privProperties = new Exports_js_3.PropertyCollection();
      this.privManager = new Exports_js_12.ConversationManager();
      const language = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
      if (!language) {
        speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_js_12.ConversationConnectionConfig.defaultLanguageCode);
      }
      this.privLanguage = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
      if (!id2) {
        if (speechConfig.targetLanguages.length === 0) {
          speechConfig.addTargetLanguage(this.privLanguage);
        }
        const profanity = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceResponse_ProfanityOption]);
        if (!profanity) {
          speechConfig.setProfanity(Exports_js_3.ProfanityOption.Masked);
        }
        let hostNickname = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name]);
        if (hostNickname === void 0 || hostNickname === null) {
          hostNickname = "Host";
        }
        Contracts_js_12.Contracts.throwIfNullOrTooLong(hostNickname, "nickname", 50);
        Contracts_js_12.Contracts.throwIfNullOrTooShort(hostNickname, "nickname", 2);
        speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name], hostNickname);
      } else {
        this.privConversationId = id2;
      }
      this.privConfig = speechConfig;
      const configImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(configImpl, "speechConfig");
      this.privProperties = configImpl.properties.clone();
      this.privIsConnected = false;
      this.privParticipants = new Exports_js_12.InternalParticipants();
      this.privIsReady = false;
      this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      var _a2, _b2;
      return ((_a2 = this.privParticipants.me) == null ? void 0 : _a2.isHost) ? false : (_b2 = this.privParticipants.me) == null ? void 0 : _b2.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(true);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const convId = this.conversationId;
      const p2 = this.participants.map((part) => ({
        id: part.id,
        preferredLanguage: part.preferredLanguage,
        voice: part.voice
      }));
      const props = {};
      for (const key of Exports_js_12.ConversationConnectionConfig.transcriptionEventKeys) {
        const val = this.properties.getProperty(key, "");
        if (val !== "") {
          props[key] = val;
        }
      }
      const info = { id: convId, participants: p2, conversationProperties: props };
      return info;
    }
    get canSend() {
      var _a2;
      return this.privIsConnected && !((_a2 = this.privParticipants.me) == null ? void 0 : _a2.isMuted);
    }
    get canSendAsHost() {
      var _a2;
      return this.privIsConnected && ((_a2 = this.privParticipants.me) == null ? void 0 : _a2.isHost);
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "authorizationToken");
      this.privToken = value;
    }
    set conversationTranslator(conversationTranslator) {
      this.privConversationTranslator = conversationTranslator;
    }
    onToken(token) {
      this.privConversationTranslator.onToken(token);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(cb2, err2) {
      try {
        if (!!this.privConversationRecognizer) {
          this.handleError(new Error(this.privErrors.permissionDeniedStart), err2);
        }
        this.privManager.createOrJoin(this.privProperties, void 0, (room) => {
          if (!room) {
            this.handleError(new Error(this.privErrors.permissionDeniedConnect), err2);
          }
          this.privRoom = room;
          this.handleCallback(cb2, err2);
        }, (error) => {
          this.handleError(error, err2);
        });
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(cb2, err2) {
      try {
        if (!!this.privConversationRecognizer) {
          this.handleError(new Error(this.privErrors.permissionDeniedStart), err2);
        }
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);
        this.privParticipants.meId = this.privRoom.participantId;
        this.privConversationRecognizer = Exports_js_12.ConversationRecognizerFactory.fromConfig(this, this.privConfig);
        this.privConversationRecognizer.connected = this.onConnected;
        this.privConversationRecognizer.disconnected = this.onDisconnected;
        this.privConversationRecognizer.canceled = this.onCanceled;
        this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;
        this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;
        this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;
        this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;
        this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;
        this.privConversationRecognizer.translationReceived = this.onTranslationReceived;
        this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;
        this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;
        this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(cb2, err2);
        }, (error) => {
          this.handleError(error, err2);
        });
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(participant, cb2, err2) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(participant, "Participant");
      Exports_js_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb2, err2);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(conversationId, nickname, lang, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace("{arg}", "conversationId"));
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace("{arg}", "language"));
        this.privManager.createOrJoin(this.privProperties, conversationId, (room) => {
          Contracts_js_12.Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);
          this.privRoom = room;
          this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;
          if (!!cb2) {
            cb2(room.cognitiveSpeechAuthToken);
          }
        }, (error) => {
          this.handleError(error, err2);
        });
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb2, err2);
    }
    async deleteConversationImplAsync() {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);
      await this.privManager.leave(this.privProperties, this.privRoom.token);
      this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.endConversationImplAsync(), cb2, err2);
    }
    endConversationImplAsync() {
      return this.close(true);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getLockCommand(true), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(userId, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!this.me.isHost && this.me.id !== userId) {
          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err2);
        }
        const exists = this.privParticipants.getParticipantIndex(userId);
        if (exists === -1) {
          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(userId, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        if (!!this.privTranscriberRecognizer && userId.hasOwnProperty("id")) {
          Exports_js_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb2, err2);
        } else {
          Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
          Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
          if (!this.canSendAsHost) {
            this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), err2);
          }
          let participantId = "";
          if (typeof userId === "string") {
            participantId = userId;
          } else if (userId.hasOwnProperty("id")) {
            const participant = userId;
            participantId = participant.id;
          } else if (userId.hasOwnProperty("userId")) {
            const user = userId;
            participantId = user.userId;
          }
          Contracts_js_12.Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
          const index2 = this.participants.findIndex((p2) => p2.id === participantId);
          if (index2 === -1) {
            this.handleError(new Error(this.privErrors.invalidParticipantRequest), err2);
          }
          if (!!this.privConversationRecognizer) {
            this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), () => {
              this.handleCallback(cb2, err2);
            }, (error) => {
              this.handleError(error, err2);
            });
          }
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getLockCommand(false), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(userId, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!this.me.isHost && this.me.id !== userId) {
          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err2);
        }
        const exists = this.privParticipants.getParticipantIndex(userId);
        if (exists === -1) {
          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(message, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", "message"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (message.length > this.privTextMessageMaxLength) {
          this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(languages, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace("{arg}", "languages"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(nickname, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this.privIsDisposed = true;
      if (!!this.config) {
        this.config.close();
      }
      this.privConfig = void 0;
      this.privLanguage = void 0;
      this.privProperties = void 0;
      this.privRoom = void 0;
      this.privToken = void 0;
      this.privManager = void 0;
      this.privIsConnected = false;
      this.privIsReady = false;
      this.privParticipants = void 0;
    }
    async connectTranscriberRecognizer(recognizer) {
      if (!!this.privTranscriberRecognizer) {
        await this.privTranscriberRecognizer.close();
      }
      await recognizer.enforceAudioGating();
      this.privTranscriberRecognizer = recognizer;
      this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const nickname = !!this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(participant) {
      const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);
      if (newParticipant !== void 0) {
        if (!!this.privTranscriberRecognizer) {
          const conversationInfo = this.conversationInfo;
          conversationInfo.participants = [participant];
          return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, "join");
        }
      }
    }
    removeParticipantImplAsync(participant) {
      this.privParticipants.deleteParticipant(participant.id);
      const conversationInfo = this.conversationInfo;
      conversationInfo.participants = [participant];
      return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, "leave");
    }
    async close(dispose) {
      var _a2;
      try {
        this.privIsConnected = false;
        await ((_a2 = this.privConversationRecognizer) == null ? void 0 : _a2.close());
        this.privConversationRecognizer = void 0;
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.dispose();
        }
      } catch (e) {
        throw e;
      }
      if (dispose) {
        this.dispose();
      }
    }
    /** Helpers */
    handleCallback(cb2, err2) {
      if (!!cb2) {
        try {
          cb2();
        } catch (e) {
          if (!!err2) {
            err2(e);
          }
        }
        cb2 = void 0;
      }
    }
    handleError(error, err2) {
      if (!!err2) {
        if (error instanceof Error) {
          const typedError = error;
          err2(typedError.name + ": " + typedError.message);
        } else {
          err2(error);
        }
      }
    }
    /** Participant Helpers */
    toParticipants(includeHost) {
      const participants = this.privParticipants.participants.map((p2) => this.toParticipant(p2));
      if (!includeHost) {
        return participants.filter((p2) => p2.isHost === false);
      } else {
        return participants;
      }
    }
    toParticipant(p2) {
      return new Exports_js_3.Participant(p2.id, p2.avatar, p2.displayName, p2.isHost, p2.isMuted, p2.isUsingTts, p2.preferredLanguage, p2.voice);
    }
    getMuteAllCommand(isMuted) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: isMuted
      });
    }
    getMuteCommand(participantId, isMuted) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: isMuted
      });
    }
    getLockCommand(isLocked) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: isLocked
      });
    }
    getEjectCommand(participantId) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(languages) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: languages
      });
    }
    getChangeNicknameCommand(nickname) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.changeNickname,
        nickname,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: nickname
      });
    }
    getMessageCommand(message) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(message, "message");
      return JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: message,
        type: Exports_js_12.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  Conversation.ConversationImpl = ConversationImpl;
  return Conversation;
}
var ConversationCommon$1 = {};
Object.defineProperty(ConversationCommon$1, "__esModule", { value: true });
ConversationCommon$1.ConversationCommon = void 0;
class ConversationCommon {
  constructor(audioConfig) {
    this.privAudioConfig = audioConfig;
  }
  handleCallback(cb2, err2) {
    if (!!cb2) {
      try {
        cb2();
      } catch (e) {
        if (!!err2) {
          err2(e);
        }
      }
      cb2 = void 0;
    }
  }
  handleError(error, err2) {
    if (!!err2) {
      if (error instanceof Error) {
        const typedError = error;
        err2(typedError.name + ": " + typedError.message);
      } else {
        err2(error);
      }
    }
  }
}
ConversationCommon$1.ConversationCommon = ConversationCommon;
var ConversationExpirationEventArgs = {};
var hasRequiredConversationExpirationEventArgs;
function requireConversationExpirationEventArgs() {
  if (hasRequiredConversationExpirationEventArgs) return ConversationExpirationEventArgs;
  hasRequiredConversationExpirationEventArgs = 1;
  Object.defineProperty(ConversationExpirationEventArgs, "__esModule", { value: true });
  ConversationExpirationEventArgs.ConversationExpirationEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let ConversationExpirationEventArgs$1 = class ConversationExpirationEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(expirationTime, sessionId) {
      super(sessionId);
      this.privExpirationTime = expirationTime;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  ConversationExpirationEventArgs.ConversationExpirationEventArgs = ConversationExpirationEventArgs$1;
  return ConversationExpirationEventArgs;
}
var ConversationParticipantsChangedEventArgs = {};
var hasRequiredConversationParticipantsChangedEventArgs;
function requireConversationParticipantsChangedEventArgs() {
  if (hasRequiredConversationParticipantsChangedEventArgs) return ConversationParticipantsChangedEventArgs;
  hasRequiredConversationParticipantsChangedEventArgs = 1;
  Object.defineProperty(ConversationParticipantsChangedEventArgs, "__esModule", { value: true });
  ConversationParticipantsChangedEventArgs.ConversationParticipantsChangedEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let ConversationParticipantsChangedEventArgs$1 = class ConversationParticipantsChangedEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(reason, participants, sessionId) {
      super(sessionId);
      this.privReason = reason;
      this.privParticipant = participants;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  ConversationParticipantsChangedEventArgs.ConversationParticipantsChangedEventArgs = ConversationParticipantsChangedEventArgs$1;
  return ConversationParticipantsChangedEventArgs;
}
var ConversationTranslationCanceledEventArgs = {};
var hasRequiredConversationTranslationCanceledEventArgs;
function requireConversationTranslationCanceledEventArgs() {
  if (hasRequiredConversationTranslationCanceledEventArgs) return ConversationTranslationCanceledEventArgs;
  hasRequiredConversationTranslationCanceledEventArgs = 1;
  Object.defineProperty(ConversationTranslationCanceledEventArgs, "__esModule", { value: true });
  ConversationTranslationCanceledEventArgs.ConversationTranslationCanceledEventArgs = void 0;
  const CancellationEventArgsBase_js_1 = requireCancellationEventArgsBase();
  let ConversationTranslationCanceledEventArgs$1 = class ConversationTranslationCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {
  };
  ConversationTranslationCanceledEventArgs.ConversationTranslationCanceledEventArgs = ConversationTranslationCanceledEventArgs$1;
  return ConversationTranslationCanceledEventArgs;
}
var ConversationTranslationEventArgs = {};
var hasRequiredConversationTranslationEventArgs;
function requireConversationTranslationEventArgs() {
  if (hasRequiredConversationTranslationEventArgs) return ConversationTranslationEventArgs;
  hasRequiredConversationTranslationEventArgs = 1;
  Object.defineProperty(ConversationTranslationEventArgs, "__esModule", { value: true });
  ConversationTranslationEventArgs.ConversationTranslationEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  let ConversationTranslationEventArgs$1 = class ConversationTranslationEventArgs extends Exports_js_12.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(result, offset, sessionId) {
      super(offset, sessionId);
      this.privResult = result;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  ConversationTranslationEventArgs.ConversationTranslationEventArgs = ConversationTranslationEventArgs$1;
  return ConversationTranslationEventArgs;
}
var ConversationTranslationResult = {};
var hasRequiredConversationTranslationResult;
function requireConversationTranslationResult() {
  if (hasRequiredConversationTranslationResult) return ConversationTranslationResult;
  hasRequiredConversationTranslationResult = 1;
  Object.defineProperty(ConversationTranslationResult, "__esModule", { value: true });
  ConversationTranslationResult.ConversationTranslationResult = void 0;
  const TranslationRecognitionResult_js_1 = requireTranslationRecognitionResult();
  let ConversationTranslationResult$1 = class ConversationTranslationResult extends TranslationRecognitionResult_js_1.TranslationRecognitionResult {
    constructor(participantId, translations, originalLanguage, resultId, reason, text2, duration, offset, errorDetails, json, properties) {
      super(translations, resultId, reason, text2, duration, offset, void 0, void 0, errorDetails, json, properties);
      this.privId = participantId;
      this.privOrigLang = originalLanguage;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  ConversationTranslationResult.ConversationTranslationResult = ConversationTranslationResult$1;
  return ConversationTranslationResult;
}
var ConversationTranslator = {};
var ConversationTranslatorConnectionFactory = {};
var StringUtils$1 = {};
Object.defineProperty(StringUtils$1, "__esModule", { value: true });
StringUtils$1.StringUtils = void 0;
class StringUtils {
  /**
   * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
   * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
   * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
   * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
   * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
   */
  static formatString(format, replacements) {
    if (!format) {
      return "";
    }
    if (!replacements) {
      return format;
    }
    let formatted = "";
    let key = "";
    const appendToFormatted = (str) => {
      formatted += str;
    };
    const appendToKey = (str) => {
      key += str;
    };
    let appendFunc = appendToFormatted;
    for (let i = 0; i < format.length; i++) {
      const c = format[i];
      const next = i + 1 < format.length ? format[i + 1] : "";
      switch (c) {
        case "{":
          if (next === "{") {
            appendFunc("{");
            i++;
          } else {
            appendFunc = appendToKey;
          }
          break;
        case "}":
          if (next === "}") {
            appendFunc("}");
            i++;
          } else {
            if (replacements.hasOwnProperty(key)) {
              formatted += replacements[key];
            }
            appendFunc = appendToFormatted;
            key = "";
          }
          break;
        default:
          appendFunc(c);
          break;
      }
    }
    return formatted;
  }
}
StringUtils$1.StringUtils = StringUtils;
var hasRequiredConversationTranslatorConnectionFactory;
function requireConversationTranslatorConnectionFactory() {
  if (hasRequiredConversationTranslatorConnectionFactory) return ConversationTranslatorConnectionFactory;
  hasRequiredConversationTranslatorConnectionFactory = 1;
  Object.defineProperty(ConversationTranslatorConnectionFactory, "__esModule", { value: true });
  ConversationTranslatorConnectionFactory.ConversationTranslatorConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const StringUtils_js_1 = StringUtils$1;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_3 = requireExports();
  let ConversationTranslatorConnectionFactory$1 = class ConversationTranslatorConnectionFactory2 extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    constructor(convGetter) {
      super();
      Contracts_js_12.Contracts.throwIfNullOrUndefined(convGetter, "convGetter");
      this.privConvGetter = convGetter;
    }
    create(config, authInfo, connectionId) {
      const isVirtMicArrayEndpoint = config.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE";
      const convInfo = this.privConvGetter().room;
      const region = convInfo.cognitiveSpeechRegion || config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, "");
      const replacementValues = {
        hostSuffix: ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region),
        path: ConversationTranslatorConnectionFactory2.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(region)
      };
      replacementValues[QueryParameterNames_js_1.QueryParameterNames.Language] = encodeURIComponent(config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, ""));
      replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsMeetingId] = encodeURIComponent(convInfo.roomId);
      replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsDeviceId] = encodeURIComponent(convInfo.participantId);
      replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsIsParticipant] = convInfo.isHost ? "" : "&" + QueryParameterNames_js_1.QueryParameterNames.CtsIsParticipant;
      let endpointUrl = "";
      const queryParams = {};
      const headers = {};
      if (isVirtMicArrayEndpoint) {
        endpointUrl = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint);
        if (!endpointUrl) {
          const hostName = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}");
          endpointUrl = "wss://" + hostName + "{path}";
        }
        endpointUrl = StringUtils_js_1.StringUtils.formatString(endpointUrl, replacementValues);
        const parsedUrl = new URL(endpointUrl);
        parsedUrl.searchParams.forEach((val, key) => {
          queryParams[key] = val;
        });
        const connFactory = new Exports_js_3.TranscriberConnectionFactory();
        connFactory.setQueryParams(queryParams, config, endpointUrl);
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CtsMeetingId] = replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsMeetingId];
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CtsDeviceId] = replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsDeviceId];
        if (!convInfo.isHost) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.CtsIsParticipant] = "";
        }
        if (!(QueryParameterNames_js_1.QueryParameterNames.Format in queryParams)) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = "simple";
        }
        parsedUrl.searchParams.forEach((val, key) => {
          parsedUrl.searchParams.set(key, queryParams[key]);
          delete queryParams[key];
        });
        endpointUrl = parsedUrl.toString();
      } else {
        const connFactory = new Exports_js_3.TranslationConnectionFactory();
        endpointUrl = connFactory.getEndpointUrl(config, true);
        endpointUrl = StringUtils_js_1.StringUtils.formatString(endpointUrl, replacementValues);
        connFactory.setQueryParams(queryParams, config, endpointUrl);
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      headers[Exports_js_12.RestConfigBase.configParams.token] = convInfo.token;
      if (!!authInfo.token) {
        headers[authInfo.headerName] = authInfo.token;
      }
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return new Exports_js_12.WebsocketConnection(endpointUrl, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
  };
  ConversationTranslatorConnectionFactory.ConversationTranslatorConnectionFactory = ConversationTranslatorConnectionFactory$1;
  ConversationTranslatorConnectionFactory$1.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio";
  return ConversationTranslatorConnectionFactory;
}
var hasRequiredConversationTranslator;
function requireConversationTranslator() {
  if (hasRequiredConversationTranslator) return ConversationTranslator;
  hasRequiredConversationTranslator = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConversationTranslator = exports.SpeechState = void 0;
    const Exports_js_12 = requireExports();
    const ConversationTranslatorConnectionFactory_js_1 = requireConversationTranslatorConnectionFactory();
    const Exports_js_2 = requireExports$5();
    const Contracts_js_12 = Contracts$1;
    const Exports_js_3 = requireExports$3();
    const Conversation_js_1 = requireConversation();
    const Exports_js_4 = requireExports$4();
    var SpeechState;
    (function(SpeechState2) {
      SpeechState2[SpeechState2["Inactive"] = 0] = "Inactive";
      SpeechState2[SpeechState2["Connecting"] = 1] = "Connecting";
      SpeechState2[SpeechState2["Connected"] = 2] = "Connected";
    })(SpeechState = exports.SpeechState || (exports.SpeechState = {}));
    class ConversationTranslationRecognizer extends Exports_js_3.TranslationRecognizer {
      constructor(speechConfig, audioConfig, translator, convGetter) {
        super(speechConfig, audioConfig, new ConversationTranslatorConnectionFactory_js_1.ConversationTranslatorConnectionFactory(convGetter));
        this.privSpeechState = SpeechState.Inactive;
        if (!!translator) {
          this.privTranslator = translator;
          this.sessionStarted = () => {
            this.privSpeechState = SpeechState.Connected;
          };
          this.sessionStopped = () => {
            this.privSpeechState = SpeechState.Inactive;
          };
          this.recognizing = (tr, e) => {
            if (!!this.privTranslator.recognizing) {
              this.privTranslator.recognizing(this.privTranslator, e);
            }
          };
          this.recognized = async (tr, e) => {
            var _a2;
            if ((_a2 = e.result) == null ? void 0 : _a2.errorDetails) {
              await this.cancelSpeech();
              this.fireCancelEvent(e.result.errorDetails);
            } else {
              if (!!this.privTranslator.recognized) {
                this.privTranslator.recognized(this.privTranslator, e);
              }
            }
            return;
          };
          this.canceled = async () => {
            if (this.privSpeechState !== SpeechState.Inactive) {
              try {
                await this.cancelSpeech();
              } catch (error) {
                this.privSpeechState = SpeechState.Inactive;
              }
            }
          };
        }
      }
      get state() {
        return this.privSpeechState;
      }
      set state(newState) {
        this.privSpeechState = newState;
      }
      set authentication(token) {
        this.privReco.authentication = token;
      }
      onConnection() {
        this.privSpeechState = SpeechState.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = SpeechState.Inactive;
        await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(error) {
        try {
          if (!!this.privTranslator.canceled) {
            const cancelEvent = new Exports_js_4.ConversationTranslationCanceledEventArgs(Exports_js_3.CancellationReason.Error, error, Exports_js_3.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, cancelEvent);
          }
        } catch (e) {
        }
      }
      async cancelSpeech() {
        var _a2;
        try {
          this.stopContinuousRecognitionAsync();
          await ((_a2 = this.privReco) == null ? void 0 : _a2.disconnect());
          this.privSpeechState = SpeechState.Inactive;
        } catch (e) {
        }
      }
    }
    class ConversationTranslator2 extends Exports_js_4.ConversationCommon {
      constructor(audioConfig) {
        super(audioConfig);
        this.privErrors = Exports_js_12.ConversationConnectionConfig.restErrors;
        this.privIsDisposed = false;
        this.privIsSpeaking = false;
        this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345";
        this.privPlaceholderRegion = "westus";
        this.privProperties = new Exports_js_3.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        var _a2;
        return (_a2 = this.privConversation) == null ? void 0 : _a2.participants;
      }
      get canSpeak() {
        if (!this.privConversation.isConnected || !this.privCTRecognizer) {
          return false;
        }
        if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {
          return false;
        }
        if (this.privConversation.isMutedByHost) {
          return false;
        }
        return true;
      }
      onToken(token) {
        this.privCTRecognizer.authentication = token;
      }
      setServiceProperty(name2, value) {
        const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_12.ServicePropertiesPropertyName, "{}"));
        currentProperties[name2] = value;
        this.privProperties.setProperty(Exports_js_12.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
      }
      joinConversationAsync(conversation, nickname, param1, param2, param3) {
        try {
          if (typeof conversation === "string") {
            Contracts_js_12.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace("{arg}", "conversation id"));
            Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
            if (!!this.privConversation) {
              this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);
            }
            let lang = param1;
            if (lang === void 0 || lang === null || lang === "") {
              lang = Exports_js_12.ConversationConnectionConfig.defaultLanguageCode;
            }
            this.privSpeechTranslationConfig = Exports_js_3.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);
            this.privSpeechTranslationConfig.setProfanity(Exports_js_3.ProfanityOption.Masked);
            this.privSpeechTranslationConfig.addTargetLanguage(lang);
            this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], lang);
            this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name], nickname);
            const propertyIdsToCopy = [
              Exports_js_3.PropertyId.SpeechServiceConnection_Host,
              Exports_js_3.PropertyId.ConversationTranslator_Host,
              Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint,
              Exports_js_3.PropertyId.SpeechServiceConnection_ProxyHostName,
              Exports_js_3.PropertyId.SpeechServiceConnection_ProxyPassword,
              Exports_js_3.PropertyId.SpeechServiceConnection_ProxyPort,
              Exports_js_3.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const prop of propertyIdsToCopy) {
              const value = this.privProperties.getProperty(prop);
              if (value) {
                const key = typeof prop === "string" ? prop : Exports_js_3.PropertyId[prop];
                this.privSpeechTranslationConfig.setProperty(key, value);
              }
            }
            const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_12.ServicePropertiesPropertyName, "{}"));
            for (const prop of Object.keys(currentProperties)) {
              this.privSpeechTranslationConfig.setServiceProperty(prop, currentProperties[prop], Exports_js_3.ServicePropertyChannel.UriQueryParameter);
            }
            this.privConversation = new Conversation_js_1.ConversationImpl(this.privSpeechTranslationConfig);
            this.privConversation.conversationTranslator = this;
            this.privConversation.joinConversationAsync(conversation, nickname, lang, (result) => {
              if (!result) {
                this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);
              }
              this.privSpeechTranslationConfig.authorizationToken = result;
              this.privConversation.room.isHost = false;
              this.privConversation.startConversationAsync(() => {
                this.handleCallback(param2, param3);
              }, (error) => {
                this.handleError(error, param3);
              });
            }, (error) => {
              this.handleError(error, param3);
            });
          } else if (typeof conversation === "object") {
            Contracts_js_12.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace("{arg}", "conversation id"));
            Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
            this.privProperties.setProperty(Exports_js_3.PropertyId.ConversationTranslator_Name, nickname);
            this.privConversation = conversation;
            this.privConversation.conversationTranslator = this;
            this.privConversation.room.isHost = true;
            Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);
            Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);
            this.privSpeechTranslationConfig = conversation.config;
            this.handleCallback(param1, param2);
          } else {
            this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), param2);
          }
        } catch (error) {
          this.handleError(error, typeof param1 === "string" ? param3 : param2);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(cb2, err2) {
        Exports_js_2.marshalPromiseToCallbacks((async () => {
          await this.cancelSpeech();
          await this.privConversation.endConversationImplAsync();
          await this.privConversation.deleteConversationImplAsync();
          this.dispose();
        })(), cb2, err2);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(message, cb2, err2) {
        try {
          Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);
          Contracts_js_12.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", message));
          this.privConversation.sendTextMessageAsync(message, cb2, err2);
        } catch (error) {
          this.handleError(error, err2);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(cb2, err2) {
        Exports_js_2.marshalPromiseToCallbacks((async () => {
          try {
            Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);
            Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);
            if (this.privCTRecognizer === void 0) {
              await this.connectTranslatorRecognizer();
            }
            Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);
            if (!this.canSpeak) {
              this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
            }
            await this.startContinuousRecognition();
            this.privIsSpeaking = true;
          } catch (error) {
            this.privIsSpeaking = false;
            await this.cancelSpeech();
            throw error;
          }
        })(), cb2, err2);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(cb2, err2) {
        Exports_js_2.marshalPromiseToCallbacks((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = false;
            await new Promise((resolve, reject) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);
            });
          } catch (error) {
            await this.cancelSpeech();
          }
        })(), cb2, err2);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(reason, success, err2) {
        Exports_js_2.marshalPromiseToCallbacks((async () => {
          if (this.isDisposed && !this.privIsSpeaking) {
            return;
          }
          await this.cancelSpeech();
          this.privIsDisposed = true;
          this.privSpeechTranslationConfig.close();
          this.privSpeechRecognitionLanguage = void 0;
          this.privProperties = void 0;
          this.privAudioConfig = void 0;
          this.privSpeechTranslationConfig = void 0;
          this.privConversation.dispose();
          this.privConversation = void 0;
        })(), success, err2);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        var _a2;
        try {
          this.privIsSpeaking = false;
          await ((_a2 = this.privCTRecognizer) == null ? void 0 : _a2.onCancelSpeech());
          this.privCTRecognizer = void 0;
        } catch (e) {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          if (this.privAudioConfig === void 0) {
            this.privAudioConfig = Exports_js_3.AudioConfig.fromDefaultMicrophoneInput();
          }
          if (this.privSpeechTranslationConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {
            this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key], "");
          }
          const convGetter = () => this.privConversation;
          this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this, convGetter);
        } catch (error) {
          await this.cancelSpeech();
          throw error;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((resolve, reject) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);
        });
      }
    }
    exports.ConversationTranslator = ConversationTranslator2;
  })(ConversationTranslator);
  return ConversationTranslator;
}
var ConversationTranscriber = {};
var hasRequiredConversationTranscriber;
function requireConversationTranscriber() {
  if (hasRequiredConversationTranscriber) return ConversationTranscriber;
  hasRequiredConversationTranscriber = 1;
  Object.defineProperty(ConversationTranscriber, "__esModule", { value: true });
  ConversationTranscriber.ConversationTranscriber = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let ConversationTranscriber$1 = class ConversationTranscriber2 extends Exports_js_3.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(speechConfig, audioConfig) {
      const speechConfigImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
      super(audioConfig, speechConfigImpl.properties, new Exports_js_12.ConversationTranscriberConnectionFactory());
      this.privProperties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
      this.privDisposedRecognizer = false;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
      const speechConfigImpl = speechConfig;
      autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
      const recognizer = new ConversationTranscriber2(speechConfig, audioConfig);
      return recognizer;
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      if (this.properties.getProperty(Exports_js_12.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) === Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) {
        return Exports_js_3.OutputFormat.Simple;
      } else {
        return Exports_js_3.OutputFormat.Detailed;
      }
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_12.RecognitionMode.Conversation), cb2, err2);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb2, err2);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(cb2, errorCb) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, errorCb);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(disposing) {
      if (this.privDisposedRecognizer) {
        return;
      }
      if (disposing) {
        this.privDisposedRecognizer = true;
        await this.implRecognizerStop();
      }
      await super.dispose(disposing);
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const configImpl = audioConfig;
      recognizerConfig.isSpeakerDiarizationEnabled = true;
      return new Exports_js_12.ConversationTranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    }
  };
  ConversationTranscriber.ConversationTranscriber = ConversationTranscriber$1;
  return ConversationTranscriber;
}
var IParticipant = {};
var hasRequiredIParticipant;
function requireIParticipant() {
  if (hasRequiredIParticipant) return IParticipant;
  hasRequiredIParticipant = 1;
  Object.defineProperty(IParticipant, "__esModule", { value: true });
  IParticipant.Participant = IParticipant.User = void 0;
  const Exports_js_12 = requireExports$3();
  class User {
    constructor(userId) {
      this.privUserId = userId;
    }
    get userId() {
      return this.privUserId;
    }
  }
  IParticipant.User = User;
  class Participant {
    constructor(id2, avatar, displayName, isHost, isMuted, isUsingTts, preferredLanguage, voice) {
      this.privId = id2;
      this.privAvatar = avatar;
      this.privDisplayName = displayName;
      this.privIsHost = isHost;
      this.privIsMuted = isMuted;
      this.privIsUsingTts = isUsingTts;
      this.privPreferredLanguage = preferredLanguage;
      this.privVoice = voice;
      this.privProperties = new Exports_js_12.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(id2, language, voice) {
      return new Participant(id2, "", id2, false, false, false, language, voice);
    }
  }
  IParticipant.Participant = Participant;
  return IParticipant;
}
var ParticipantChangedReason = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ParticipantChangedReason = void 0;
  (function(ParticipantChangedReason2) {
    ParticipantChangedReason2[ParticipantChangedReason2["JoinedConversation"] = 0] = "JoinedConversation";
    ParticipantChangedReason2[ParticipantChangedReason2["LeftConversation"] = 1] = "LeftConversation";
    ParticipantChangedReason2[ParticipantChangedReason2["Updated"] = 2] = "Updated";
  })(exports.ParticipantChangedReason || (exports.ParticipantChangedReason = {}));
})(ParticipantChangedReason);
var Meeting = {};
var hasRequiredMeeting;
function requireMeeting() {
  if (hasRequiredMeeting) return Meeting;
  hasRequiredMeeting = 1;
  Object.defineProperty(Meeting, "__esModule", { value: true });
  Meeting.MeetingImpl = Meeting.Meeting = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let Meeting$1 = class Meeting {
    constructor() {
      return;
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(speechConfig, meetingId, arg3, arg4) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig, Exports_js_12.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config"));
      Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_js_12.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region"));
      Contracts_js_12.Contracts.throwIfNull(meetingId, "meetingId");
      if (meetingId.length === 0) {
        throw new Error("meetingId cannot be empty");
      }
      if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceAuthorization_Token])) {
        Contracts_js_12.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_js_12.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      }
      const meetingImpl = new MeetingImpl(speechConfig, meetingId);
      Exports_js_2.marshalPromiseToCallbacks((async () => {
      })(), arg3, arg4);
      return meetingImpl;
    }
  };
  Meeting.Meeting = Meeting$1;
  class MeetingImpl extends Meeting$1 {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(speechConfig, id2) {
      super();
      this.privErrors = Exports_js_12.ConversationConnectionConfig.restErrors;
      this.onConnected = (e) => {
        var _a2;
        this.privIsConnected = true;
        try {
          if (!!((_a2 = this.privConversationTranslator) == null ? void 0 : _a2.sessionStarted)) {
            this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);
          }
        } catch (e2) {
        }
      };
      this.onDisconnected = (e) => {
        var _a2;
        try {
          if (!!((_a2 = this.privConversationTranslator) == null ? void 0 : _a2.sessionStopped)) {
            this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);
          }
        } catch (e2) {
        } finally {
          void this.close(false);
        }
      };
      this.onCanceled = (r2, e) => {
        var _a2;
        try {
          if (!!((_a2 = this.privConversationTranslator) == null ? void 0 : _a2.canceled)) {
            this.privConversationTranslator.canceled(this.privConversationTranslator, e);
          }
        } catch (e2) {
        }
      };
      this.onParticipantUpdateCommandReceived = (r2, e) => {
        try {
          const updatedParticipant = this.privParticipants.getParticipant(e.id);
          if (updatedParticipant !== void 0) {
            switch (e.key) {
              case Exports_js_12.ConversationTranslatorCommandTypes.changeNickname:
                updatedParticipant.displayName = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setUseTTS:
                updatedParticipant.isUsingTts = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setProfanityFiltering:
                updatedParticipant.profanity = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setMute:
                updatedParticipant.isMuted = e.value;
                break;
              case Exports_js_12.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                updatedParticipant.translateToLanguages = e.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(updatedParticipant);
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));
            }
          }
        } catch (e2) {
        }
      };
      this.onLockRoomCommandReceived = () => {
      };
      this.onMuteAllCommandReceived = (r2, e) => {
        try {
          this.privParticipants.participants.forEach((p2) => p2.isMuted = p2.isHost ? false : e.isMuted);
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));
          }
        } catch (e2) {
        }
      };
      this.onParticipantJoinCommandReceived = (r2, e) => {
        try {
          const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);
          if (newParticipant !== void 0) {
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));
            }
          }
        } catch (e2) {
        }
      };
      this.onParticipantLeaveCommandReceived = (r2, e) => {
        try {
          const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);
          if (ejectedParticipant !== void 0) {
            this.privParticipants.deleteParticipant(e.participant.id);
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));
            }
          }
        } catch (e2) {
        }
      };
      this.onTranslationReceived = (r2, e) => {
        try {
          switch (e.command) {
            case Exports_js_12.ConversationTranslatorMessageTypes.final:
              if (!!this.privConversationTranslator) {
                this.privConversationTranslator.transcribed(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, void 0, e.sessionId));
              }
              break;
            case Exports_js_12.ConversationTranslatorMessageTypes.partial:
              if (!!this.privConversationTranslator) {
                this.privConversationTranslator.transcribing(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, void 0, e.sessionId));
              }
              break;
            case Exports_js_12.ConversationTranslatorMessageTypes.instantMessage:
              if (!!this.privConversationTranslator) {
                this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, void 0, e.sessionId));
              }
              break;
          }
        } catch (e2) {
        }
      };
      this.onParticipantsListReceived = (r2, e) => {
        var _a2;
        try {
          if (e.sessionToken !== void 0 && e.sessionToken !== null) {
            this.privRoom.token = e.sessionToken;
          }
          this.privParticipants.participants = [...e.participants];
          if (this.privParticipants.me !== void 0) {
            this.privIsReady = true;
          }
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));
          }
          if (this.me.isHost) {
            const nickname = (_a2 = this.privConversationTranslator) == null ? void 0 : _a2.properties.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Name);
            if (nickname !== void 0 && nickname.length > 0 && nickname !== this.me.displayName) {
              this.changeNicknameAsync(nickname);
            }
          }
        } catch (e2) {
        }
      };
      this.onConversationExpiration = (r2, e) => {
        try {
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);
          }
        } catch (e2) {
        }
      };
      this.privIsConnected = false;
      this.privIsDisposed = false;
      this.privConversationId = "";
      this.privProperties = new Exports_js_3.PropertyCollection();
      this.privManager = new Exports_js_12.ConversationManager();
      const language = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
      if (!language) {
        speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_js_12.ConversationConnectionConfig.defaultLanguageCode);
      }
      this.privLanguage = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
      this.privConversationId = id2;
      this.privConfig = speechConfig;
      const configImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(configImpl, "speechConfig");
      this.privProperties = configImpl.properties.clone();
      this.privIsConnected = false;
      this.privParticipants = new Exports_js_12.InternalParticipants();
      this.privIsReady = false;
      this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      var _a2, _b2;
      return ((_a2 = this.privParticipants.me) == null ? void 0 : _a2.isHost) ? false : (_b2 = this.privParticipants.me) == null ? void 0 : _b2.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(true);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const convId = this.meetingId;
      const p2 = this.participants.map((part) => ({
        id: part.id,
        preferredLanguage: part.preferredLanguage,
        voice: part.voice
      }));
      const props = {};
      for (const key of Exports_js_12.ConversationConnectionConfig.transcriptionEventKeys) {
        const val = this.properties.getProperty(key, "");
        if (val !== "") {
          props[key] = val;
        }
      }
      const info = { id: convId, participants: p2, meetingProperties: props };
      return info;
    }
    get canSend() {
      var _a2;
      return this.privIsConnected && !((_a2 = this.privParticipants.me) == null ? void 0 : _a2.isMuted);
    }
    get canSendAsHost() {
      var _a2;
      return this.privIsConnected && ((_a2 = this.privParticipants.me) == null ? void 0 : _a2.isHost);
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(value) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(value, "authorizationToken");
      this.privToken = value;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(cb2, err2) {
      try {
        if (!!this.privConversationRecognizer) {
          this.handleError(new Error(this.privErrors.permissionDeniedStart), err2);
        }
        this.privManager.createOrJoin(this.privProperties, void 0, (room) => {
          if (!room) {
            this.handleError(new Error(this.privErrors.permissionDeniedConnect), err2);
          }
          this.privRoom = room;
          this.handleCallback(cb2, err2);
        }, (error) => {
          this.handleError(error, err2);
        });
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(cb2, err2) {
      try {
        if (!!this.privConversationRecognizer) {
          this.handleError(new Error(this.privErrors.permissionDeniedStart), err2);
        }
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);
        this.privParticipants.meId = this.privRoom.participantId;
        this.privConversationRecognizer.connected = this.onConnected;
        this.privConversationRecognizer.disconnected = this.onDisconnected;
        this.privConversationRecognizer.canceled = this.onCanceled;
        this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;
        this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;
        this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;
        this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;
        this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;
        this.privConversationRecognizer.translationReceived = this.onTranslationReceived;
        this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;
        this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;
        this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(cb2, err2);
        }, (error) => {
          this.handleError(error, err2);
        });
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(participant, cb2, err2) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(participant, "Participant");
      Exports_js_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb2, err2);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(meetingId, nickname, lang, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(meetingId, this.privErrors.invalidArgs.replace("{arg}", "conversationId"));
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace("{arg}", "language"));
        this.privManager.createOrJoin(this.privProperties, meetingId, (room) => {
          Contracts_js_12.Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);
          this.privRoom = room;
          this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;
          if (!!cb2) {
            cb2(room.cognitiveSpeechAuthToken);
          }
        }, (error) => {
          this.handleError(error, err2);
        });
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.deleteMeetingImplAsync(), cb2, err2);
    }
    async deleteMeetingImplAsync() {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);
      await this.privManager.leave(this.privProperties, this.privRoom.token);
      this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(cb2, err2) {
      Exports_js_2.marshalPromiseToCallbacks(this.endMeetingImplAsync(), cb2, err2);
    }
    endMeetingImplAsync() {
      return this.close(true);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getLockCommand(true), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(userId, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!this.me.isHost && this.me.id !== userId) {
          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err2);
        }
        const exists = this.privParticipants.getParticipantIndex(userId);
        if (exists === -1) {
          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(userId, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        if (!!this.privTranscriberRecognizer && userId.hasOwnProperty("id")) {
          Exports_js_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb2, err2);
        } else {
          Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
          Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
          if (!this.canSendAsHost) {
            this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), err2);
          }
          let participantId = "";
          if (typeof userId === "string") {
            participantId = userId;
          } else if (userId.hasOwnProperty("id")) {
            const participant = userId;
            participantId = participant.id;
          } else if (userId.hasOwnProperty("userId")) {
            const user = userId;
            participantId = user.userId;
          }
          Contracts_js_12.Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
          const index2 = this.participants.findIndex((p2) => p2.id === participantId);
          if (index2 === -1) {
            this.handleError(new Error(this.privErrors.invalidParticipantRequest), err2);
          }
          if (!!this.privConversationRecognizer) {
            this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), () => {
              this.handleCallback(cb2, err2);
            }, (error) => {
              this.handleError(error, err2);
            });
          }
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getLockCommand(false), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(userId, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!this.me.isHost && this.me.id !== userId) {
          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err2);
        }
        const exists = this.privParticipants.getParticipantIndex(userId);
        if (exists === -1) {
          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(message, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", "message"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (message.length > this.privTextMessageMaxLength) {
          this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(languages, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace("{arg}", "languages"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(nickname, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
        Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSend) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err2);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), () => {
            this.handleCallback(cb2, err2);
          }, (error) => {
            this.handleError(error, err2);
          });
        }
      } catch (error) {
        this.handleError(error, err2);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      if (this.isDisposed) {
        return;
      }
      this.privIsDisposed = true;
      if (!!this.config) {
        this.config.close();
      }
      this.privConfig = void 0;
      this.privLanguage = void 0;
      this.privProperties = void 0;
      this.privRoom = void 0;
      this.privToken = void 0;
      this.privManager = void 0;
      this.privIsConnected = false;
      this.privIsReady = false;
      this.privParticipants = void 0;
    }
    async connectTranscriberRecognizer(recognizer) {
      if (!!this.privTranscriberRecognizer) {
        await this.privTranscriberRecognizer.close();
      }
      await recognizer.enforceAudioGating();
      this.privTranscriberRecognizer = recognizer;
      this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const nickname = !!this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(participant) {
      const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);
      if (newParticipant !== void 0) {
        if (!!this.privTranscriberRecognizer) {
          const meetingInfo = this.meetingInfo;
          meetingInfo.participants = [participant];
          return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, "join");
        }
      }
    }
    removeParticipantImplAsync(participant) {
      this.privParticipants.deleteParticipant(participant.id);
      const meetingInfo = this.meetingInfo;
      meetingInfo.participants = [participant];
      return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, "leave");
    }
    async close(dispose) {
      var _a2;
      try {
        this.privIsConnected = false;
        await ((_a2 = this.privConversationRecognizer) == null ? void 0 : _a2.close());
        this.privConversationRecognizer = void 0;
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.dispose();
        }
      } catch (e) {
        throw e;
      }
      if (dispose) {
        this.dispose();
      }
    }
    /** Helpers */
    handleCallback(cb2, err2) {
      if (!!cb2) {
        try {
          cb2();
        } catch (e) {
          if (!!err2) {
            err2(e);
          }
        }
        cb2 = void 0;
      }
    }
    handleError(error, err2) {
      if (!!err2) {
        if (error instanceof Error) {
          const typedError = error;
          err2(typedError.name + ": " + typedError.message);
        } else {
          err2(error);
        }
      }
    }
    /** Participant Helpers */
    toParticipants(includeHost) {
      const participants = this.privParticipants.participants.map((p2) => this.toParticipant(p2));
      if (!includeHost) {
        return participants.filter((p2) => p2.isHost === false);
      } else {
        return participants;
      }
    }
    toParticipant(p2) {
      return new Exports_js_3.Participant(p2.id, p2.avatar, p2.displayName, p2.isHost, p2.isMuted, p2.isUsingTts, p2.preferredLanguage, p2.voice);
    }
    getMuteAllCommand(isMuted) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: isMuted
      });
    }
    getMuteCommand(participantId, isMuted) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: isMuted
      });
    }
    getLockCommand(isLocked) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: isLocked
      });
    }
    getEjectCommand(participantId) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(languages) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: languages
      });
    }
    getChangeNicknameCommand(nickname) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      return JSON.stringify({
        command: Exports_js_12.ConversationTranslatorCommandTypes.changeNickname,
        nickname,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: Exports_js_12.ConversationTranslatorMessageTypes.participantCommand,
        value: nickname
      });
    }
    getMessageCommand(message) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(message, "message");
      return JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: message,
        type: Exports_js_12.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  Meeting.MeetingImpl = MeetingImpl;
  return Meeting;
}
var MeetingTranscriptionCanceledEventArgs$1 = {};
var hasRequiredMeetingTranscriptionCanceledEventArgs$1;
function requireMeetingTranscriptionCanceledEventArgs$1() {
  if (hasRequiredMeetingTranscriptionCanceledEventArgs$1) return MeetingTranscriptionCanceledEventArgs$1;
  hasRequiredMeetingTranscriptionCanceledEventArgs$1 = 1;
  Object.defineProperty(MeetingTranscriptionCanceledEventArgs$1, "__esModule", { value: true });
  MeetingTranscriptionCanceledEventArgs$1.MeetingTranscriptionCanceledEventArgs = void 0;
  const CancellationEventArgsBase_js_1 = requireCancellationEventArgsBase();
  class MeetingTranscriptionCanceledEventArgs2 extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {
  }
  MeetingTranscriptionCanceledEventArgs$1.MeetingTranscriptionCanceledEventArgs = MeetingTranscriptionCanceledEventArgs2;
  return MeetingTranscriptionCanceledEventArgs$1;
}
var MeetingTranscriber = {};
var hasRequiredMeetingTranscriber;
function requireMeetingTranscriber() {
  if (hasRequiredMeetingTranscriber) return MeetingTranscriber;
  hasRequiredMeetingTranscriber = 1;
  Object.defineProperty(MeetingTranscriber, "__esModule", { value: true });
  MeetingTranscriber.MeetingTranscriber = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  const Exports_js_4 = requireExports$4();
  let MeetingTranscriber$1 = class MeetingTranscriber {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(audioConfig) {
      this.privAudioConfig = audioConfig;
      this.privProperties = new Exports_js_3.PropertyCollection();
      this.privRecognizer = void 0;
      this.privDisposedRecognizer = false;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return Exports_js_3.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(meeting, cb2, err2) {
      const meetingImpl = meeting;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(Exports_js_4.MeetingImpl, "Meeting");
      this.privRecognizer = new Exports_js_12.TranscriberRecognizer(meeting.config, this.privAudioConfig);
      Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer");
      this.privRecognizer.connectMeetingCallbacks(this);
      Exports_js_2.marshalPromiseToCallbacks(meetingImpl.connectTranscriberRecognizer(this.privRecognizer), cb2, err2);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(cb2, err2) {
      this.privRecognizer.startContinuousRecognitionAsync(cb2, err2);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(cb2, err2) {
      this.privRecognizer.stopContinuousRecognitionAsync(cb2, err2);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(cb2, err2) {
      this.privRecognizer.disconnectCallbacks();
      Exports_js_2.marshalPromiseToCallbacks((async () => {
        return;
      })(), cb2, err2);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(cb2, errorCb) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, errorCb);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(disposing) {
      if (this.privDisposedRecognizer) {
        return;
      }
      if (!!this.privRecognizer) {
        await this.privRecognizer.close();
        this.privRecognizer = void 0;
      }
      if (disposing) {
        this.privDisposedRecognizer = true;
      }
    }
  };
  MeetingTranscriber.MeetingTranscriber = MeetingTranscriber$1;
  return MeetingTranscriber;
}
var ConversationTranscriptionResult = {};
var hasRequiredConversationTranscriptionResult;
function requireConversationTranscriptionResult() {
  if (hasRequiredConversationTranscriptionResult) return ConversationTranscriptionResult;
  hasRequiredConversationTranscriptionResult = 1;
  Object.defineProperty(ConversationTranscriptionResult, "__esModule", { value: true });
  ConversationTranscriptionResult.ConversationTranscriptionResult = void 0;
  const Exports_js_12 = requireExports$3();
  let ConversationTranscriptionResult$1 = class ConversationTranscriptionResult extends Exports_js_12.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
      super(resultId, reason, text2, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties);
      this.privSpeakerId = speakerId;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  ConversationTranscriptionResult.ConversationTranscriptionResult = ConversationTranscriptionResult$1;
  return ConversationTranscriptionResult;
}
var hasRequiredExports$4;
function requireExports$4() {
  if (hasRequiredExports$4) return Exports$2;
  hasRequiredExports$4 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var Conversation_js_1 = requireConversation();
    Object.defineProperty(exports, "Conversation", { enumerable: true, get: function() {
      return Conversation_js_1.Conversation;
    } });
    Object.defineProperty(exports, "ConversationImpl", { enumerable: true, get: function() {
      return Conversation_js_1.ConversationImpl;
    } });
    var ConversationCommon_js_1 = ConversationCommon$1;
    Object.defineProperty(exports, "ConversationCommon", { enumerable: true, get: function() {
      return ConversationCommon_js_1.ConversationCommon;
    } });
    var ConversationExpirationEventArgs_js_1 = requireConversationExpirationEventArgs();
    Object.defineProperty(exports, "ConversationExpirationEventArgs", { enumerable: true, get: function() {
      return ConversationExpirationEventArgs_js_1.ConversationExpirationEventArgs;
    } });
    var ConversationParticipantsChangedEventArgs_js_1 = requireConversationParticipantsChangedEventArgs();
    Object.defineProperty(exports, "ConversationParticipantsChangedEventArgs", { enumerable: true, get: function() {
      return ConversationParticipantsChangedEventArgs_js_1.ConversationParticipantsChangedEventArgs;
    } });
    var ConversationTranslationCanceledEventArgs_js_1 = requireConversationTranslationCanceledEventArgs();
    Object.defineProperty(exports, "ConversationTranslationCanceledEventArgs", { enumerable: true, get: function() {
      return ConversationTranslationCanceledEventArgs_js_1.ConversationTranslationCanceledEventArgs;
    } });
    var ConversationTranslationEventArgs_js_1 = requireConversationTranslationEventArgs();
    Object.defineProperty(exports, "ConversationTranslationEventArgs", { enumerable: true, get: function() {
      return ConversationTranslationEventArgs_js_1.ConversationTranslationEventArgs;
    } });
    var ConversationTranslationResult_js_1 = requireConversationTranslationResult();
    Object.defineProperty(exports, "ConversationTranslationResult", { enumerable: true, get: function() {
      return ConversationTranslationResult_js_1.ConversationTranslationResult;
    } });
    var ConversationTranslator_js_1 = requireConversationTranslator();
    Object.defineProperty(exports, "ConversationTranslator", { enumerable: true, get: function() {
      return ConversationTranslator_js_1.ConversationTranslator;
    } });
    var ConversationTranscriber_js_1 = requireConversationTranscriber();
    Object.defineProperty(exports, "ConversationTranscriber", { enumerable: true, get: function() {
      return ConversationTranscriber_js_1.ConversationTranscriber;
    } });
    var IParticipant_js_1 = requireIParticipant();
    Object.defineProperty(exports, "Participant", { enumerable: true, get: function() {
      return IParticipant_js_1.Participant;
    } });
    Object.defineProperty(exports, "User", { enumerable: true, get: function() {
      return IParticipant_js_1.User;
    } });
    var ParticipantChangedReason_js_1 = ParticipantChangedReason;
    Object.defineProperty(exports, "ParticipantChangedReason", { enumerable: true, get: function() {
      return ParticipantChangedReason_js_1.ParticipantChangedReason;
    } });
    var Meeting_js_1 = requireMeeting();
    Object.defineProperty(exports, "Meeting", { enumerable: true, get: function() {
      return Meeting_js_1.Meeting;
    } });
    Object.defineProperty(exports, "MeetingImpl", { enumerable: true, get: function() {
      return Meeting_js_1.MeetingImpl;
    } });
    var MeetingTranscriptionCanceledEventArgs_js_1 = requireMeetingTranscriptionCanceledEventArgs$1();
    Object.defineProperty(exports, "MeetingTranscriptionCanceledEventArgs", { enumerable: true, get: function() {
      return MeetingTranscriptionCanceledEventArgs_js_1.MeetingTranscriptionCanceledEventArgs;
    } });
    var MeetingTranscriber_js_1 = requireMeetingTranscriber();
    Object.defineProperty(exports, "MeetingTranscriber", { enumerable: true, get: function() {
      return MeetingTranscriber_js_1.MeetingTranscriber;
    } });
    var ConversationTranscriptionResult_js_1 = requireConversationTranscriptionResult();
    Object.defineProperty(exports, "ConversationTranscriptionResult", { enumerable: true, get: function() {
      return ConversationTranscriptionResult_js_1.ConversationTranscriptionResult;
    } });
  })(Exports$2);
  return Exports$2;
}
var Synthesizer = {};
var hasRequiredSynthesizer;
function requireSynthesizer() {
  if (hasRequiredSynthesizer) return Synthesizer;
  hasRequiredSynthesizer = 1;
  Object.defineProperty(Synthesizer, "__esModule", { value: true });
  Synthesizer.SynthesisRequest = Synthesizer.Synthesizer = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  let Synthesizer$1 = class Synthesizer2 {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(speechConfig) {
      const speechConfigImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
      this.privProperties = speechConfigImpl.properties.clone();
      this.privDisposed = false;
      this.privSynthesizing = false;
      this.synthesisRequestQueue = new Exports_js_2.Queue();
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === Exports_js_12.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(text2) {
      const languageToDefaultVoice = {
        ["af-ZA"]: "af-ZA-AdriNeural",
        ["am-ET"]: "am-ET-AmehaNeural",
        ["ar-AE"]: "ar-AE-FatimaNeural",
        ["ar-BH"]: "ar-BH-AliNeural",
        ["ar-DZ"]: "ar-DZ-AminaNeural",
        ["ar-EG"]: "ar-EG-SalmaNeural",
        ["ar-IQ"]: "ar-IQ-BasselNeural",
        ["ar-JO"]: "ar-JO-SanaNeural",
        ["ar-KW"]: "ar-KW-FahedNeural",
        ["ar-LY"]: "ar-LY-ImanNeural",
        ["ar-MA"]: "ar-MA-JamalNeural",
        ["ar-QA"]: "ar-QA-AmalNeural",
        ["ar-SA"]: "ar-SA-HamedNeural",
        ["ar-SY"]: "ar-SY-AmanyNeural",
        ["ar-TN"]: "ar-TN-HediNeural",
        ["ar-YE"]: "ar-YE-MaryamNeural",
        ["bg-BG"]: "bg-BG-BorislavNeural",
        ["bn-BD"]: "bn-BD-NabanitaNeural",
        ["bn-IN"]: "bn-IN-BashkarNeural",
        ["ca-ES"]: "ca-ES-JoanaNeural",
        ["cs-CZ"]: "cs-CZ-AntoninNeural",
        ["cy-GB"]: "cy-GB-AledNeural",
        ["da-DK"]: "da-DK-ChristelNeural",
        ["de-AT"]: "de-AT-IngridNeural",
        ["de-CH"]: "de-CH-JanNeural",
        ["de-DE"]: "de-DE-KatjaNeural",
        ["el-GR"]: "el-GR-AthinaNeural",
        ["en-AU"]: "en-AU-NatashaNeural",
        ["en-CA"]: "en-CA-ClaraNeural",
        ["en-GB"]: "en-GB-LibbyNeural",
        ["en-HK"]: "en-HK-SamNeural",
        ["en-IE"]: "en-IE-ConnorNeural",
        ["en-IN"]: "en-IN-NeerjaNeural",
        ["en-KE"]: "en-KE-AsiliaNeural",
        ["en-NG"]: "en-NG-AbeoNeural",
        ["en-NZ"]: "en-NZ-MitchellNeural",
        ["en-PH"]: "en-PH-JamesNeural",
        ["en-SG"]: "en-SG-LunaNeural",
        ["en-TZ"]: "en-TZ-ElimuNeural",
        ["en-US"]: "en-US-AvaMultilingualNeural",
        ["en-ZA"]: "en-ZA-LeahNeural",
        ["es-AR"]: "es-AR-ElenaNeural",
        ["es-BO"]: "es-BO-MarceloNeural",
        ["es-CL"]: "es-CL-CatalinaNeural",
        ["es-CO"]: "es-CO-GonzaloNeural",
        ["es-CR"]: "es-CR-JuanNeural",
        ["es-CU"]: "es-CU-BelkysNeural",
        ["es-DO"]: "es-DO-EmilioNeural",
        ["es-EC"]: "es-EC-AndreaNeural",
        ["es-ES"]: "es-ES-AlvaroNeural",
        ["es-GQ"]: "es-GQ-JavierNeural",
        ["es-GT"]: "es-GT-AndresNeural",
        ["es-HN"]: "es-HN-CarlosNeural",
        ["es-MX"]: "es-MX-DaliaNeural",
        ["es-NI"]: "es-NI-FedericoNeural",
        ["es-PA"]: "es-PA-MargaritaNeural",
        ["es-PE"]: "es-PE-AlexNeural",
        ["es-PR"]: "es-PR-KarinaNeural",
        ["es-PY"]: "es-PY-MarioNeural",
        ["es-SV"]: "es-SV-LorenaNeural",
        ["es-US"]: "es-US-AlonsoNeural",
        ["es-UY"]: "es-UY-MateoNeural",
        ["es-VE"]: "es-VE-PaolaNeural",
        ["et-EE"]: "et-EE-AnuNeural",
        ["fa-IR"]: "fa-IR-DilaraNeural",
        ["fi-FI"]: "fi-FI-SelmaNeural",
        ["fil-PH"]: "fil-PH-AngeloNeural",
        ["fr-BE"]: "fr-BE-CharlineNeural",
        ["fr-CA"]: "fr-CA-SylvieNeural",
        ["fr-CH"]: "fr-CH-ArianeNeural",
        ["fr-FR"]: "fr-FR-DeniseNeural",
        ["ga-IE"]: "ga-IE-ColmNeural",
        ["gl-ES"]: "gl-ES-RoiNeural",
        ["gu-IN"]: "gu-IN-DhwaniNeural",
        ["he-IL"]: "he-IL-AvriNeural",
        ["hi-IN"]: "hi-IN-MadhurNeural",
        ["hr-HR"]: "hr-HR-GabrijelaNeural",
        ["hu-HU"]: "hu-HU-NoemiNeural",
        ["id-ID"]: "id-ID-ArdiNeural",
        ["is-IS"]: "is-IS-GudrunNeural",
        ["it-IT"]: "it-IT-IsabellaNeural",
        ["ja-JP"]: "ja-JP-NanamiNeural",
        ["jv-ID"]: "jv-ID-DimasNeural",
        ["kk-KZ"]: "kk-KZ-AigulNeural",
        ["km-KH"]: "km-KH-PisethNeural",
        ["kn-IN"]: "kn-IN-GaganNeural",
        ["ko-KR"]: "ko-KR-SunHiNeural",
        ["lo-LA"]: "lo-LA-ChanthavongNeural",
        ["lt-LT"]: "lt-LT-LeonasNeural",
        ["lv-LV"]: "lv-LV-EveritaNeural",
        ["mk-MK"]: "mk-MK-AleksandarNeural",
        ["ml-IN"]: "ml-IN-MidhunNeural",
        ["mr-IN"]: "mr-IN-AarohiNeural",
        ["ms-MY"]: "ms-MY-OsmanNeural",
        ["mt-MT"]: "mt-MT-GraceNeural",
        ["my-MM"]: "my-MM-NilarNeural",
        ["nb-NO"]: "nb-NO-PernilleNeural",
        ["nl-BE"]: "nl-BE-ArnaudNeural",
        ["nl-NL"]: "nl-NL-ColetteNeural",
        ["pl-PL"]: "pl-PL-AgnieszkaNeural",
        ["ps-AF"]: "ps-AF-GulNawazNeural",
        ["pt-BR"]: "pt-BR-FranciscaNeural",
        ["pt-PT"]: "pt-PT-DuarteNeural",
        ["ro-RO"]: "ro-RO-AlinaNeural",
        ["ru-RU"]: "ru-RU-SvetlanaNeural",
        ["si-LK"]: "si-LK-SameeraNeural",
        ["sk-SK"]: "sk-SK-LukasNeural",
        ["sl-SI"]: "sl-SI-PetraNeural",
        ["so-SO"]: "so-SO-MuuseNeural",
        ["sr-RS"]: "sr-RS-NicholasNeural",
        ["su-ID"]: "su-ID-JajangNeural",
        ["sv-SE"]: "sv-SE-SofieNeural",
        ["sw-KE"]: "sw-KE-RafikiNeural",
        ["sw-TZ"]: "sw-TZ-DaudiNeural",
        ["ta-IN"]: "ta-IN-PallaviNeural",
        ["ta-LK"]: "ta-LK-KumarNeural",
        ["ta-SG"]: "ta-SG-AnbuNeural",
        ["te-IN"]: "te-IN-MohanNeural",
        ["th-TH"]: "th-TH-PremwadeeNeural",
        ["tr-TR"]: "tr-TR-AhmetNeural",
        ["uk-UA"]: "uk-UA-OstapNeural",
        ["ur-IN"]: "ur-IN-GulNeural",
        ["ur-PK"]: "ur-PK-AsadNeural",
        ["uz-UZ"]: "uz-UZ-MadinaNeural",
        ["vi-VN"]: "vi-VN-HoaiMyNeural",
        ["zh-CN"]: "zh-CN-XiaoxiaoNeural",
        ["zh-HK"]: "zh-HK-HiuMaanNeural",
        ["zh-TW"]: "zh-TW-HsiaoChenNeural",
        ["zu-ZA"]: "zu-ZA-ThandoNeural"
      };
      let language = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US");
      let voice = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthVoice, "");
      let ssml = Synthesizer2.XMLEncode(text2);
      if (this.autoDetectSourceLanguage) {
        language = "en-US";
      } else {
        voice = voice || languageToDefaultVoice[language];
      }
      if (voice) {
        ssml = `<voice name='${voice}'>${ssml}</voice>`;
      }
      ssml = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${language}'>${ssml}</speak>`;
      return ssml;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(disposing) {
      if (this.privDisposed) {
        return;
      }
      if (disposing) {
        if (this.privAdapter) {
          await this.privAdapter.dispose();
        }
      }
      this.privDisposed = true;
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = true;
        const request = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(request.text, request.isSSML, request.requestId, request.cb, request.err, request.dataStream);
      }
    }
    createSynthesizerConfig(speechConfig) {
      return new Exports_js_12.SynthesizerConfig(speechConfig, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let osPlatform = typeof window !== "undefined" ? "Browser" : "Node";
      let osName = "unknown";
      let osVersion = "unknown";
      if (typeof navigator !== "undefined") {
        osPlatform = osPlatform + "/" + navigator.platform;
        osName = navigator.userAgent;
        osVersion = navigator.appVersion;
      }
      const synthesizerConfig = this.createSynthesizerConfig(new Exports_js_12.SpeechServiceConfig(new Exports_js_12.Context(new Exports_js_12.OS(osPlatform, osName, osVersion))));
      const subscriptionKey = this.privProperties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Key, void 0);
      const authentication = subscriptionKey && subscriptionKey !== "" ? new Exports_js_12.CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new Exports_js_12.CognitiveTokenAuthentication(() => {
        const authorizationToken = this.privProperties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(authorizationToken);
      }, () => {
        const authorizationToken = this.privProperties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(authorizationToken);
      });
      this.privAdapter = this.createSynthesisAdapter(authentication, this.privConnectionFactory, synthesizerConfig);
      this.privRestAdapter = this.createRestSynthesisAdapter(authentication, synthesizerConfig);
    }
    static XMLEncode(text2) {
      return text2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  Synthesizer.Synthesizer = Synthesizer$1;
  class SynthesisRequest {
    constructor(requestId, text2, isSSML, cb2, err2, dataStream) {
      this.requestId = requestId;
      this.text = text2;
      this.isSSML = isSSML;
      this.cb = cb2;
      this.err = err2;
      this.dataStream = dataStream;
    }
  }
  Synthesizer.SynthesisRequest = SynthesisRequest;
  return Synthesizer;
}
var SpeechSynthesizer = {};
var hasRequiredSpeechSynthesizer;
function requireSpeechSynthesizer() {
  if (hasRequiredSpeechSynthesizer) return SpeechSynthesizer;
  hasRequiredSpeechSynthesizer = 1;
  Object.defineProperty(SpeechSynthesizer, "__esModule", { value: true });
  SpeechSynthesizer.SpeechSynthesizer = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const AudioFileWriter_js_1 = AudioFileWriter$1;
  const AudioOutputFormat_js_12 = AudioOutputFormat;
  const AudioOutputStream_js_12 = AudioOutputStream$1;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  const Synthesizer_js_1 = requireSynthesizer();
  let SpeechSynthesizer$1 = class SpeechSynthesizer2 extends Exports_js_3.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(speechConfig, audioConfig) {
      super(speechConfig);
      if (audioConfig !== null) {
        if (audioConfig === void 0) {
          this.audioConfig = typeof window === "undefined" ? void 0 : Exports_js_3.AudioConfig.fromDefaultSpeakerOutput();
        } else {
          this.audioConfig = audioConfig;
        }
      }
      this.privConnectionFactory = new Exports_js_12.SpeechSynthesisConnectionFactory();
      this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
      const speechConfigImpl = speechConfig;
      autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
      return new SpeechSynthesizer2(speechConfig, audioConfig);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(text2, cb2, err2, stream) {
      this.speakImpl(text2, false, cb2, err2, stream);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(ssml, cb2, err2, stream) {
      this.speakImpl(ssml, true, cb2, err2, stream);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(locale = "") {
      return this.getVoices(locale);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(cb2, err2) {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
      Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb2, err2);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(authentication, connectionFactory, synthesizerConfig) {
      return new Exports_js_12.SpeechSynthesisAdapter(authentication, connectionFactory, synthesizerConfig, this, this.audioConfig);
    }
    createRestSynthesisAdapter(authentication, synthesizerConfig) {
      return new Exports_js_12.SynthesisRestAdapter(synthesizerConfig, authentication);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup();
      this.privAdapter.audioOutputFormat = AudioOutputFormat_js_12.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(Exports_js_3.SpeechSynthesisOutputFormat[this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(text2, IsSsml, cb2, err2, dataStream) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
        const requestId = Exports_js_2.createNoDashGuid();
        let audioDestination;
        if (dataStream instanceof Exports_js_3.PushAudioOutputStreamCallback) {
          audioDestination = new AudioOutputStream_js_12.PushAudioOutputStreamImpl(dataStream);
        } else if (dataStream instanceof Exports_js_3.PullAudioOutputStream) {
          audioDestination = dataStream;
        } else if (dataStream !== void 0) {
          audioDestination = new AudioFileWriter_js_1.AudioFileWriter(dataStream);
        } else {
          audioDestination = void 0;
        }
        this.synthesisRequestQueue.enqueue(new Synthesizer_js_1.SynthesisRequest(requestId, text2, IsSsml, (e) => {
          this.privSynthesizing = false;
          if (!!cb2) {
            try {
              cb2(e);
            } catch (e2) {
              if (!!err2) {
                err2(e2);
              }
            }
          }
          cb2 = void 0;
          this.adapterSpeak().catch(() => {
          });
        }, (e) => {
          if (!!err2) {
            err2(e);
          }
        }, audioDestination));
        this.adapterSpeak().catch(() => {
        });
      } catch (error) {
        if (!!err2) {
          if (error instanceof Error) {
            const typedError = error;
            err2(typedError.name + ": " + typedError.message);
          } else {
            err2(error);
          }
        }
        this.dispose(true).catch(() => {
        });
      }
    }
    async getVoices(locale) {
      const requestId = Exports_js_2.createNoDashGuid();
      const response = await this.privRestAdapter.getVoicesList(requestId);
      if (response.ok && Array.isArray(response.json)) {
        let json = response.json;
        if (!!locale && locale.length > 0) {
          json = json.filter((item) => !!item.Locale && item.Locale.toLowerCase() === locale.toLowerCase());
        }
        return new Exports_js_3.SynthesisVoicesResult(requestId, json, void 0);
      } else {
        return new Exports_js_3.SynthesisVoicesResult(requestId, void 0, `Error: ${response.status}: ${response.statusText}`);
      }
    }
  };
  SpeechSynthesizer.SpeechSynthesizer = SpeechSynthesizer$1;
  return SpeechSynthesizer;
}
var SynthesisResult$1 = {};
Object.defineProperty(SynthesisResult$1, "__esModule", { value: true });
SynthesisResult$1.SynthesisResult = void 0;
class SynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(resultId, reason, errorDetails, properties) {
    this.privResultId = resultId;
    this.privReason = reason;
    this.privErrorDetails = errorDetails;
    this.privProperties = properties;
  }
  /**
   * Specifies the result identifier.
   * @member SynthesisResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member SynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful synthesis, provides details of the occurred error.
   * @member SynthesisResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The set of properties exposed in the result.
   * @member SynthesisResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
SynthesisResult$1.SynthesisResult = SynthesisResult;
var SpeechSynthesisResult = {};
var hasRequiredSpeechSynthesisResult;
function requireSpeechSynthesisResult() {
  if (hasRequiredSpeechSynthesisResult) return SpeechSynthesisResult;
  hasRequiredSpeechSynthesisResult = 1;
  Object.defineProperty(SpeechSynthesisResult, "__esModule", { value: true });
  SpeechSynthesisResult.SpeechSynthesisResult = void 0;
  const Exports_js_12 = requireExports$3();
  let SpeechSynthesisResult$1 = class SpeechSynthesisResult extends Exports_js_12.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(resultId, reason, audioData, errorDetails, properties, audioDuration) {
      super(resultId, reason, errorDetails, properties);
      this.privAudioData = audioData;
      this.privAudioDuration = audioDuration;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  SpeechSynthesisResult.SpeechSynthesisResult = SpeechSynthesisResult$1;
  return SpeechSynthesisResult;
}
var SpeechSynthesisEventArgs$1 = {};
Object.defineProperty(SpeechSynthesisEventArgs$1, "__esModule", { value: true });
SpeechSynthesisEventArgs$1.SpeechSynthesisEventArgs = void 0;
class SpeechSynthesisEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {SpeechSynthesisResult} result - The speech synthesis result.
   */
  constructor(result) {
    this.privResult = result;
  }
  /**
   * Specifies the synthesis result.
   * @member SpeechSynthesisEventArgs.prototype.result
   * @function
   * @public
   * @returns {SpeechSynthesisResult} the synthesis result.
   */
  get result() {
    return this.privResult;
  }
}
SpeechSynthesisEventArgs$1.SpeechSynthesisEventArgs = SpeechSynthesisEventArgs;
var SpeechSynthesisWordBoundaryEventArgs$1 = {};
Object.defineProperty(SpeechSynthesisWordBoundaryEventArgs$1, "__esModule", { value: true });
SpeechSynthesisWordBoundaryEventArgs$1.SpeechSynthesisWordBoundaryEventArgs = void 0;
class SpeechSynthesisWordBoundaryEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} duration - The audio duration.
   * @param {string} text - The text.
   * @param {number} wordLength - The length of the word.
   * @param {number} textOffset - The text offset.
   * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
   */
  constructor(audioOffset, duration, text2, wordLength, textOffset, boundaryType) {
    this.privAudioOffset = audioOffset;
    this.privDuration = duration;
    this.privText = text2;
    this.privWordLength = wordLength;
    this.privTextOffset = textOffset;
    this.privBoundaryType = boundaryType;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the duration, in ticks (100 nanoseconds).
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
   * @function
   * @public
   * @returns {number} Duration in 100 nanosecond increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Specifies the text of the word boundary event.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the text.
   */
  get text() {
    return this.privText;
  }
  /**
   * Specifies the word length
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
   * @function
   * @public
   * @returns {number} the word length
   */
  get wordLength() {
    return this.privWordLength;
  }
  /**
   * Specifies the text offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
   * @function
   * @public
   * @returns {number} the text offset.
   */
  get textOffset() {
    return this.privTextOffset;
  }
  /**
   * Specifies the boundary type.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
   * @function
   * @public
   * @returns {SpeechSynthesisBoundaryType} the boundary type.
   */
  get boundaryType() {
    return this.privBoundaryType;
  }
}
SpeechSynthesisWordBoundaryEventArgs$1.SpeechSynthesisWordBoundaryEventArgs = SpeechSynthesisWordBoundaryEventArgs;
var SpeechSynthesisBookmarkEventArgs$1 = {};
Object.defineProperty(SpeechSynthesisBookmarkEventArgs$1, "__esModule", { value: true });
SpeechSynthesisBookmarkEventArgs$1.SpeechSynthesisBookmarkEventArgs = void 0;
class SpeechSynthesisBookmarkEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {string} text - The bookmark text.
   */
  constructor(audioOffset, text2) {
    this.privAudioOffset = audioOffset;
    this.privText = text2;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the bookmark.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the bookmark text.
   */
  get text() {
    return this.privText;
  }
}
SpeechSynthesisBookmarkEventArgs$1.SpeechSynthesisBookmarkEventArgs = SpeechSynthesisBookmarkEventArgs;
var SpeechSynthesisVisemeEventArgs$1 = {};
Object.defineProperty(SpeechSynthesisVisemeEventArgs$1, "__esModule", { value: true });
SpeechSynthesisVisemeEventArgs$1.SpeechSynthesisVisemeEventArgs = void 0;
class SpeechSynthesisVisemeEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} visemeId - The viseme ID.
   * @param {string} animation - The animation, could be in svg or other format.
   */
  constructor(audioOffset, visemeId, animation) {
    this.privAudioOffset = audioOffset;
    this.privVisemeId = visemeId;
    this.privAnimation = animation;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the viseme ID.
   * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
   * @function
   * @public
   * @returns {number} the viseme ID.
   */
  get visemeId() {
    return this.privVisemeId;
  }
  /**
   * Specifies the animation.
   * @member SpeechSynthesisVisemeEventArgs.prototype.animation
   * @function
   * @public
   * @returns {string} the animation, could be in svg or other format.
   */
  get animation() {
    return this.privAnimation;
  }
}
SpeechSynthesisVisemeEventArgs$1.SpeechSynthesisVisemeEventArgs = SpeechSynthesisVisemeEventArgs;
var SpeechSynthesisBoundaryType = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SpeechSynthesisBoundaryType = void 0;
  (function(SpeechSynthesisBoundaryType2) {
    SpeechSynthesisBoundaryType2["Word"] = "WordBoundary";
    SpeechSynthesisBoundaryType2["Punctuation"] = "PunctuationBoundary";
    SpeechSynthesisBoundaryType2["Sentence"] = "SentenceBoundary";
  })(exports.SpeechSynthesisBoundaryType || (exports.SpeechSynthesisBoundaryType = {}));
})(SpeechSynthesisBoundaryType);
var SynthesisVoicesResult = {};
var hasRequiredSynthesisVoicesResult;
function requireSynthesisVoicesResult() {
  if (hasRequiredSynthesisVoicesResult) return SynthesisVoicesResult;
  hasRequiredSynthesisVoicesResult = 1;
  Object.defineProperty(SynthesisVoicesResult, "__esModule", { value: true });
  SynthesisVoicesResult.SynthesisVoicesResult = void 0;
  const Exports_js_12 = requireExports$3();
  let SynthesisVoicesResult$1 = class SynthesisVoicesResult extends Exports_js_12.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(requestId, json, errorDetails) {
      if (Array.isArray(json)) {
        super(requestId, Exports_js_12.ResultReason.VoicesListRetrieved, void 0, new Exports_js_12.PropertyCollection());
        this.privVoices = [];
        for (const item of json) {
          this.privVoices.push(new Exports_js_12.VoiceInfo(item));
        }
      } else {
        super(requestId, Exports_js_12.ResultReason.Canceled, errorDetails ? errorDetails : "Error information unavailable", new Exports_js_12.PropertyCollection());
      }
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  SynthesisVoicesResult.SynthesisVoicesResult = SynthesisVoicesResult$1;
  return SynthesisVoicesResult;
}
var VoiceInfo = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VoiceInfo = exports.SynthesisVoiceType = exports.SynthesisVoiceGender = void 0;
  var SynthesisVoiceGender;
  (function(SynthesisVoiceGender2) {
    SynthesisVoiceGender2[SynthesisVoiceGender2["Unknown"] = 0] = "Unknown";
    SynthesisVoiceGender2[SynthesisVoiceGender2["Female"] = 1] = "Female";
    SynthesisVoiceGender2[SynthesisVoiceGender2["Male"] = 2] = "Male";
    SynthesisVoiceGender2[SynthesisVoiceGender2["Neutral"] = 3] = "Neutral";
  })(SynthesisVoiceGender = exports.SynthesisVoiceGender || (exports.SynthesisVoiceGender = {}));
  var SynthesisVoiceType;
  (function(SynthesisVoiceType2) {
    SynthesisVoiceType2[SynthesisVoiceType2["OnlineNeural"] = 1] = "OnlineNeural";
    SynthesisVoiceType2[SynthesisVoiceType2["OnlineStandard"] = 2] = "OnlineStandard";
    SynthesisVoiceType2[SynthesisVoiceType2["OfflineNeural"] = 3] = "OfflineNeural";
    SynthesisVoiceType2[SynthesisVoiceType2["OfflineStandard"] = 4] = "OfflineStandard";
  })(SynthesisVoiceType = exports.SynthesisVoiceType || (exports.SynthesisVoiceType = {}));
  const GENDER_LOOKUP = {
    [SynthesisVoiceGender[SynthesisVoiceGender.Neutral]]: SynthesisVoiceGender.Neutral,
    [SynthesisVoiceGender[SynthesisVoiceGender.Male]]: SynthesisVoiceGender.Male,
    [SynthesisVoiceGender[SynthesisVoiceGender.Female]]: SynthesisVoiceGender.Female
  };
  class VoiceInfo2 {
    constructor(json) {
      this.privStyleList = [];
      if (!!json) {
        this.privName = json.Name;
        this.privLocale = json.Locale;
        this.privShortName = json.ShortName;
        this.privLocaleName = json.LocaleName;
        this.privDisplayName = json.DisplayName;
        this.privLocalName = json.LocalName;
        this.privVoiceType = json.VoiceType.endsWith("Standard") ? SynthesisVoiceType.OnlineStandard : SynthesisVoiceType.OnlineNeural;
        this.privGender = GENDER_LOOKUP[json.Gender] || SynthesisVoiceGender.Unknown;
        if (!!json.StyleList && Array.isArray(json.StyleList)) {
          for (const style of json.StyleList) {
            this.privStyleList.push(style);
          }
        }
        this.privSampleRateHertz = json.SampleRateHertz;
        this.privStatus = json.Status;
        if (json.ExtendedPropertyMap) {
          this.privExtendedPropertyMap = json.ExtendedPropertyMap;
        }
        this.privWordsPerMinute = json.WordsPerMinute;
        if (Array.isArray(json.SecondaryLocaleList)) {
          this.privSecondaryLocaleList = [...json.SecondaryLocaleList];
        }
        if (Array.isArray(json.RolePlayList)) {
          this.privRolePlayList = [...json.RolePlayList];
        }
      }
    }
    get name() {
      return this.privName;
    }
    get locale() {
      return this.privLocale;
    }
    get shortName() {
      return this.privShortName;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get localName() {
      return this.privLocalName;
    }
    get localeName() {
      return this.privLocaleName;
    }
    get gender() {
      return this.privGender;
    }
    get voiceType() {
      return this.privVoiceType;
    }
    get styleList() {
      return this.privStyleList;
    }
    get sampleRateHertz() {
      return this.privSampleRateHertz;
    }
    get status() {
      return this.privStatus;
    }
    get extendedPropertyMap() {
      return this.privExtendedPropertyMap;
    }
    get wordsPerMinute() {
      return this.privWordsPerMinute;
    }
    get secondaryLocaleList() {
      return this.privSecondaryLocaleList;
    }
    get rolePlayList() {
      return this.privRolePlayList;
    }
  }
  exports.VoiceInfo = VoiceInfo2;
})(VoiceInfo);
var SpeakerAudioDestination$1 = {};
Object.defineProperty(SpeakerAudioDestination$1, "__esModule", { value: true });
SpeakerAudioDestination$1.SpeakerAudioDestination = void 0;
const Exports_js_1$8 = requireExports$5();
const AudioOutputStream_js_1$1 = AudioOutputStream$1;
const AudioStreamFormat_js_1 = AudioStreamFormat;
const MediaDurationPlaceholderSeconds = 60 * 30;
const AudioFormatToMimeType = {
  [AudioStreamFormat_js_1.AudioFormatTag.PCM]: "audio/wav",
  [AudioStreamFormat_js_1.AudioFormatTag.MuLaw]: "audio/x-wav",
  [AudioStreamFormat_js_1.AudioFormatTag.MP3]: "audio/mpeg",
  [AudioStreamFormat_js_1.AudioFormatTag.OGG_OPUS]: "audio/ogg",
  [AudioStreamFormat_js_1.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
  [AudioStreamFormat_js_1.AudioFormatTag.ALaw]: "audio/x-wav",
  [AudioStreamFormat_js_1.AudioFormatTag.FLAC]: "audio/flac",
  [AudioStreamFormat_js_1.AudioFormatTag.AMR_WB]: "audio/amr-wb",
  [AudioStreamFormat_js_1.AudioFormatTag.G722]: "audio/G722"
};
class SpeakerAudioDestination {
  constructor(audioDestinationId) {
    this.privPlaybackStarted = false;
    this.privAppendingToBuffer = false;
    this.privMediaSourceOpened = false;
    this.privBytesReceived = 0;
    this.privId = audioDestinationId ? audioDestinationId : Exports_js_1$8.createNoDashGuid();
    this.privIsPaused = false;
    this.privIsClosed = false;
  }
  id() {
    return this.privId;
  }
  write(buffer, cb2, err2) {
    if (this.privAudioBuffer !== void 0) {
      this.privAudioBuffer.push(buffer);
      this.updateSourceBuffer().then(() => {
        if (!!cb2) {
          cb2();
        }
      }, (error) => {
        if (!!err2) {
          err2(error);
        }
      });
    } else if (this.privAudioOutputStream !== void 0) {
      this.privAudioOutputStream.write(buffer);
      this.privBytesReceived += buffer.byteLength;
    }
  }
  close(cb2, err2) {
    this.privIsClosed = true;
    if (this.privSourceBuffer !== void 0) {
      this.handleSourceBufferUpdateEnd().then(() => {
        if (!!cb2) {
          cb2();
        }
      }, (error) => {
        if (!!err2) {
          err2(error);
        }
      });
    } else if (this.privAudioOutputStream !== void 0 && typeof window !== "undefined") {
      if ((this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.PCM || this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.MuLaw || this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {
        console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header.");
        if (!!this.onAudioEnd) {
          this.onAudioEnd(this);
        }
      } else {
        let receivedAudio = new ArrayBuffer(this.privBytesReceived);
        this.privAudioOutputStream.read(receivedAudio).then(() => {
          receivedAudio = this.privFormat.addHeader(receivedAudio);
          const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });
          this.privAudio.src = window.URL.createObjectURL(audioBlob);
          this.notifyPlayback().then(() => {
            if (!!cb2) {
              cb2();
            }
          }, (error) => {
            if (!!err2) {
              err2(error);
            }
          });
        }, (error) => {
          if (!!err2) {
            err2(error);
          }
        });
      }
    } else {
      if (!!this.onAudioEnd) {
        this.onAudioEnd(this);
      }
    }
  }
  set format(format) {
    if (typeof AudioContext !== "undefined" || typeof window !== "undefined" && typeof window.webkitAudioContext !== "undefined") {
      this.privFormat = format;
      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];
      if (mimeType === void 0) {
        console.warn(`Unknown mimeType for format ${AudioStreamFormat_js_1.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);
      } else if (typeof MediaSource !== "undefined" && MediaSource.isTypeSupported(mimeType)) {
        this.privAudio = new Audio();
        this.privAudioBuffer = [];
        this.privMediaSource = new MediaSource();
        this.privAudio.src = URL.createObjectURL(this.privMediaSource);
        this.privAudio.load();
        this.privMediaSource.onsourceopen = () => {
          this.privMediaSourceOpened = true;
          this.privMediaSource.duration = MediaDurationPlaceholderSeconds;
          this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);
          this.privSourceBuffer.onupdate = () => {
            this.updateSourceBuffer().catch((reason) => {
              Exports_js_1$8.Events.instance.onEvent(new Exports_js_1$8.BackgroundEvent(reason));
            });
          };
          this.privSourceBuffer.onupdateend = () => {
            this.handleSourceBufferUpdateEnd().catch((reason) => {
              Exports_js_1$8.Events.instance.onEvent(new Exports_js_1$8.BackgroundEvent(reason));
            });
          };
          this.privSourceBuffer.onupdatestart = () => {
            this.privAppendingToBuffer = false;
          };
        };
        this.updateSourceBuffer().catch((reason) => {
          Exports_js_1$8.Events.instance.onEvent(new Exports_js_1$8.BackgroundEvent(reason));
        });
      } else {
        console.warn(`Format ${AudioStreamFormat_js_1.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);
        this.privAudioOutputStream = new AudioOutputStream_js_1$1.PullAudioOutputStreamImpl();
        this.privAudioOutputStream.format = this.privFormat;
        this.privAudio = new Audio();
      }
    }
  }
  get volume() {
    var _a2;
    return ((_a2 = this.privAudio) == null ? void 0 : _a2.volume) ?? -1;
  }
  set volume(volume) {
    if (!!this.privAudio) {
      this.privAudio.volume = volume;
    }
  }
  mute() {
    if (!!this.privAudio) {
      this.privAudio.muted = true;
    }
  }
  unmute() {
    if (!!this.privAudio) {
      this.privAudio.muted = false;
    }
  }
  get isClosed() {
    return this.privIsClosed;
  }
  get currentTime() {
    if (this.privAudio !== void 0) {
      return this.privAudio.currentTime;
    }
    return -1;
  }
  pause() {
    if (!this.privIsPaused && this.privAudio !== void 0) {
      this.privAudio.pause();
      this.privIsPaused = true;
    }
  }
  resume(cb2, err2) {
    if (this.privIsPaused && this.privAudio !== void 0) {
      this.privAudio.play().then(() => {
        if (!!cb2) {
          cb2();
        }
      }, (error) => {
        if (!!err2) {
          err2(error);
        }
      });
      this.privIsPaused = false;
    }
  }
  get internalAudio() {
    return this.privAudio;
  }
  async updateSourceBuffer() {
    if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
      this.privAppendingToBuffer = true;
      const binary = this.privAudioBuffer.shift();
      try {
        this.privSourceBuffer.appendBuffer(binary);
      } catch (error) {
        this.privAudioBuffer.unshift(binary);
        console.log("buffer filled, pausing addition of binaries until space is made");
        return;
      }
      await this.notifyPlayback();
    } else if (this.canEndStream()) {
      await this.handleSourceBufferUpdateEnd();
    }
  }
  async handleSourceBufferUpdateEnd() {
    if (this.canEndStream() && this.sourceBufferAvailable()) {
      this.privMediaSource.endOfStream();
      await this.notifyPlayback();
    }
  }
  async notifyPlayback() {
    if (!this.privPlaybackStarted && this.privAudio !== void 0) {
      this.privPlaybackStarted = true;
      if (!!this.onAudioStart) {
        this.onAudioStart(this);
      }
      this.privAudio.onended = () => {
        if (!!this.onAudioEnd) {
          this.onAudioEnd(this);
        }
      };
      if (!this.privIsPaused) {
        await this.privAudio.play();
      }
    }
  }
  canEndStream() {
    return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
  }
  sourceBufferAvailable() {
    return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
  }
}
SpeakerAudioDestination$1.SpeakerAudioDestination = SpeakerAudioDestination;
var ConversationTranscriptionCanceledEventArgs = {};
var hasRequiredConversationTranscriptionCanceledEventArgs;
function requireConversationTranscriptionCanceledEventArgs() {
  if (hasRequiredConversationTranscriptionCanceledEventArgs) return ConversationTranscriptionCanceledEventArgs;
  hasRequiredConversationTranscriptionCanceledEventArgs = 1;
  Object.defineProperty(ConversationTranscriptionCanceledEventArgs, "__esModule", { value: true });
  ConversationTranscriptionCanceledEventArgs.ConversationTranscriptionCanceledEventArgs = void 0;
  const CancellationEventArgsBase_js_1 = requireCancellationEventArgsBase();
  let ConversationTranscriptionCanceledEventArgs$1 = class ConversationTranscriptionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {
  };
  ConversationTranscriptionCanceledEventArgs.ConversationTranscriptionCanceledEventArgs = ConversationTranscriptionCanceledEventArgs$1;
  return ConversationTranscriptionCanceledEventArgs;
}
var MeetingTranscriptionCanceledEventArgs = {};
var hasRequiredMeetingTranscriptionCanceledEventArgs;
function requireMeetingTranscriptionCanceledEventArgs() {
  if (hasRequiredMeetingTranscriptionCanceledEventArgs) return MeetingTranscriptionCanceledEventArgs;
  hasRequiredMeetingTranscriptionCanceledEventArgs = 1;
  Object.defineProperty(MeetingTranscriptionCanceledEventArgs, "__esModule", { value: true });
  MeetingTranscriptionCanceledEventArgs.MeetingTranscriptionCanceledEventArgs = void 0;
  const CancellationEventArgsBase_js_1 = requireCancellationEventArgsBase();
  let MeetingTranscriptionCanceledEventArgs$12 = class MeetingTranscriptionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {
  };
  MeetingTranscriptionCanceledEventArgs.MeetingTranscriptionCanceledEventArgs = MeetingTranscriptionCanceledEventArgs$12;
  return MeetingTranscriptionCanceledEventArgs;
}
var PronunciationAssessmentGradingSystem = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PronunciationAssessmentGradingSystem = void 0;
  (function(PronunciationAssessmentGradingSystem2) {
    PronunciationAssessmentGradingSystem2[PronunciationAssessmentGradingSystem2["FivePoint"] = 1] = "FivePoint";
    PronunciationAssessmentGradingSystem2[PronunciationAssessmentGradingSystem2["HundredMark"] = 2] = "HundredMark";
  })(exports.PronunciationAssessmentGradingSystem || (exports.PronunciationAssessmentGradingSystem = {}));
})(PronunciationAssessmentGradingSystem);
var PronunciationAssessmentGranularity = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PronunciationAssessmentGranularity = void 0;
  (function(PronunciationAssessmentGranularity2) {
    PronunciationAssessmentGranularity2[PronunciationAssessmentGranularity2["Phoneme"] = 1] = "Phoneme";
    PronunciationAssessmentGranularity2[PronunciationAssessmentGranularity2["Word"] = 2] = "Word";
    PronunciationAssessmentGranularity2[PronunciationAssessmentGranularity2["FullText"] = 3] = "FullText";
  })(exports.PronunciationAssessmentGranularity || (exports.PronunciationAssessmentGranularity = {}));
})(PronunciationAssessmentGranularity);
var PronunciationAssessmentConfig = {};
var hasRequiredPronunciationAssessmentConfig;
function requirePronunciationAssessmentConfig() {
  if (hasRequiredPronunciationAssessmentConfig) return PronunciationAssessmentConfig;
  hasRequiredPronunciationAssessmentConfig = 1;
  Object.defineProperty(PronunciationAssessmentConfig, "__esModule", { value: true });
  PronunciationAssessmentConfig.PronunciationAssessmentConfig = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  let PronunciationAssessmentConfig$1 = class PronunciationAssessmentConfig2 {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(referenceText, gradingSystem = Exports_js_12.PronunciationAssessmentGradingSystem.FivePoint, granularity = Exports_js_12.PronunciationAssessmentGranularity.Phoneme, enableMiscue = false) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(referenceText, "referenceText");
      this.privProperties = new Exports_js_12.PropertyCollection();
      this.privProperties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_ReferenceText, referenceText);
      this.privProperties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_GradingSystem, Exports_js_12.PronunciationAssessmentGradingSystem[gradingSystem]);
      this.privProperties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_Granularity, Exports_js_12.PronunciationAssessmentGranularity[granularity]);
      this.privProperties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_EnableMiscue, String(enableMiscue));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(json) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(json, "json");
      const config = new PronunciationAssessmentConfig2("");
      config.privProperties = new Exports_js_12.PropertyCollection();
      config.properties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_Json, json);
      return config;
    }
    toJSON() {
      this.updateJson();
      return this.privProperties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(recognizer) {
      this.updateJson();
      const recoBase = recognizer.internalData;
      recoBase.expectContentAssessmentResponse = !!this.privContentAssessmentTopic;
      recoBase.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, recoBase.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(referenceText) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(referenceText, "referenceText");
      this.properties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_ReferenceText, referenceText);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(phonemeAlphabet) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(phonemeAlphabet, "phonemeAlphabet");
      this.privPhonemeAlphabet = phonemeAlphabet;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(enableMiscue) {
      const enableMiscueString = enableMiscue ? "true" : "false";
      this.properties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_EnableMiscue, enableMiscueString);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      const enableMiscueString = this.properties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_EnableMiscue, "false");
      return enableMiscueString.toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(nbestPhonemeCount) {
      this.privNBestPhonemeCount = nbestPhonemeCount;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(enableProsodyAssessment) {
      this.privEnableProsodyAssessment = enableProsodyAssessment;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(topic) {
      this.privContentAssessmentTopic = topic;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const jsonString = this.privProperties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_Json, "{}");
      const paramsJson = JSON.parse(jsonString);
      const referenceText = this.privProperties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_ReferenceText);
      if (referenceText) {
        paramsJson.referenceText = referenceText;
      }
      const gradingSystem = this.privProperties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_GradingSystem);
      if (gradingSystem) {
        paramsJson.gradingSystem = gradingSystem;
      }
      const granularity = this.privProperties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_Granularity);
      if (granularity) {
        paramsJson.granularity = granularity;
      }
      if (this.privPhonemeAlphabet) {
        paramsJson.phonemeAlphabet = this.privPhonemeAlphabet;
      }
      if (this.privNBestPhonemeCount) {
        paramsJson.nbestPhonemeCount = this.privNBestPhonemeCount;
      }
      paramsJson.enableProsodyAssessment = this.privEnableProsodyAssessment;
      paramsJson.dimension = "Comprehensive";
      const enableMiscueString = this.privProperties.getProperty(Exports_js_12.PropertyId.PronunciationAssessment_EnableMiscue);
      if (enableMiscueString) {
        paramsJson.enableMiscue = this.enableMiscue;
      }
      this.privProperties.setProperty(Exports_js_12.PropertyId.PronunciationAssessment_Params, JSON.stringify(paramsJson));
    }
  };
  PronunciationAssessmentConfig.PronunciationAssessmentConfig = PronunciationAssessmentConfig$1;
  return PronunciationAssessmentConfig;
}
var PronunciationAssessmentResult = {};
var hasRequiredPronunciationAssessmentResult;
function requirePronunciationAssessmentResult() {
  if (hasRequiredPronunciationAssessmentResult) return PronunciationAssessmentResult;
  hasRequiredPronunciationAssessmentResult = 1;
  Object.defineProperty(PronunciationAssessmentResult, "__esModule", { value: true });
  PronunciationAssessmentResult.PronunciationAssessmentResult = PronunciationAssessmentResult.ContentAssessmentResult = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  class ContentAssessmentResult {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(detailResult) {
      this.privPronJson = detailResult;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speakers ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  PronunciationAssessmentResult.ContentAssessmentResult = ContentAssessmentResult;
  let PronunciationAssessmentResult$1 = class PronunciationAssessmentResult2 {
    constructor(jsonString) {
      const j = JSON.parse(jsonString);
      Contracts_js_12.Contracts.throwIfNullOrUndefined(j.NBest[0], "NBest");
      this.privPronJson = j.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(result) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(result, "result");
      const json = result.properties.getProperty(Exports_js_12.PropertyId.SpeechServiceResponse_JsonResult);
      Contracts_js_12.Contracts.throwIfNullOrUndefined(json, "json");
      return new PronunciationAssessmentResult2(json);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      var _a2;
      return (_a2 = this.detailResult.PronunciationAssessment) == null ? void 0 : _a2.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      var _a2;
      return (_a2 = this.detailResult.PronunciationAssessment) == null ? void 0 : _a2.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      var _a2;
      return (_a2 = this.detailResult.PronunciationAssessment) == null ? void 0 : _a2.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      var _a2;
      return (_a2 = this.detailResult.PronunciationAssessment) == null ? void 0 : _a2.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      var _a2;
      return (_a2 = this.detailResult.PronunciationAssessment) == null ? void 0 : _a2.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment === void 0) {
        return void 0;
      }
      return new ContentAssessmentResult(this.detailResult);
    }
  };
  PronunciationAssessmentResult.PronunciationAssessmentResult = PronunciationAssessmentResult$1;
  return PronunciationAssessmentResult;
}
var AvatarConfig = {};
var hasRequiredAvatarConfig;
function requireAvatarConfig() {
  if (hasRequiredAvatarConfig) return AvatarConfig;
  hasRequiredAvatarConfig = 1;
  Object.defineProperty(AvatarConfig, "__esModule", { value: true });
  AvatarConfig.AvatarConfig = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports$3();
  let AvatarConfig$1 = class AvatarConfig {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(character, style, videoFormat) {
      this.privCustomized = false;
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(character, "character");
      this.character = character;
      this.style = style;
      if (videoFormat === void 0) {
        videoFormat = new Exports_js_12.AvatarVideoFormat();
      }
      this.videoFormat = videoFormat;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(value) {
      this.privCustomized = value;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(value) {
      this.privBackgroundColor = value;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(value) {
      this.privBackgroundImage = value;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(value) {
      this.privRemoteIceServers = value;
    }
  };
  AvatarConfig.AvatarConfig = AvatarConfig$1;
  return AvatarConfig;
}
var AvatarEventArgs = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AvatarEventArgs = exports.AvatarEventTypes = void 0;
  (function(AvatarEventTypes) {
    AvatarEventTypes["SwitchedToSpeaking"] = "SwitchedToSpeaking";
    AvatarEventTypes["SwitchedToIdle"] = "SwitchedToIdle";
    AvatarEventTypes["SessionClosed"] = "SessionClosed";
  })(exports.AvatarEventTypes || (exports.AvatarEventTypes = {}));
  class AvatarEventArgs2 {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} description - The description of the event.
     */
    constructor(audioOffset, description) {
      this.privOffset = audioOffset;
      this.privDescription = description;
    }
    /**
     * The type of the event.
     * @public
     * @returns {AvatarEventTypes} The type of the event.
     */
    get type() {
      return this.privType;
    }
    /**
     * The time offset associated with this event.
     * @public
     * @returns {number} The time offset associated with this event.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * The description of the event.
     * @public
     * @returns {string} The description of the event.
     */
    get description() {
      return this.privDescription;
    }
  }
  exports.AvatarEventArgs = AvatarEventArgs2;
})(AvatarEventArgs);
var AvatarSynthesizer = {};
var SpeechSynthesisConnectionFactory = {};
var hasRequiredSpeechSynthesisConnectionFactory;
function requireSpeechSynthesisConnectionFactory() {
  if (hasRequiredSpeechSynthesisConnectionFactory) return SpeechSynthesisConnectionFactory;
  hasRequiredSpeechSynthesisConnectionFactory = 1;
  Object.defineProperty(SpeechSynthesisConnectionFactory, "__esModule", { value: true });
  SpeechSynthesisConnectionFactory.SpeechSynthesisConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_3 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  let SpeechSynthesisConnectionFactory$1 = class SpeechSynthesisConnectionFactory {
    constructor() {
      this.synthesisUri = "/cognitiveservices/websocket/v1";
    }
    create(config, authInfo, connectionId) {
      let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, void 0);
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const endpointId = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, void 0);
      const hostPrefix = endpointId === void 0 ? "tts" : "voice";
      const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + "." + hostPrefix + ".speech" + hostSuffix);
      const queryParams = {};
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      if (endpointId !== void 0 && endpointId !== "") {
        if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.CustomVoiceDeploymentId) === -1) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomVoiceDeploymentId] = endpointId;
        }
      }
      if (config.avatarEnabled) {
        if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.EnableAvatar) === -1) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableAvatar] = "true";
        }
      }
      if (!endpoint) {
        endpoint = host + this.synthesisUri;
      }
      config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromParameters(config.parameters), enableCompression, connectionId);
    }
  };
  SpeechSynthesisConnectionFactory.SpeechSynthesisConnectionFactory = SpeechSynthesisConnectionFactory$1;
  return SpeechSynthesisConnectionFactory;
}
var hasRequiredAvatarSynthesizer;
function requireAvatarSynthesizer() {
  if (hasRequiredAvatarSynthesizer) return AvatarSynthesizer;
  hasRequiredAvatarSynthesizer = 1;
  Object.defineProperty(AvatarSynthesizer, "__esModule", { value: true });
  AvatarSynthesizer.AvatarSynthesizer = void 0;
  const SpeechSynthesisConnectionFactory_js_1 = requireSpeechSynthesisConnectionFactory();
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const AudioOutputFormat_js_12 = AudioOutputFormat;
  const Exports_js_3 = requireExports$3();
  const Contracts_js_12 = Contracts$1;
  const Synthesizer_js_1 = requireSynthesizer();
  let AvatarSynthesizer$1 = class AvatarSynthesizer extends Exports_js_3.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(speechConfig, avatarConfig) {
      super(speechConfig);
      Contracts_js_12.Contracts.throwIfNullOrUndefined(avatarConfig, "avatarConfig");
      this.privConnectionFactory = new SpeechSynthesisConnectionFactory_js_1.SpeechSynthesisConnectionFactory();
      this.privAvatarConfig = avatarConfig;
      this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup();
      this.privAdapter.audioOutputFormat = AudioOutputFormat_js_12.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(Exports_js_3.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(peerConnection) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(peerConnection, "peerConnection");
      this.privIceServers = peerConnection.getConfiguration().iceServers;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const iceGatheringDone = new Exports_js_2.Deferred();
      peerConnection.onicegatheringstatechange = () => {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice gathering state: " + peerConnection.iceGatheringState, Exports_js_2.EventType.Debug));
        if (peerConnection.iceGatheringState === "complete") {
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice gathering complete.", Exports_js_2.EventType.Info));
          iceGatheringDone.resolve();
        }
      };
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice candidate: " + event.candidate.candidate, Exports_js_2.EventType.Debug));
        } else {
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice candidate: complete", Exports_js_2.EventType.Debug));
          iceGatheringDone.resolve();
        }
      };
      setTimeout(() => {
        if (peerConnection.iceGatheringState !== "complete") {
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice gathering timeout.", Exports_js_2.EventType.Warning));
          iceGatheringDone.resolve();
        }
      }, 2e3);
      const sdp = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(sdp);
      await iceGatheringDone.promise;
      Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: got local SDP.", Exports_js_2.EventType.Info));
      this.privProperties.setProperty(Exports_js_3.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(peerConnection.localDescription));
      const result = await this.speak("", false);
      if (result.reason !== Exports_js_3.ResultReason.SynthesizingAudioCompleted) {
        return new Exports_js_3.SynthesisResult(result.resultId, result.reason, result.errorDetails, result.properties);
      }
      const sdpAnswerString = atob(result.properties.getProperty(Exports_js_3.PropertyId.TalkingAvatarService_WebRTC_SDP));
      const sdpAnswer = new RTCSessionDescription(JSON.parse(sdpAnswerString));
      await peerConnection.setRemoteDescription(sdpAnswer);
      return new Exports_js_3.SynthesisResult(result.resultId, result.reason, void 0, result.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(text2) {
      const r2 = await this.speak(text2, false);
      return new Exports_js_3.SynthesisResult(r2.resultId, r2.reason, r2.errorDetails, r2.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(ssml) {
      const r2 = await this.speak(ssml, true);
      return new Exports_js_3.SynthesisResult(r2.resultId, r2.reason, r2.errorDetails, r2.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      while (this.synthesisRequestQueue.length() > 0) {
        const request = await this.synthesisRequestQueue.dequeue();
        request.err("Synthesis is canceled by user.");
      }
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposed);
      return this.dispose(true);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (this.privDisposed) {
        return;
      }
      return this.dispose(true);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(authentication, connectionFactory, synthesizerConfig) {
      return new Exports_js_12.AvatarSynthesisAdapter(authentication, connectionFactory, synthesizerConfig, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(_authentication, _synthesizerConfig) {
      return void 0;
    }
    createSynthesizerConfig(speechConfig) {
      const config = super.createSynthesizerConfig(speechConfig);
      config.avatarEnabled = true;
      return config;
    }
    async speak(text2, isSSML) {
      const requestId = Exports_js_2.createNoDashGuid();
      const deferredResult = new Exports_js_2.Deferred();
      this.synthesisRequestQueue.enqueue(new Synthesizer_js_1.SynthesisRequest(requestId, text2, isSSML, (e) => {
        deferredResult.resolve(e);
        this.privSynthesizing = false;
        void this.adapterSpeak();
      }, (e) => {
        deferredResult.reject(e);
        this.privSynthesizing = false;
      }));
      void this.adapterSpeak();
      return deferredResult.promise;
    }
  };
  AvatarSynthesizer.AvatarSynthesizer = AvatarSynthesizer$1;
  return AvatarSynthesizer;
}
var AvatarVideoFormat$1 = {};
Object.defineProperty(AvatarVideoFormat$1, "__esModule", { value: true });
AvatarVideoFormat$1.AvatarVideoFormat = AvatarVideoFormat$1.Coordinate = void 0;
class Coordinate {
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
}
AvatarVideoFormat$1.Coordinate = Coordinate;
class AvatarVideoFormat {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} codec - The video codec.
   * @param {number} bitrate - The video bitrate.
   * @param {number} width - The video width.
   * @param {number} height - The video height.
   */
  constructor(codec = "H264", bitrate = 2e6, width = 1920, height = 1080) {
    this.codec = codec;
    this.bitrate = bitrate;
    this.width = width;
    this.height = height;
  }
  /**
   * Sets the video crop range.
   */
  setCropRange(topLeft, bottomRight) {
    this.cropRange = {
      bottomRight,
      topLeft
    };
  }
}
AvatarVideoFormat$1.AvatarVideoFormat = AvatarVideoFormat;
var AvatarWebRTCConnectionResult = {};
var hasRequiredAvatarWebRTCConnectionResult;
function requireAvatarWebRTCConnectionResult() {
  if (hasRequiredAvatarWebRTCConnectionResult) return AvatarWebRTCConnectionResult;
  hasRequiredAvatarWebRTCConnectionResult = 1;
  Object.defineProperty(AvatarWebRTCConnectionResult, "__esModule", { value: true });
  AvatarWebRTCConnectionResult.AvatarWebRTCConnectionResult = void 0;
  const Exports_js_12 = requireExports$3();
  let AvatarWebRTCConnectionResult$1 = class AvatarWebRTCConnectionResult extends Exports_js_12.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(SDPAnswer, resultId, reason, errorDetails, properties) {
      super(resultId, reason, errorDetails, properties);
      this.privSDPAnswer = SDPAnswer;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  AvatarWebRTCConnectionResult.AvatarWebRTCConnectionResult = AvatarWebRTCConnectionResult$1;
  return AvatarWebRTCConnectionResult;
}
var Diagnostics = {};
var hasRequiredDiagnostics;
function requireDiagnostics() {
  if (hasRequiredDiagnostics) return Diagnostics;
  hasRequiredDiagnostics = 1;
  Object.defineProperty(Diagnostics, "__esModule", { value: true });
  Diagnostics.Diagnostics = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$5();
  let Diagnostics$1 = class Diagnostics {
    static SetLoggingLevel(logLevel) {
      this.privListener = new Exports_js_12.ConsoleLoggingListener(logLevel);
      Exports_js_2.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      if (!!this.privListener) {
        this.privListener.enableConsoleOutput = true;
      }
    }
    static StopConsoleOutput() {
      if (!!this.privListener) {
        this.privListener.enableConsoleOutput = false;
      }
    }
    static SetLogOutputPath(path) {
      if (typeof window === "undefined") {
        if (!!this.privListener) {
          this.privListener.logPath = path;
        }
      } else {
        throw new Error("File system logging not available in browser.");
      }
    }
    static set onLogOutput(callback) {
      if (!!this.privListener) {
        this.privListener.logCallback = callback;
      }
    }
  };
  Diagnostics.Diagnostics = Diagnostics$1;
  Diagnostics$1.privListener = void 0;
  return Diagnostics;
}
var hasRequiredExports$3;
function requireExports$3() {
  if (hasRequiredExports$3) return Exports$3;
  hasRequiredExports$3 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var AudioConfig_js_1 = requireAudioConfig();
    Object.defineProperty(exports, "AudioConfig", { enumerable: true, get: function() {
      return AudioConfig_js_1.AudioConfig;
    } });
    var AudioStreamFormat_js_12 = AudioStreamFormat;
    Object.defineProperty(exports, "AudioStreamFormat", { enumerable: true, get: function() {
      return AudioStreamFormat_js_12.AudioStreamFormat;
    } });
    Object.defineProperty(exports, "AudioFormatTag", { enumerable: true, get: function() {
      return AudioStreamFormat_js_12.AudioFormatTag;
    } });
    var AudioInputStream_js_1 = requireAudioInputStream();
    Object.defineProperty(exports, "AudioInputStream", { enumerable: true, get: function() {
      return AudioInputStream_js_1.AudioInputStream;
    } });
    Object.defineProperty(exports, "PullAudioInputStream", { enumerable: true, get: function() {
      return AudioInputStream_js_1.PullAudioInputStream;
    } });
    Object.defineProperty(exports, "PushAudioInputStream", { enumerable: true, get: function() {
      return AudioInputStream_js_1.PushAudioInputStream;
    } });
    var AudioOutputStream_js_12 = AudioOutputStream$1;
    Object.defineProperty(exports, "AudioOutputStream", { enumerable: true, get: function() {
      return AudioOutputStream_js_12.AudioOutputStream;
    } });
    Object.defineProperty(exports, "PullAudioOutputStream", { enumerable: true, get: function() {
      return AudioOutputStream_js_12.PullAudioOutputStream;
    } });
    Object.defineProperty(exports, "PushAudioOutputStream", { enumerable: true, get: function() {
      return AudioOutputStream_js_12.PushAudioOutputStream;
    } });
    var CancellationReason_js_1 = CancellationReason;
    Object.defineProperty(exports, "CancellationReason", { enumerable: true, get: function() {
      return CancellationReason_js_1.CancellationReason;
    } });
    var PullAudioInputStreamCallback_js_1 = PullAudioInputStreamCallback$1;
    Object.defineProperty(exports, "PullAudioInputStreamCallback", { enumerable: true, get: function() {
      return PullAudioInputStreamCallback_js_1.PullAudioInputStreamCallback;
    } });
    var PushAudioOutputStreamCallback_js_1 = PushAudioOutputStreamCallback$1;
    Object.defineProperty(exports, "PushAudioOutputStreamCallback", { enumerable: true, get: function() {
      return PushAudioOutputStreamCallback_js_1.PushAudioOutputStreamCallback;
    } });
    var KeywordRecognitionModel_js_1 = KeywordRecognitionModel$1;
    Object.defineProperty(exports, "KeywordRecognitionModel", { enumerable: true, get: function() {
      return KeywordRecognitionModel_js_1.KeywordRecognitionModel;
    } });
    var SessionEventArgs_js_1 = SessionEventArgs$1;
    Object.defineProperty(exports, "SessionEventArgs", { enumerable: true, get: function() {
      return SessionEventArgs_js_1.SessionEventArgs;
    } });
    var RecognitionEventArgs_js_1 = requireRecognitionEventArgs();
    Object.defineProperty(exports, "RecognitionEventArgs", { enumerable: true, get: function() {
      return RecognitionEventArgs_js_1.RecognitionEventArgs;
    } });
    var OutputFormat_js_1 = OutputFormat;
    Object.defineProperty(exports, "OutputFormat", { enumerable: true, get: function() {
      return OutputFormat_js_1.OutputFormat;
    } });
    var IntentRecognitionEventArgs_js_1 = requireIntentRecognitionEventArgs();
    Object.defineProperty(exports, "IntentRecognitionEventArgs", { enumerable: true, get: function() {
      return IntentRecognitionEventArgs_js_1.IntentRecognitionEventArgs;
    } });
    var RecognitionResult_js_1 = RecognitionResult$1;
    Object.defineProperty(exports, "RecognitionResult", { enumerable: true, get: function() {
      return RecognitionResult_js_1.RecognitionResult;
    } });
    var SpeechRecognitionResult_js_1 = requireSpeechRecognitionResult();
    Object.defineProperty(exports, "SpeechRecognitionResult", { enumerable: true, get: function() {
      return SpeechRecognitionResult_js_1.SpeechRecognitionResult;
    } });
    var IntentRecognitionResult_js_1 = requireIntentRecognitionResult();
    Object.defineProperty(exports, "IntentRecognitionResult", { enumerable: true, get: function() {
      return IntentRecognitionResult_js_1.IntentRecognitionResult;
    } });
    var LanguageUnderstandingModel_js_1 = LanguageUnderstandingModel$1;
    Object.defineProperty(exports, "LanguageUnderstandingModel", { enumerable: true, get: function() {
      return LanguageUnderstandingModel_js_1.LanguageUnderstandingModel;
    } });
    var SpeechRecognitionEventArgs_js_1 = requireSpeechRecognitionEventArgs();
    Object.defineProperty(exports, "SpeechRecognitionEventArgs", { enumerable: true, get: function() {
      return SpeechRecognitionEventArgs_js_1.SpeechRecognitionEventArgs;
    } });
    Object.defineProperty(exports, "ConversationTranscriptionEventArgs", { enumerable: true, get: function() {
      return SpeechRecognitionEventArgs_js_1.ConversationTranscriptionEventArgs;
    } });
    Object.defineProperty(exports, "MeetingTranscriptionEventArgs", { enumerable: true, get: function() {
      return SpeechRecognitionEventArgs_js_1.MeetingTranscriptionEventArgs;
    } });
    var SpeechRecognitionCanceledEventArgs_js_1 = requireSpeechRecognitionCanceledEventArgs();
    Object.defineProperty(exports, "SpeechRecognitionCanceledEventArgs", { enumerable: true, get: function() {
      return SpeechRecognitionCanceledEventArgs_js_1.SpeechRecognitionCanceledEventArgs;
    } });
    var TranslationRecognitionEventArgs_js_1 = requireTranslationRecognitionEventArgs();
    Object.defineProperty(exports, "TranslationRecognitionEventArgs", { enumerable: true, get: function() {
      return TranslationRecognitionEventArgs_js_1.TranslationRecognitionEventArgs;
    } });
    var TranslationSynthesisEventArgs_js_1 = requireTranslationSynthesisEventArgs();
    Object.defineProperty(exports, "TranslationSynthesisEventArgs", { enumerable: true, get: function() {
      return TranslationSynthesisEventArgs_js_1.TranslationSynthesisEventArgs;
    } });
    var TranslationRecognitionResult_js_1 = requireTranslationRecognitionResult();
    Object.defineProperty(exports, "TranslationRecognitionResult", { enumerable: true, get: function() {
      return TranslationRecognitionResult_js_1.TranslationRecognitionResult;
    } });
    var TranslationSynthesisResult_js_1 = TranslationSynthesisResult$1;
    Object.defineProperty(exports, "TranslationSynthesisResult", { enumerable: true, get: function() {
      return TranslationSynthesisResult_js_1.TranslationSynthesisResult;
    } });
    var ResultReason_js_1 = ResultReason;
    Object.defineProperty(exports, "ResultReason", { enumerable: true, get: function() {
      return ResultReason_js_1.ResultReason;
    } });
    var SpeechConfig_js_1 = requireSpeechConfig();
    Object.defineProperty(exports, "SpeechConfig", { enumerable: true, get: function() {
      return SpeechConfig_js_1.SpeechConfig;
    } });
    Object.defineProperty(exports, "SpeechConfigImpl", { enumerable: true, get: function() {
      return SpeechConfig_js_1.SpeechConfigImpl;
    } });
    var SpeechTranslationConfig_js_1 = requireSpeechTranslationConfig();
    Object.defineProperty(exports, "SpeechTranslationConfig", { enumerable: true, get: function() {
      return SpeechTranslationConfig_js_1.SpeechTranslationConfig;
    } });
    Object.defineProperty(exports, "SpeechTranslationConfigImpl", { enumerable: true, get: function() {
      return SpeechTranslationConfig_js_1.SpeechTranslationConfigImpl;
    } });
    var PropertyCollection_js_1 = requirePropertyCollection();
    Object.defineProperty(exports, "PropertyCollection", { enumerable: true, get: function() {
      return PropertyCollection_js_1.PropertyCollection;
    } });
    var PropertyId_js_1 = PropertyId;
    Object.defineProperty(exports, "PropertyId", { enumerable: true, get: function() {
      return PropertyId_js_1.PropertyId;
    } });
    var Recognizer_js_1 = requireRecognizer();
    Object.defineProperty(exports, "Recognizer", { enumerable: true, get: function() {
      return Recognizer_js_1.Recognizer;
    } });
    var SpeechRecognizer_js_1 = requireSpeechRecognizer();
    Object.defineProperty(exports, "SpeechRecognizer", { enumerable: true, get: function() {
      return SpeechRecognizer_js_1.SpeechRecognizer;
    } });
    var IntentRecognizer_js_1 = requireIntentRecognizer();
    Object.defineProperty(exports, "IntentRecognizer", { enumerable: true, get: function() {
      return IntentRecognizer_js_1.IntentRecognizer;
    } });
    var VoiceProfileType_js_1 = VoiceProfileType;
    Object.defineProperty(exports, "VoiceProfileType", { enumerable: true, get: function() {
      return VoiceProfileType_js_1.VoiceProfileType;
    } });
    var TranslationRecognizer_js_1 = requireTranslationRecognizer();
    Object.defineProperty(exports, "TranslationRecognizer", { enumerable: true, get: function() {
      return TranslationRecognizer_js_1.TranslationRecognizer;
    } });
    var Translations_js_1 = requireTranslations();
    Object.defineProperty(exports, "Translations", { enumerable: true, get: function() {
      return Translations_js_1.Translations;
    } });
    var NoMatchReason_js_1 = NoMatchReason;
    Object.defineProperty(exports, "NoMatchReason", { enumerable: true, get: function() {
      return NoMatchReason_js_1.NoMatchReason;
    } });
    var NoMatchDetails_js_1 = requireNoMatchDetails();
    Object.defineProperty(exports, "NoMatchDetails", { enumerable: true, get: function() {
      return NoMatchDetails_js_1.NoMatchDetails;
    } });
    var TranslationRecognitionCanceledEventArgs_js_1 = TranslationRecognitionCanceledEventArgs$1;
    Object.defineProperty(exports, "TranslationRecognitionCanceledEventArgs", { enumerable: true, get: function() {
      return TranslationRecognitionCanceledEventArgs_js_1.TranslationRecognitionCanceledEventArgs;
    } });
    var IntentRecognitionCanceledEventArgs_js_1 = requireIntentRecognitionCanceledEventArgs();
    Object.defineProperty(exports, "IntentRecognitionCanceledEventArgs", { enumerable: true, get: function() {
      return IntentRecognitionCanceledEventArgs_js_1.IntentRecognitionCanceledEventArgs;
    } });
    var CancellationDetailsBase_js_1 = CancellationDetailsBase$1;
    Object.defineProperty(exports, "CancellationDetailsBase", { enumerable: true, get: function() {
      return CancellationDetailsBase_js_1.CancellationDetailsBase;
    } });
    var CancellationDetails_js_1 = requireCancellationDetails();
    Object.defineProperty(exports, "CancellationDetails", { enumerable: true, get: function() {
      return CancellationDetails_js_1.CancellationDetails;
    } });
    var CancellationErrorCodes_js_1 = CancellationErrorCodes;
    Object.defineProperty(exports, "CancellationErrorCode", { enumerable: true, get: function() {
      return CancellationErrorCodes_js_1.CancellationErrorCode;
    } });
    var ConnectionEventArgs_js_1 = requireConnectionEventArgs();
    Object.defineProperty(exports, "ConnectionEventArgs", { enumerable: true, get: function() {
      return ConnectionEventArgs_js_1.ConnectionEventArgs;
    } });
    var ServiceEventArgs_js_1 = requireServiceEventArgs();
    Object.defineProperty(exports, "ServiceEventArgs", { enumerable: true, get: function() {
      return ServiceEventArgs_js_1.ServiceEventArgs;
    } });
    var Connection_js_1 = requireConnection();
    Object.defineProperty(exports, "Connection", { enumerable: true, get: function() {
      return Connection_js_1.Connection;
    } });
    var PhraseListGrammar_js_1 = PhraseListGrammar$1;
    Object.defineProperty(exports, "PhraseListGrammar", { enumerable: true, get: function() {
      return PhraseListGrammar_js_1.PhraseListGrammar;
    } });
    var DialogServiceConfig_js_1 = requireDialogServiceConfig();
    Object.defineProperty(exports, "DialogServiceConfig", { enumerable: true, get: function() {
      return DialogServiceConfig_js_1.DialogServiceConfig;
    } });
    var BotFrameworkConfig_js_1 = requireBotFrameworkConfig();
    Object.defineProperty(exports, "BotFrameworkConfig", { enumerable: true, get: function() {
      return BotFrameworkConfig_js_1.BotFrameworkConfig;
    } });
    var CustomCommandsConfig_js_1 = requireCustomCommandsConfig();
    Object.defineProperty(exports, "CustomCommandsConfig", { enumerable: true, get: function() {
      return CustomCommandsConfig_js_1.CustomCommandsConfig;
    } });
    var DialogServiceConnector_js_1 = requireDialogServiceConnector();
    Object.defineProperty(exports, "DialogServiceConnector", { enumerable: true, get: function() {
      return DialogServiceConnector_js_1.DialogServiceConnector;
    } });
    var ActivityReceivedEventArgs_js_1 = ActivityReceivedEventArgs$1;
    Object.defineProperty(exports, "ActivityReceivedEventArgs", { enumerable: true, get: function() {
      return ActivityReceivedEventArgs_js_1.ActivityReceivedEventArgs;
    } });
    var TurnStatusReceivedEventArgs_js_1 = TurnStatusReceivedEventArgs$1;
    Object.defineProperty(exports, "TurnStatusReceivedEventArgs", { enumerable: true, get: function() {
      return TurnStatusReceivedEventArgs_js_1.TurnStatusReceivedEventArgs;
    } });
    var ServicePropertyChannel_js_1 = ServicePropertyChannel;
    Object.defineProperty(exports, "ServicePropertyChannel", { enumerable: true, get: function() {
      return ServicePropertyChannel_js_1.ServicePropertyChannel;
    } });
    var ProfanityOption_js_1 = ProfanityOption;
    Object.defineProperty(exports, "ProfanityOption", { enumerable: true, get: function() {
      return ProfanityOption_js_1.ProfanityOption;
    } });
    var BaseAudioPlayer_js_1 = requireBaseAudioPlayer();
    Object.defineProperty(exports, "BaseAudioPlayer", { enumerable: true, get: function() {
      return BaseAudioPlayer_js_1.BaseAudioPlayer;
    } });
    var ConnectionMessageEventArgs_js_1 = ConnectionMessageEventArgs$1;
    Object.defineProperty(exports, "ConnectionMessageEventArgs", { enumerable: true, get: function() {
      return ConnectionMessageEventArgs_js_1.ConnectionMessageEventArgs;
    } });
    var ConnectionMessage_js_12 = requireConnectionMessage();
    Object.defineProperty(exports, "ConnectionMessage", { enumerable: true, get: function() {
      return ConnectionMessage_js_12.ConnectionMessage;
    } });
    var VoiceProfile_js_1 = VoiceProfile$1;
    Object.defineProperty(exports, "VoiceProfile", { enumerable: true, get: function() {
      return VoiceProfile_js_1.VoiceProfile;
    } });
    var VoiceProfileEnrollmentResult_js_1 = requireVoiceProfileEnrollmentResult();
    Object.defineProperty(exports, "VoiceProfileEnrollmentResult", { enumerable: true, get: function() {
      return VoiceProfileEnrollmentResult_js_1.VoiceProfileEnrollmentResult;
    } });
    Object.defineProperty(exports, "VoiceProfileEnrollmentCancellationDetails", { enumerable: true, get: function() {
      return VoiceProfileEnrollmentResult_js_1.VoiceProfileEnrollmentCancellationDetails;
    } });
    var VoiceProfileResult_js_1 = requireVoiceProfileResult();
    Object.defineProperty(exports, "VoiceProfileResult", { enumerable: true, get: function() {
      return VoiceProfileResult_js_1.VoiceProfileResult;
    } });
    Object.defineProperty(exports, "VoiceProfileCancellationDetails", { enumerable: true, get: function() {
      return VoiceProfileResult_js_1.VoiceProfileCancellationDetails;
    } });
    var VoiceProfilePhraseResult_js_1 = requireVoiceProfilePhraseResult();
    Object.defineProperty(exports, "VoiceProfilePhraseResult", { enumerable: true, get: function() {
      return VoiceProfilePhraseResult_js_1.VoiceProfilePhraseResult;
    } });
    var VoiceProfileClient_js_1 = requireVoiceProfileClient();
    Object.defineProperty(exports, "VoiceProfileClient", { enumerable: true, get: function() {
      return VoiceProfileClient_js_1.VoiceProfileClient;
    } });
    var SpeakerRecognizer_js_1 = requireSpeakerRecognizer();
    Object.defineProperty(exports, "SpeakerRecognizer", { enumerable: true, get: function() {
      return SpeakerRecognizer_js_1.SpeakerRecognizer;
    } });
    var SpeakerIdentificationModel_js_1 = requireSpeakerIdentificationModel();
    Object.defineProperty(exports, "SpeakerIdentificationModel", { enumerable: true, get: function() {
      return SpeakerIdentificationModel_js_1.SpeakerIdentificationModel;
    } });
    var SpeakerVerificationModel_js_1 = requireSpeakerVerificationModel();
    Object.defineProperty(exports, "SpeakerVerificationModel", { enumerable: true, get: function() {
      return SpeakerVerificationModel_js_1.SpeakerVerificationModel;
    } });
    var AutoDetectSourceLanguageConfig_js_1 = requireAutoDetectSourceLanguageConfig();
    Object.defineProperty(exports, "AutoDetectSourceLanguageConfig", { enumerable: true, get: function() {
      return AutoDetectSourceLanguageConfig_js_1.AutoDetectSourceLanguageConfig;
    } });
    var AutoDetectSourceLanguageResult_js_1 = AutoDetectSourceLanguageResult$1;
    Object.defineProperty(exports, "AutoDetectSourceLanguageResult", { enumerable: true, get: function() {
      return AutoDetectSourceLanguageResult_js_1.AutoDetectSourceLanguageResult;
    } });
    var SourceLanguageConfig_js_1 = SourceLanguageConfig$1;
    Object.defineProperty(exports, "SourceLanguageConfig", { enumerable: true, get: function() {
      return SourceLanguageConfig_js_1.SourceLanguageConfig;
    } });
    var SpeakerRecognitionResult_js_1 = requireSpeakerRecognitionResult();
    Object.defineProperty(exports, "SpeakerRecognitionResult", { enumerable: true, get: function() {
      return SpeakerRecognitionResult_js_1.SpeakerRecognitionResult;
    } });
    Object.defineProperty(exports, "SpeakerRecognitionResultType", { enumerable: true, get: function() {
      return SpeakerRecognitionResult_js_1.SpeakerRecognitionResultType;
    } });
    Object.defineProperty(exports, "SpeakerRecognitionCancellationDetails", { enumerable: true, get: function() {
      return SpeakerRecognitionResult_js_1.SpeakerRecognitionCancellationDetails;
    } });
    var Exports_js_12 = requireExports$4();
    Object.defineProperty(exports, "Conversation", { enumerable: true, get: function() {
      return Exports_js_12.Conversation;
    } });
    Object.defineProperty(exports, "ConversationExpirationEventArgs", { enumerable: true, get: function() {
      return Exports_js_12.ConversationExpirationEventArgs;
    } });
    Object.defineProperty(exports, "ConversationParticipantsChangedEventArgs", { enumerable: true, get: function() {
      return Exports_js_12.ConversationParticipantsChangedEventArgs;
    } });
    Object.defineProperty(exports, "ConversationTranslationCanceledEventArgs", { enumerable: true, get: function() {
      return Exports_js_12.ConversationTranslationCanceledEventArgs;
    } });
    Object.defineProperty(exports, "ConversationTranslationEventArgs", { enumerable: true, get: function() {
      return Exports_js_12.ConversationTranslationEventArgs;
    } });
    Object.defineProperty(exports, "ConversationTranslationResult", { enumerable: true, get: function() {
      return Exports_js_12.ConversationTranslationResult;
    } });
    Object.defineProperty(exports, "ConversationTranslator", { enumerable: true, get: function() {
      return Exports_js_12.ConversationTranslator;
    } });
    Object.defineProperty(exports, "ConversationTranscriber", { enumerable: true, get: function() {
      return Exports_js_12.ConversationTranscriber;
    } });
    Object.defineProperty(exports, "ConversationTranscriptionResult", { enumerable: true, get: function() {
      return Exports_js_12.ConversationTranscriptionResult;
    } });
    Object.defineProperty(exports, "Meeting", { enumerable: true, get: function() {
      return Exports_js_12.Meeting;
    } });
    Object.defineProperty(exports, "MeetingTranscriber", { enumerable: true, get: function() {
      return Exports_js_12.MeetingTranscriber;
    } });
    Object.defineProperty(exports, "Participant", { enumerable: true, get: function() {
      return Exports_js_12.Participant;
    } });
    Object.defineProperty(exports, "ParticipantChangedReason", { enumerable: true, get: function() {
      return Exports_js_12.ParticipantChangedReason;
    } });
    Object.defineProperty(exports, "User", { enumerable: true, get: function() {
      return Exports_js_12.User;
    } });
    var Synthesizer_js_1 = requireSynthesizer();
    Object.defineProperty(exports, "Synthesizer", { enumerable: true, get: function() {
      return Synthesizer_js_1.Synthesizer;
    } });
    var SpeechSynthesisOutputFormat_js_12 = SpeechSynthesisOutputFormat;
    Object.defineProperty(exports, "SpeechSynthesisOutputFormat", { enumerable: true, get: function() {
      return SpeechSynthesisOutputFormat_js_12.SpeechSynthesisOutputFormat;
    } });
    var SpeechSynthesizer_js_1 = requireSpeechSynthesizer();
    Object.defineProperty(exports, "SpeechSynthesizer", { enumerable: true, get: function() {
      return SpeechSynthesizer_js_1.SpeechSynthesizer;
    } });
    var SynthesisResult_js_1 = SynthesisResult$1;
    Object.defineProperty(exports, "SynthesisResult", { enumerable: true, get: function() {
      return SynthesisResult_js_1.SynthesisResult;
    } });
    var SpeechSynthesisResult_js_1 = requireSpeechSynthesisResult();
    Object.defineProperty(exports, "SpeechSynthesisResult", { enumerable: true, get: function() {
      return SpeechSynthesisResult_js_1.SpeechSynthesisResult;
    } });
    var SpeechSynthesisEventArgs_js_1 = SpeechSynthesisEventArgs$1;
    Object.defineProperty(exports, "SpeechSynthesisEventArgs", { enumerable: true, get: function() {
      return SpeechSynthesisEventArgs_js_1.SpeechSynthesisEventArgs;
    } });
    var SpeechSynthesisWordBoundaryEventArgs_js_1 = SpeechSynthesisWordBoundaryEventArgs$1;
    Object.defineProperty(exports, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: true, get: function() {
      return SpeechSynthesisWordBoundaryEventArgs_js_1.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var SpeechSynthesisBookmarkEventArgs_js_1 = SpeechSynthesisBookmarkEventArgs$1;
    Object.defineProperty(exports, "SpeechSynthesisBookmarkEventArgs", { enumerable: true, get: function() {
      return SpeechSynthesisBookmarkEventArgs_js_1.SpeechSynthesisBookmarkEventArgs;
    } });
    var SpeechSynthesisVisemeEventArgs_js_1 = SpeechSynthesisVisemeEventArgs$1;
    Object.defineProperty(exports, "SpeechSynthesisVisemeEventArgs", { enumerable: true, get: function() {
      return SpeechSynthesisVisemeEventArgs_js_1.SpeechSynthesisVisemeEventArgs;
    } });
    var SpeechSynthesisBoundaryType_js_1 = SpeechSynthesisBoundaryType;
    Object.defineProperty(exports, "SpeechSynthesisBoundaryType", { enumerable: true, get: function() {
      return SpeechSynthesisBoundaryType_js_1.SpeechSynthesisBoundaryType;
    } });
    var SynthesisVoicesResult_js_1 = requireSynthesisVoicesResult();
    Object.defineProperty(exports, "SynthesisVoicesResult", { enumerable: true, get: function() {
      return SynthesisVoicesResult_js_1.SynthesisVoicesResult;
    } });
    var VoiceInfo_js_1 = VoiceInfo;
    Object.defineProperty(exports, "VoiceInfo", { enumerable: true, get: function() {
      return VoiceInfo_js_1.VoiceInfo;
    } });
    var SpeakerAudioDestination_js_1 = SpeakerAudioDestination$1;
    Object.defineProperty(exports, "SpeakerAudioDestination", { enumerable: true, get: function() {
      return SpeakerAudioDestination_js_1.SpeakerAudioDestination;
    } });
    var ConversationTranscriptionCanceledEventArgs_js_1 = requireConversationTranscriptionCanceledEventArgs();
    Object.defineProperty(exports, "ConversationTranscriptionCanceledEventArgs", { enumerable: true, get: function() {
      return ConversationTranscriptionCanceledEventArgs_js_1.ConversationTranscriptionCanceledEventArgs;
    } });
    var MeetingTranscriptionCanceledEventArgs_js_1 = requireMeetingTranscriptionCanceledEventArgs();
    Object.defineProperty(exports, "MeetingTranscriptionCanceledEventArgs", { enumerable: true, get: function() {
      return MeetingTranscriptionCanceledEventArgs_js_1.MeetingTranscriptionCanceledEventArgs;
    } });
    var PronunciationAssessmentGradingSystem_js_1 = PronunciationAssessmentGradingSystem;
    Object.defineProperty(exports, "PronunciationAssessmentGradingSystem", { enumerable: true, get: function() {
      return PronunciationAssessmentGradingSystem_js_1.PronunciationAssessmentGradingSystem;
    } });
    var PronunciationAssessmentGranularity_js_1 = PronunciationAssessmentGranularity;
    Object.defineProperty(exports, "PronunciationAssessmentGranularity", { enumerable: true, get: function() {
      return PronunciationAssessmentGranularity_js_1.PronunciationAssessmentGranularity;
    } });
    var PronunciationAssessmentConfig_js_1 = requirePronunciationAssessmentConfig();
    Object.defineProperty(exports, "PronunciationAssessmentConfig", { enumerable: true, get: function() {
      return PronunciationAssessmentConfig_js_1.PronunciationAssessmentConfig;
    } });
    var PronunciationAssessmentResult_js_1 = requirePronunciationAssessmentResult();
    Object.defineProperty(exports, "PronunciationAssessmentResult", { enumerable: true, get: function() {
      return PronunciationAssessmentResult_js_1.PronunciationAssessmentResult;
    } });
    var LanguageIdMode_js_1 = LanguageIdMode;
    Object.defineProperty(exports, "LanguageIdMode", { enumerable: true, get: function() {
      return LanguageIdMode_js_1.LanguageIdMode;
    } });
    var AvatarConfig_js_1 = requireAvatarConfig();
    Object.defineProperty(exports, "AvatarConfig", { enumerable: true, get: function() {
      return AvatarConfig_js_1.AvatarConfig;
    } });
    var AvatarEventArgs_js_1 = AvatarEventArgs;
    Object.defineProperty(exports, "AvatarEventArgs", { enumerable: true, get: function() {
      return AvatarEventArgs_js_1.AvatarEventArgs;
    } });
    var AvatarSynthesizer_js_1 = requireAvatarSynthesizer();
    Object.defineProperty(exports, "AvatarSynthesizer", { enumerable: true, get: function() {
      return AvatarSynthesizer_js_1.AvatarSynthesizer;
    } });
    var AvatarVideoFormat_js_1 = AvatarVideoFormat$1;
    Object.defineProperty(exports, "AvatarVideoFormat", { enumerable: true, get: function() {
      return AvatarVideoFormat_js_1.AvatarVideoFormat;
    } });
    Object.defineProperty(exports, "Coordinate", { enumerable: true, get: function() {
      return AvatarVideoFormat_js_1.Coordinate;
    } });
    var AvatarWebRTCConnectionResult_js_1 = requireAvatarWebRTCConnectionResult();
    Object.defineProperty(exports, "AvatarWebRTCConnectionResult", { enumerable: true, get: function() {
      return AvatarWebRTCConnectionResult_js_1.AvatarWebRTCConnectionResult;
    } });
    var Diagnostics_js_1 = requireDiagnostics();
    Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function() {
      return Diagnostics_js_1.Diagnostics;
    } });
    var LogLevel_js_12 = LogLevel;
    Object.defineProperty(exports, "LogLevel", { enumerable: true, get: function() {
      return LogLevel_js_12.LogLevel;
    } });
  })(Exports$3);
  return Exports$3;
}
var hasRequiredProxyInfo;
function requireProxyInfo() {
  if (hasRequiredProxyInfo) return ProxyInfo;
  hasRequiredProxyInfo = 1;
  Object.defineProperty(ProxyInfo, "__esModule", { value: true });
  ProxyInfo.ProxyInfo = void 0;
  const Exports_js_12 = requireExports$3();
  let ProxyInfo$1 = class ProxyInfo2 {
    constructor(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
      this.privProxyHostName = proxyHostName;
      this.privProxyPort = proxyPort;
      this.privProxyUserName = proxyUserName;
      this.privProxyPassword = proxyPassword;
    }
    static fromParameters(parameters) {
      return new ProxyInfo2(parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyPort), 10), parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyUserName), parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(config) {
      return this.fromParameters(config.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  ProxyInfo.ProxyInfo = ProxyInfo$1;
  return ProxyInfo;
}
var RestMessageAdapter = {};
const encodings = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
var core$1 = (mkrequest2) => (...args) => {
  const statusCodes = /* @__PURE__ */ new Set();
  let method;
  let encoding;
  let headers;
  let baseurl = "";
  args.forEach((arg) => {
    if (typeof arg === "string") {
      if (arg.toUpperCase() === arg) {
        if (method) {
          const msg = `Can't set method to ${arg}, already set to ${method}.`;
          throw new Error(msg);
        } else {
          method = arg;
        }
      } else if (arg.startsWith("http:") || arg.startsWith("https:")) {
        baseurl = arg;
      } else {
        if (encodings.has(arg)) {
          encoding = arg;
        } else {
          throw new Error(`Unknown encoding, ${arg}`);
        }
      }
    } else if (typeof arg === "number") {
      statusCodes.add(arg);
    } else if (typeof arg === "object") {
      if (Array.isArray(arg) || arg instanceof Set) {
        arg.forEach((code2) => statusCodes.add(code2));
      } else {
        if (headers) {
          throw new Error("Cannot set headers twice.");
        }
        headers = arg;
      }
    } else {
      throw new Error(`Unknown type: ${typeof arg}`);
    }
  });
  if (!method) method = "GET";
  if (statusCodes.size === 0) {
    statusCodes.add(200);
  }
  return mkrequest2(statusCodes, method, encoding, headers, baseurl);
};
const core = core$1;
class StatusError extends Error {
  constructor(res, ...params) {
    super(...params);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, StatusError);
    }
    this.name = "StatusError";
    this.message = res.statusMessage;
    this.statusCode = res.status;
    this.res = res;
    this.json = res.json.bind(res);
    this.text = res.text.bind(res);
    this.arrayBuffer = res.arrayBuffer.bind(res);
    let buffer;
    const get = () => {
      if (!buffer) buffer = this.arrayBuffer();
      return buffer;
    };
    Object.defineProperty(this, "responseBody", { get });
    this.headers = {};
    for (const [key, value] of res.headers.entries()) {
      this.headers[key.toLowerCase()] = value;
    }
  }
}
const mkrequest = (statusCodes, method, encoding, headers, baseurl) => async (_url, body, _headers = {}) => {
  _url = baseurl + (_url || "");
  let parsed = new URL(_url);
  if (!headers) headers = {};
  if (parsed.username) {
    headers.Authorization = "Basic " + btoa(parsed.username + ":" + parsed.password);
    parsed = new URL(parsed.protocol + "//" + parsed.host + parsed.pathname + parsed.search);
  }
  if (parsed.protocol !== "https:" && parsed.protocol !== "http:") {
    throw new Error(`Unknown protocol, ${parsed.protocol}`);
  }
  if (body) {
    if (body instanceof ArrayBuffer || ArrayBuffer.isView(body) || typeof body === "string") ;
    else if (typeof body === "object") {
      body = JSON.stringify(body);
      headers["Content-Type"] = "application/json";
    } else {
      throw new Error("Unknown body type.");
    }
  }
  _headers = new Headers({ ...headers || {}, ..._headers });
  const resp = await fetch(parsed, { method, headers: _headers, body });
  resp.statusCode = resp.status;
  if (!statusCodes.has(resp.status)) {
    throw new StatusError(resp);
  }
  if (encoding === "json") return resp.json();
  else if (encoding === "buffer") return resp.arrayBuffer();
  else if (encoding === "string") return resp.text();
  else return resp;
};
var browser = core(mkrequest);
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestMessageAdapter = exports.RestRequestType = void 0;
  const bent_1 = __importDefault2(browser);
  const Exports_js_12 = requireExports$5();
  var RestRequestType;
  (function(RestRequestType2) {
    RestRequestType2["Get"] = "GET";
    RestRequestType2["Post"] = "POST";
    RestRequestType2["Delete"] = "DELETE";
    RestRequestType2["File"] = "file";
  })(RestRequestType = exports.RestRequestType || (exports.RestRequestType = {}));
  class RestMessageAdapter2 {
    constructor(configParams) {
      if (!configParams) {
        throw new Exports_js_12.ArgumentNullError("configParams");
      }
      this.privHeaders = configParams.headers;
      this.privIgnoreCache = configParams.ignoreCache;
    }
    static extractHeaderValue(headerKey, headers) {
      let headerValue = "";
      try {
        const arr = headers.trim().split(/[\r\n]+/);
        const headerMap = {};
        arr.forEach((line) => {
          const parts = line.split(": ");
          const header = parts.shift().toLowerCase();
          const value = parts.join(": ");
          headerMap[header] = value;
        });
        headerValue = headerMap[headerKey.toLowerCase()];
      } catch (e) {
      }
      return headerValue;
    }
    set options(configParams) {
      this.privHeaders = configParams.headers;
      this.privIgnoreCache = configParams.ignoreCache;
    }
    setHeaders(key, value) {
      this.privHeaders[key] = value;
    }
    request(method, uri, queryParams = {}, body = null) {
      const responseReceivedDeferral = new Exports_js_12.Deferred();
      const requestCommand = method === RestRequestType.File ? "POST" : method;
      const handleRestResponse = (data, j = {}) => {
        const d = data;
        return {
          data: JSON.stringify(j),
          headers: JSON.stringify(data.headers),
          json: j,
          ok: data.statusCode >= 200 && data.statusCode < 300,
          status: data.statusCode,
          statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage
        };
      };
      const send = (postData) => {
        const sendRequest = bent_1.default(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);
        const params = this.queryParams(queryParams) === "" ? "" : `?${this.queryParams(queryParams)}`;
        sendRequest(params, postData).then(async (data) => {
          if (method === RestRequestType.Delete || data.statusCode === 204) {
            responseReceivedDeferral.resolve(handleRestResponse(data));
          } else {
            try {
              const j = await data.json();
              responseReceivedDeferral.resolve(handleRestResponse(data, j));
            } catch {
              responseReceivedDeferral.resolve(handleRestResponse(data));
            }
          }
        }).catch((error) => {
          responseReceivedDeferral.reject(error);
        });
      };
      if (this.privIgnoreCache) {
        this.privHeaders["Cache-Control"] = "no-cache";
      }
      if (method === RestRequestType.Post && body) {
        this.privHeaders["content-type"] = "application/json";
        this.privHeaders["Content-Type"] = "application/json";
      }
      send(body);
      return responseReceivedDeferral.promise;
    }
    queryParams(params = {}) {
      return Object.keys(params).map((k2) => encodeURIComponent(k2) + "=" + encodeURIComponent(params[k2])).join("&");
    }
  }
  exports.RestMessageAdapter = RestMessageAdapter2;
})(RestMessageAdapter);
var RestConfigBase$1 = {};
Object.defineProperty(RestConfigBase$1, "__esModule", { value: true });
RestConfigBase$1.RestConfigBase = void 0;
class RestConfigBase {
  static get requestOptions() {
    return RestConfigBase.privDefaultRequestOptions;
  }
  static get configParams() {
    return RestConfigBase.privDefaultParams;
  }
  static get restErrors() {
    return RestConfigBase.privRestErrors;
  }
}
RestConfigBase$1.RestConfigBase = RestConfigBase;
RestConfigBase.privDefaultRequestOptions = {
  headers: {
    Accept: "application/json"
  },
  ignoreCache: false,
  timeout: 1e4
};
RestConfigBase.privRestErrors = {
  authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
  authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
  invalidArgs: "Required input not found: {arg}.",
  invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
  invalidParticipantRequest: "The requested participant was not found.",
  permissionDeniedConnect: "Required credentials not found.",
  permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
  permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
  permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
  permissionDeniedStart: "Invalid operation: there is already an active conversation."
};
RestConfigBase.privDefaultParams = {
  apiVersion: "api-version",
  authorization: "Authorization",
  clientAppId: "X-ClientAppId",
  contentTypeKey: "Content-Type",
  correlationId: "X-CorrelationId",
  languageCode: "language",
  nickname: "nickname",
  profanity: "profanity",
  requestId: "X-RequestId",
  roomId: "roomid",
  sessionToken: "token",
  subscriptionKey: "Ocp-Apim-Subscription-Key",
  subscriptionRegion: "Ocp-Apim-Subscription-Region",
  token: "X-CapitoToken"
};
var hasRequiredExports$2;
function requireExports$2() {
  if (hasRequiredExports$2) return Exports$4;
  hasRequiredExports$2 = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !exports2.hasOwnProperty(p2)) __createBinding2(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(ConsoleLoggingListener$1, exports);
    __exportStar(IRecorder, exports);
    __exportStar(requireMicAudioSource(), exports);
    __exportStar(requireFileAudioSource(), exports);
    __exportStar(PCMRecorder, exports);
    __exportStar(WebsocketConnection$1, exports);
    __exportStar(WebsocketMessageAdapter$1, exports);
    __exportStar(ReplayableAudioNode$1, exports);
    __exportStar(requireProxyInfo(), exports);
    __exportStar(RestMessageAdapter, exports);
    __exportStar(RestConfigBase$1, exports);
  })(Exports$4);
  return Exports$4;
}
var hasRequiredIntentConnectionFactory;
function requireIntentConnectionFactory() {
  if (hasRequiredIntentConnectionFactory) return IntentConnectionFactory;
  hasRequiredIntentConnectionFactory = 1;
  Object.defineProperty(IntentConnectionFactory, "__esModule", { value: true });
  IntentConnectionFactory.IntentConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_3 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  let IntentConnectionFactory$1 = class IntentConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    create(config, authInfo, connectionId) {
      let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint);
      if (!endpoint) {
        const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_IntentRegion);
        const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
        const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".sr.speech" + hostSuffix);
        endpoint = host + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const queryParams = {
        format: "simple",
        language: config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(config, queryParams, endpoint);
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
    getSpeechRegionFromIntentRegion(intentRegion) {
      switch (intentRegion) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return intentRegion;
      }
    }
  };
  IntentConnectionFactory.IntentConnectionFactory = IntentConnectionFactory$1;
  return IntentConnectionFactory;
}
var SpeakerRecognitionConnectionFactory = {};
var hasRequiredSpeakerRecognitionConnectionFactory;
function requireSpeakerRecognitionConnectionFactory() {
  if (hasRequiredSpeakerRecognitionConnectionFactory) return SpeakerRecognitionConnectionFactory;
  hasRequiredSpeakerRecognitionConnectionFactory = 1;
  Object.defineProperty(SpeakerRecognitionConnectionFactory, "__esModule", { value: true });
  SpeakerRecognitionConnectionFactory.VoiceProfileConnectionFactory = SpeakerRecognitionConnectionFactory.SpeakerRecognitionConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_3 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  class SpeakerRecognitionConnectionFactoryBase extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    create(config, authInfo, endpointPath, connectionId) {
      let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint);
      if (!endpoint) {
        const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
        const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
        const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, `wss://${region}.spr-frontend.speech${hostSuffix}`);
        const scenario = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        endpoint = `${host}/speaker/ws/${this.scenarioToPath(scenario)}/${endpointPath}`;
      }
      const queryParams = {
        format: "simple",
        language: config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(config, queryParams, endpoint);
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      headers[HeaderNames_js_12.HeaderNames.SpIDAuthKey] = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key);
      config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
    scenarioToPath(mode) {
      switch (mode) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let SpeakerRecognitionConnectionFactory$1 = class SpeakerRecognitionConnectionFactory extends SpeakerRecognitionConnectionFactoryBase {
    create(config, authInfo, connectionId) {
      return super.create(config, authInfo, "recognition", connectionId);
    }
  };
  SpeakerRecognitionConnectionFactory.SpeakerRecognitionConnectionFactory = SpeakerRecognitionConnectionFactory$1;
  class VoiceProfileConnectionFactory extends SpeakerRecognitionConnectionFactoryBase {
    create(config, authInfo, connectionId) {
      return super.create(config, authInfo, "profile", connectionId);
    }
  }
  SpeakerRecognitionConnectionFactory.VoiceProfileConnectionFactory = VoiceProfileConnectionFactory;
  return SpeakerRecognitionConnectionFactory;
}
var RecognitionEvents = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecognitionEndedEvent = exports.RecognitionCompletionStatus = exports.RecognitionStartedEvent = exports.ConnectingToServiceEvent = exports.ListeningStartedEvent = exports.RecognitionTriggeredEvent = exports.SpeechRecognitionEvent = void 0;
  const Exports_js_12 = requireExports$5();
  class SpeechRecognitionEvent extends Exports_js_12.PlatformEvent {
    constructor(eventName, requestId, sessionId, eventType = Exports_js_12.EventType.Info) {
      super(eventName, eventType);
      this.privRequestId = requestId;
      this.privSessionId = sessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  exports.SpeechRecognitionEvent = SpeechRecognitionEvent;
  class RecognitionTriggeredEvent extends SpeechRecognitionEvent {
    constructor(requestId, sessionId, audioSourceId, audioNodeId) {
      super("RecognitionTriggeredEvent", requestId, sessionId);
      this.privAudioSourceId = audioSourceId;
      this.privAudioNodeId = audioNodeId;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  exports.RecognitionTriggeredEvent = RecognitionTriggeredEvent;
  class ListeningStartedEvent extends SpeechRecognitionEvent {
    constructor(requestId, sessionId, audioSourceId, audioNodeId) {
      super("ListeningStartedEvent", requestId, sessionId);
      this.privAudioSourceId = audioSourceId;
      this.privAudioNodeId = audioNodeId;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  exports.ListeningStartedEvent = ListeningStartedEvent;
  class ConnectingToServiceEvent extends SpeechRecognitionEvent {
    constructor(requestId, authFetchEventid, sessionId) {
      super("ConnectingToServiceEvent", requestId, sessionId);
      this.privAuthFetchEventid = authFetchEventid;
    }
    get authFetchEventid() {
      return this.privAuthFetchEventid;
    }
  }
  exports.ConnectingToServiceEvent = ConnectingToServiceEvent;
  class RecognitionStartedEvent extends SpeechRecognitionEvent {
    constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId) {
      super("RecognitionStartedEvent", requestId, sessionId);
      this.privAudioSourceId = audioSourceId;
      this.privAudioNodeId = audioNodeId;
      this.privAuthFetchEventId = authFetchEventId;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  exports.RecognitionStartedEvent = RecognitionStartedEvent;
  var RecognitionCompletionStatus;
  (function(RecognitionCompletionStatus2) {
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["Success"] = 0] = "Success";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["AudioSourceError"] = 1] = "AudioSourceError";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["AudioSourceTimeout"] = 2] = "AudioSourceTimeout";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["AuthTokenFetchError"] = 3] = "AuthTokenFetchError";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["AuthTokenFetchTimeout"] = 4] = "AuthTokenFetchTimeout";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["UnAuthorized"] = 5] = "UnAuthorized";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["ConnectTimeout"] = 6] = "ConnectTimeout";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["ConnectError"] = 7] = "ConnectError";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["ClientRecognitionActivityTimeout"] = 8] = "ClientRecognitionActivityTimeout";
    RecognitionCompletionStatus2[RecognitionCompletionStatus2["UnknownError"] = 9] = "UnknownError";
  })(RecognitionCompletionStatus = exports.RecognitionCompletionStatus || (exports.RecognitionCompletionStatus = {}));
  class RecognitionEndedEvent extends SpeechRecognitionEvent {
    constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId, serviceTag, status, error) {
      super("RecognitionEndedEvent", requestId, sessionId, status === RecognitionCompletionStatus.Success ? Exports_js_12.EventType.Info : Exports_js_12.EventType.Error);
      this.privAudioSourceId = audioSourceId;
      this.privAudioNodeId = audioNodeId;
      this.privAuthFetchEventId = authFetchEventId;
      this.privStatus = status;
      this.privError = error;
      this.privServiceTag = serviceTag;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
    get serviceTag() {
      return this.privServiceTag;
    }
    get status() {
      return this.privStatus;
    }
    get error() {
      return this.privError;
    }
  }
  exports.RecognitionEndedEvent = RecognitionEndedEvent;
})(RecognitionEvents);
var ServiceRecognizerBase = {};
var SpeechConnectionMessage_Internal = {};
Object.defineProperty(SpeechConnectionMessage_Internal, "__esModule", { value: true });
SpeechConnectionMessage_Internal.SpeechConnectionMessage = void 0;
const Exports_js_1$7 = requireExports$5();
const HeaderNames_js_1 = HeaderNames$1;
class SpeechConnectionMessage extends Exports_js_1$7.ConnectionMessage {
  constructor(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id2) {
    if (!path) {
      throw new Exports_js_1$7.ArgumentNullError("path");
    }
    if (!requestId) {
      throw new Exports_js_1$7.ArgumentNullError("requestId");
    }
    const headers = {};
    headers[HeaderNames_js_1.HeaderNames.Path] = path;
    headers[HeaderNames_js_1.HeaderNames.RequestId] = requestId;
    headers[HeaderNames_js_1.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString();
    if (contentType) {
      headers[HeaderNames_js_1.HeaderNames.ContentType] = contentType;
    }
    if (streamId) {
      headers[HeaderNames_js_1.HeaderNames.RequestStreamId] = streamId;
    }
    if (additionalHeaders) {
      for (const headerName in additionalHeaders) {
        if (headerName) {
          headers[headerName] = additionalHeaders[headerName];
        }
      }
    }
    if (id2) {
      super(messageType, body, headers, id2);
    } else {
      super(messageType, body, headers);
    }
    this.privPath = path;
    this.privRequestId = requestId;
    this.privContentType = contentType;
    this.privStreamId = streamId;
    this.privAdditionalHeaders = additionalHeaders;
  }
  get path() {
    return this.privPath;
  }
  get requestId() {
    return this.privRequestId;
  }
  get contentType() {
    return this.privContentType;
  }
  get streamId() {
    return this.privStreamId;
  }
  get additionalHeaders() {
    return this.privAdditionalHeaders;
  }
  static fromConnectionMessage(message) {
    let path = null;
    let requestId = null;
    let contentType = null;
    let streamId = null;
    const additionalHeaders = {};
    if (message.headers) {
      for (const headerName in message.headers) {
        if (headerName) {
          if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.Path.toLowerCase()) {
            path = message.headers[headerName];
          } else if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.RequestId.toLowerCase()) {
            requestId = message.headers[headerName];
          } else if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.ContentType.toLowerCase()) {
            contentType = message.headers[headerName];
          } else if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.RequestStreamId.toLowerCase()) {
            streamId = message.headers[headerName];
          } else {
            additionalHeaders[headerName] = message.headers[headerName];
          }
        }
      }
    }
    return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);
  }
}
SpeechConnectionMessage_Internal.SpeechConnectionMessage = SpeechConnectionMessage;
var hasRequiredServiceRecognizerBase;
function requireServiceRecognizerBase() {
  if (hasRequiredServiceRecognizerBase) return ServiceRecognizerBase;
  hasRequiredServiceRecognizerBase = 1;
  Object.defineProperty(ServiceRecognizerBase, "__esModule", { value: true });
  ServiceRecognizerBase.ServiceRecognizerBase = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$5();
  const Exports_js_3 = requireExports$3();
  const Exports_js_4 = requireExports();
  const SpeechConnectionMessage_Internal_js_1 = SpeechConnectionMessage_Internal;
  let ServiceRecognizerBase$1 = class ServiceRecognizerBase2 {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
      this.privConnectionConfigurationPromise = void 0;
      this.privConnectionPromise = void 0;
      this.privSetTimeout = setTimeout;
      this.privIsLiveAudio = false;
      this.privAverageBytesPerMs = 0;
      this.privEnableSpeakerId = false;
      this.privExpectContentAssessmentResponse = false;
      this.recognizeOverride = void 0;
      this.recognizeSpeaker = void 0;
      this.disconnectOverride = void 0;
      this.receiveMessageOverride = void 0;
      this.sendPrePayloadJSONOverride = void 0;
      this.postConnectImplOverride = void 0;
      this.configConnectionOverride = void 0;
      this.handleSpeechPhraseMessage = void 0;
      this.handleSpeechHypothesisMessage = void 0;
      if (!authentication) {
        throw new Exports_js_2.ArgumentNullError("authentication");
      }
      if (!connectionFactory) {
        throw new Exports_js_2.ArgumentNullError("connectionFactory");
      }
      if (!audioSource) {
        throw new Exports_js_2.ArgumentNullError("audioSource");
      }
      if (!recognizerConfig) {
        throw new Exports_js_2.ArgumentNullError("recognizerConfig");
      }
      this.privEnableSpeakerId = recognizerConfig.isSpeakerDiarizationEnabled;
      this.privMustReportEndOfStream = false;
      this.privAuthentication = authentication;
      this.privConnectionFactory = connectionFactory;
      this.privAudioSource = audioSource;
      this.privRecognizerConfig = recognizerConfig;
      this.privIsDisposed = false;
      this.privRecognizer = recognizer;
      this.privRequestSession = new Exports_js_4.RequestSession(this.privAudioSource.id());
      this.privConnectionEvents = new Exports_js_2.EventSource();
      this.privServiceEvents = new Exports_js_2.EventSource();
      this.privDynamicGrammar = new Exports_js_4.DynamicGrammarBuilder();
      this.privSpeechContext = new Exports_js_4.SpeechContext(this.privDynamicGrammar);
      this.privAgentConfig = new Exports_js_4.AgentConfig();
      const webWorkerLoadType = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.WebWorkerLoadType, "on").toLowerCase();
      if (webWorkerLoadType === "on" && typeof Blob !== "undefined" && typeof Worker !== "undefined") {
        this.privSetTimeout = Exports_js_2.Timeout.setTimeout;
      } else {
        if (typeof window !== "undefined") {
          this.privSetTimeout = window.setTimeout.bind(window);
        }
        if (typeof globalThis !== "undefined") {
          this.privSetTimeout = globalThis.setTimeout.bind(globalThis);
        }
      }
      this.connectionEvents.attach((connectionEvent) => {
        if (connectionEvent.name === "ConnectionClosedEvent") {
          const connectionClosedEvent = connectionEvent;
          if (connectionClosedEvent.statusCode === 1003 || connectionClosedEvent.statusCode === 1007 || connectionClosedEvent.statusCode === 1002 || connectionClosedEvent.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) {
            void this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_js_3.CancellationErrorCode.BadRequestParameters : Exports_js_3.CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);
          }
        }
      });
      if (this.privEnableSpeakerId) {
        this.privDiarizationSessionId = Exports_js_2.createNoDashGuid();
      }
      this.setLanguageIdJson();
      this.setOutputDetailLevelJson();
    }
    setTranslationJson() {
      const targetLanguages = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (targetLanguages !== void 0) {
        const languages = targetLanguages.split(",");
        const translationVoice = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
        const action = translationVoice !== void 0 ? "Synthesize" : "None";
        this.privSpeechContext.setSection("translation", {
          onSuccess: { action },
          output: { interimResults: { mode: "Always" } },
          targetLanguages: languages
        });
        if (translationVoice !== void 0) {
          const languageToVoiceMap = {};
          for (const lang of languages) {
            languageToVoiceMap[lang] = translationVoice;
          }
          this.privSpeechContext.setSection("synthesis", {
            defaultVoices: languageToVoiceMap
          });
        }
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const speechSegmentationTimeout = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0);
      if (speechSegmentationTimeout !== void 0) {
        const mode = this.recognitionMode === Exports_js_4.RecognitionMode.Conversation ? "CONVERSATION" : this.recognitionMode === Exports_js_4.RecognitionMode.Dictation ? "DICTATION" : "INTERACTIVE";
        const segmentationSilenceTimeoutMs = parseInt(speechSegmentationTimeout, 10);
        const phraseDetection = this.privSpeechContext.getSection("phraseDetection");
        phraseDetection.mode = mode;
        phraseDetection[mode] = {
          segmentation: {
            mode: "Custom",
            segmentationSilenceTimeoutMs
          }
        };
        this.privSpeechContext.setSection("phraseDetection", phraseDetection);
      }
    }
    setLanguageIdJson() {
      const phraseDetection = this.privSpeechContext.getSection("phraseDetection");
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const sourceLanguages = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        let speechContextLidMode;
        if (this.privRecognizerConfig.languageIdMode === "Continuous") {
          speechContextLidMode = "DetectContinuous";
        } else {
          speechContextLidMode = "DetectAtAudioStart";
        }
        this.privSpeechContext.setSection("languageId", {
          Priority: "PrioritizeLatency",
          languages: sourceLanguages,
          mode: speechContextLidMode,
          onSuccess: { action: "Recognize" },
          onUnknown: { action: "None" }
        });
        this.privSpeechContext.setSection("phraseOutput", {
          interimResults: {
            resultType: "Auto"
          },
          phraseResults: {
            resultType: "Always"
          }
        });
        const customModels = this.privRecognizerConfig.sourceLanguageModels;
        if (customModels !== void 0) {
          phraseDetection.customModels = customModels;
          phraseDetection.onInterim = { action: "None" };
          phraseDetection.onSuccess = { action: "None" };
        }
      }
      const targetLanguages = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (targetLanguages !== void 0) {
        phraseDetection.onInterim = { action: "Translate" };
        phraseDetection.onSuccess = { action: "Translate" };
        this.privSpeechContext.setSection("phraseOutput", {
          interimResults: {
            resultType: "None"
          },
          phraseResults: {
            resultType: "None"
          }
        });
      }
      this.privSpeechContext.setSection("phraseDetection", phraseDetection);
    }
    setOutputDetailLevelJson() {
      if (this.privEnableSpeakerId) {
        const requestWordLevelTimestamps = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase();
        if (requestWordLevelTimestamps === "true") {
          this.privSpeechContext.setWordLevelTimings();
        } else {
          const outputFormat = this.privRecognizerConfig.parameters.getProperty(Exports_js_4.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]).toLowerCase();
          if (outputFormat === Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Detailed].toLocaleLowerCase()) {
            this.privSpeechContext.setDetailedOutputFormat();
          }
        }
      }
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(token) {
      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.ConversationTranslator_Token, token);
    }
    set voiceProfileType(type) {
      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SpeakerIdMode, type);
    }
    set authentication(auth) {
      this.privAuthentication = auth;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(reason) {
      this.privIsDisposed = true;
      if (this.privConnectionConfigurationPromise !== void 0) {
        try {
          const connection = await this.privConnectionConfigurationPromise;
          await connection.dispose(reason);
        } catch (error) {
          return;
        }
      }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(recoMode, successCallback, errorCallBack) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(recoMode, successCallback, errorCallBack);
        return;
      }
      this.privConnectionConfigurationPromise = void 0;
      this.privRecognizerConfig.recognitionMode = recoMode;
      this.setSpeechSegmentationTimeoutJson();
      this.setTranslationJson();
      this.privSuccessCallback = successCallback;
      this.privErrorCallback = errorCallBack;
      this.privRequestSession.startNewRecognition();
      this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const conPromise = this.connectImpl();
      let audioNode;
      try {
        const audioStreamNode = await this.audioSource.attach(this.privRequestSession.audioNodeId);
        const format = await this.audioSource.format;
        const deviceInfo = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === Exports_js_4.type.Microphones;
        audioNode = new Exports_js_12.ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);
        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };
      } catch (error) {
        await this.privRequestSession.onStopRecognizing();
        throw error;
      }
      try {
        await conPromise;
      } catch (error) {
        await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, error);
        return;
      }
      const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
      if (!!this.privRecognizer.sessionStarted) {
        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
      }
      void this.receiveMessage();
      const audioSendPromise = this.sendAudio(audioNode);
      audioSendPromise.catch(async (error) => {
        await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
      });
      return;
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing) {
        try {
          await this.audioSource.turnOff();
          await this.sendFinalAudio();
          await this.privRequestSession.onStopRecognizing();
          await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
      }
      return;
    }
    async connect() {
      await this.connectImpl();
      return Promise.resolve();
    }
    connectAsync(cb2, err2) {
      this.connectImpl().then(() => {
        try {
          if (!!cb2) {
            cb2();
          }
        } catch (e) {
          if (!!err2) {
            err2(e);
          }
        }
      }, (reason) => {
        try {
          if (!!err2) {
            err2(reason);
          }
        } catch (error) {
        }
      });
    }
    async disconnect() {
      await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.NoError, "Disconnecting");
      if (this.disconnectOverride !== void 0) {
        await this.disconnectOverride();
      }
      if (this.privConnectionPromise !== void 0) {
        try {
          await (await this.privConnectionPromise).dispose();
        } catch (error) {
        }
      }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(message) {
      return;
    }
    async sendNetworkMessage(path, payload) {
      const type = typeof payload === "string" ? Exports_js_2.MessageType.Text : Exports_js_2.MessageType.Binary;
      const contentType = typeof payload === "string" ? "application/json" : "";
      const connection = await this.fetchConnection();
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));
    }
    set activityTemplate(messagePayload) {
      this.privActivityTemplate = messagePayload;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(value) {
      this.privExpectContentAssessmentResponse = value;
    }
    async sendTelemetryData() {
      const telemetryData = this.privRequestSession.getTelemetry();
      if (ServiceRecognizerBase2.telemetryDataEnabled !== true || this.privIsDisposed || null === telemetryData) {
        return;
      }
      if (!!ServiceRecognizerBase2.telemetryData) {
        try {
          ServiceRecognizerBase2.telemetryData(telemetryData);
        } catch {
        }
      }
      const connection = await this.fetchConnection();
      await connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", telemetryData));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(cancellationReason, errorCode, error) {
      if (!!this.privRequestSession.isRecognizing) {
        await this.privRequestSession.onStopRecognizing();
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error);
      }
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed) {
          return;
        }
        let connection = await this.fetchConnection();
        const message = await connection.read();
        if (this.receiveMessageOverride !== void 0) {
          return this.receiveMessageOverride();
        }
        if (!message) {
          return this.receiveMessage();
        }
        this.privServiceHasSentMessage = true;
        const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);
        if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) {
          switch (connectionMessage.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = true;
              this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const speechStartDetected = Exports_js_4.SpeechDetected.fromJSON(connectionMessage.textBody);
              const speechStartEventArgs = new Exports_js_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
              if (!!this.privRecognizer.speechStartDetected) {
                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
              }
              break;
            case "speech.enddetected":
              let json;
              if (connectionMessage.textBody.length > 0) {
                json = connectionMessage.textBody;
              } else {
                json = "{ Offset: 0 }";
              }
              const speechStopDetected = Exports_js_4.SpeechDetected.fromJSON(json);
              const speechStopEventArgs = new Exports_js_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              if (!!this.privRecognizer.speechEndDetected) {
                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
              }
              break;
            case "turn.end":
              await this.sendTelemetryData();
              if (this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream) {
                this.privMustReportEndOfStream = false;
                await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.EndOfStream, Exports_js_3.CancellationErrorCode.NoError, void 0);
              }
              const sessionStopEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
              await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition);
              if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                if (!!this.privRecognizer.sessionStopped) {
                  this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);
                }
                return;
              } else {
                connection = await this.fetchConnection();
                await this.sendPrePayloadJSON(connection);
              }
              break;
            default:
              if (!await this.processTypeSpecificMessages(connectionMessage)) {
                if (!!this.privServiceEvents) {
                  this.serviceEvents.onEvent(new Exports_js_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                }
              }
          }
        }
        return this.receiveMessage();
      } catch (error) {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const bytesSent = this.privRequestSession.recognitionBytesSent;
      const audioOffsetMs = bytesSent / this.privAverageBytesPerMs;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(audioOffsetMs);
    }
    sendSpeechContext(connection, generateNewRequestId) {
      if (this.privEnableSpeakerId) {
        this.updateSpeakerDiarizationAudioOffset();
      }
      const speechContextJson = this.speechContext.toJSON();
      if (generateNewRequestId) {
        this.privRequestSession.onSpeechContext();
      }
      if (speechContextJson) {
        return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", speechContextJson));
      }
      return;
    }
    noOp() {
      return;
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(connection, generateNewRequestId = true) {
      if (this.sendPrePayloadJSONOverride !== void 0) {
        return this.sendPrePayloadJSONOverride(connection);
      }
      await this.sendSpeechContext(connection, generateNewRequestId);
      await this.sendWaveHeader(connection);
      return;
    }
    async sendWaveHeader(connection) {
      const format = await this.audioSource.format;
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", format.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      if (this.privConnectionPromise !== void 0) {
        return this.privConnectionPromise.then((connection) => {
          if (connection.state() === Exports_js_2.ConnectionState.Disconnected) {
            this.privConnectionId = null;
            this.privConnectionPromise = void 0;
            this.privServiceHasSentMessage = false;
            return this.connectImpl();
          }
          return this.privConnectionPromise;
        }, () => {
          this.privConnectionId = null;
          this.privConnectionPromise = void 0;
          this.privServiceHasSentMessage = false;
          return this.connectImpl();
        });
      }
      this.privConnectionPromise = this.retryableConnect();
      this.privConnectionPromise.catch(() => {
      });
      if (this.postConnectImplOverride !== void 0) {
        return this.postConnectImplOverride(this.privConnectionPromise);
      }
      return this.privConnectionPromise;
    }
    sendSpeechServiceConfig(connection, requestSession, SpeechServiceConfigJson) {
      requestSession.onSpeechContext();
      if (ServiceRecognizerBase2.telemetryDataEnabled !== true) {
        const withTelemetry = JSON.parse(SpeechServiceConfigJson);
        const replacement = {
          context: {
            system: withTelemetry.context.system
          }
        };
        SpeechServiceConfigJson = JSON.stringify(replacement);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const json = JSON.parse(SpeechServiceConfigJson);
        json.context.DisableReferenceChannel = "True";
        json.context.MicSpec = "1_0_0";
        SpeechServiceConfigJson = JSON.stringify(json);
      }
      if (SpeechServiceConfigJson) {
        return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speech.config", requestSession.requestId, "application/json", SpeechServiceConfigJson));
      }
      return;
    }
    async fetchConnection() {
      if (this.privConnectionConfigurationPromise !== void 0) {
        return this.privConnectionConfigurationPromise.then((connection) => {
          if (connection.state() === Exports_js_2.ConnectionState.Disconnected) {
            this.privConnectionId = null;
            this.privConnectionConfigurationPromise = void 0;
            this.privServiceHasSentMessage = false;
            return this.fetchConnection();
          }
          return this.privConnectionConfigurationPromise;
        }, () => {
          this.privConnectionId = null;
          this.privConnectionConfigurationPromise = void 0;
          this.privServiceHasSentMessage = false;
          return this.fetchConnection();
        });
      }
      this.privConnectionConfigurationPromise = this.configureConnection();
      return await this.privConnectionConfigurationPromise;
    }
    async sendAudio(audioStreamNode) {
      const audioFormat = await this.audioSource.format;
      this.privAverageBytesPerMs = audioFormat.avgBytesPerSec / 1e3;
      let nextSendTime = Date.now();
      const fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000");
      const maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1e3 * parseInt(fastLaneSizeMs, 10);
      const startRecogNumber = this.privRequestSession.recogNumber;
      const readAndUploadCycle = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
          const connection = await this.fetchConnection();
          const audioStreamChunk = await audioStreamNode.read();
          if (this.privRequestSession.isSpeechEnded) {
            return;
          }
          let payload;
          let sendDelay;
          if (!audioStreamChunk || audioStreamChunk.isEnd) {
            payload = null;
            sendDelay = 0;
          } else {
            payload = audioStreamChunk.buffer;
            this.privRequestSession.onAudioSent(payload.byteLength);
            if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) {
              sendDelay = 0;
            } else {
              sendDelay = Math.max(0, nextSendTime - Date.now());
            }
          }
          if (0 !== sendDelay) {
            await this.delay(sendDelay);
          }
          if (payload !== null) {
            nextSendTime = Date.now() + payload.byteLength * 1e3 / (audioFormat.avgBytesPerSec * 2);
          }
          if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
            connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Binary, "audio", this.privRequestSession.requestId, null, payload)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            });
            if (!(audioStreamChunk == null ? void 0 : audioStreamChunk.isEnd)) {
              return readAndUploadCycle();
            } else {
              if (!this.privIsLiveAudio) {
                this.privRequestSession.onSpeechEnded();
              }
            }
          }
        }
      };
      return readAndUploadCycle();
    }
    async retryableConnect() {
      let isUnAuthorized = false;
      this.privAuthFetchEventId = Exports_js_2.createNoDashGuid();
      const sessionId = this.privRequestSession.sessionId;
      this.privConnectionId = sessionId !== void 0 ? sessionId : Exports_js_2.createNoDashGuid();
      this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let lastStatusCode = 0;
      let lastReason = "";
      while (this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount) {
        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
        const auth = await authPromise;
        await this.privRequestSession.onAuthCompleted(false);
        const connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(connection.events);
        connection.events.attach((event) => {
          this.connectionEvents.onEvent(event);
        });
        const response = await connection.open();
        if (response.statusCode === 200) {
          await this.privRequestSession.onConnectionEstablishCompleted(response.statusCode);
          return Promise.resolve(connection);
        } else if (response.statusCode === 1006) {
          isUnAuthorized = true;
        }
        lastStatusCode = response.statusCode;
        lastReason = response.reason;
        this.privRequestSession.onRetryConnection();
      }
      await this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason);
      return Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);
    }
    delay(delayMs) {
      return new Promise((resolve) => this.privSetTimeout(resolve, delayMs));
    }
    writeBufferToConsole(buffer) {
      let out = "Buffer Size: ";
      if (null === buffer) {
        out += "null";
      } else {
        const readView = new Uint8Array(buffer);
        out += `${buffer.byteLength}\r
`;
        for (let i = 0; i < buffer.byteLength; i++) {
          out += readView[i].toString(16).padStart(2, "0") + " ";
          if ((i + 1) % 16 === 0) {
            console.info(out);
            out = "";
          }
        }
      }
      console.info(out);
    }
    async sendFinalAudio() {
      const connection = await this.fetchConnection();
      await connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
      return;
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const connection = await this.connectImpl();
      if (this.configConnectionOverride !== void 0) {
        return this.configConnectionOverride(connection);
      }
      await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());
      await this.sendPrePayloadJSON(connection, false);
      return connection;
    }
  };
  ServiceRecognizerBase.ServiceRecognizerBase = ServiceRecognizerBase$1;
  ServiceRecognizerBase$1.telemetryDataEnabled = true;
  return ServiceRecognizerBase;
}
var ConversationServiceRecognizer = {};
var hasRequiredConversationServiceRecognizer;
function requireConversationServiceRecognizer() {
  if (hasRequiredConversationServiceRecognizer) return ConversationServiceRecognizer;
  hasRequiredConversationServiceRecognizer = 1;
  Object.defineProperty(ConversationServiceRecognizer, "__esModule", { value: true });
  ConversationServiceRecognizer.ConversationServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$3();
  const Exports_js_2 = requireExports();
  let ConversationServiceRecognizer$1 = class ConversationServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
      this.handleSpeechPhraseMessage = async (textBody) => this.handleSpeechPhrase(textBody);
      this.handleSpeechHypothesisMessage = (textBody) => this.handleSpeechHypothesis(textBody);
    }
    processTypeSpecificMessages(connectionMessage) {
      return;
    }
    handleRecognizedCallback(result, offset, sessionId) {
      return;
    }
    handleRecognizingCallback(result, duration, sessionId) {
      return;
    }
    async processSpeechMessages(connectionMessage) {
      let processed = false;
      switch (connectionMessage.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          if (!!this.handleSpeechHypothesisMessage) {
            this.handleSpeechHypothesisMessage(connectionMessage.textBody);
          }
          processed = true;
          break;
        case "speech.phrase":
          if (!!this.handleSpeechPhraseMessage) {
            await this.handleSpeechPhraseMessage(connectionMessage.textBody);
          }
          processed = true;
          break;
      }
      return processed;
    }
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    }
    async handleSpeechPhrase(textBody) {
      const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(textBody);
      const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
      let result;
      const resultProps = new Exports_js_12.PropertyCollection();
      resultProps.setProperty(Exports_js_12.PropertyId.SpeechServiceResponse_JsonResult, textBody);
      const simpleOffset = simple.Offset + this.privRequestSession.currentTurnAudioOffset;
      let offset = simpleOffset;
      this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);
      if (Exports_js_12.ResultReason.Canceled === resultReason) {
        const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
        const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
        await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
      } else {
        if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_js_12.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_js_2.RecognitionStatus.InitialSilenceTimeout)) {
          if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_12.OutputFormat[Exports_js_12.OutputFormat.Simple]) {
            result = new Exports_js_12.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simpleOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, void 0, textBody, resultProps);
          } else {
            const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(textBody);
            const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;
            const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
            result = new Exports_js_12.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.Text, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, detailed.SpeakerId, void 0, offsetCorrectedJson, resultProps);
            offset = result.offset;
          }
          this.handleRecognizedCallback(result, offset, this.privRequestSession.sessionId);
        }
      }
    }
    handleSpeechHypothesis(textBody) {
      const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(textBody);
      const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
      const resultProps = new Exports_js_12.PropertyCollection();
      resultProps.setProperty(Exports_js_12.PropertyId.SpeechServiceResponse_JsonResult, textBody);
      const result = new Exports_js_12.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_js_12.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, void 0, textBody, resultProps);
      this.privRequestSession.onHypothesis(offset);
      this.handleRecognizingCallback(result, hypothesis.Duration, this.privRequestSession.sessionId);
    }
  };
  ConversationServiceRecognizer.ConversationServiceRecognizer = ConversationServiceRecognizer$1;
  return ConversationServiceRecognizer;
}
var RecognizerConfig = {};
var hasRequiredRecognizerConfig;
function requireRecognizerConfig() {
  if (hasRequiredRecognizerConfig) return RecognizerConfig;
  hasRequiredRecognizerConfig = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecognizerConfig = exports.SpeechResultFormat = exports.RecognitionMode = void 0;
    const Exports_js_12 = requireExports$3();
    const Exports_js_2 = requireExports();
    var RecognitionMode;
    (function(RecognitionMode2) {
      RecognitionMode2[RecognitionMode2["Interactive"] = 0] = "Interactive";
      RecognitionMode2[RecognitionMode2["Conversation"] = 1] = "Conversation";
      RecognitionMode2[RecognitionMode2["Dictation"] = 2] = "Dictation";
    })(RecognitionMode = exports.RecognitionMode || (exports.RecognitionMode = {}));
    (function(SpeechResultFormat) {
      SpeechResultFormat[SpeechResultFormat["Simple"] = 0] = "Simple";
      SpeechResultFormat[SpeechResultFormat["Detailed"] = 1] = "Detailed";
    })(exports.SpeechResultFormat || (exports.SpeechResultFormat = {}));
    class RecognizerConfig2 {
      constructor(speechServiceConfig, parameters) {
        this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new Exports_js_2.SpeechServiceConfig(new Exports_js_2.Context(null));
        this.privParameters = parameters;
        this.privMaxRetryCount = parseInt(parameters.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10);
        this.privLanguageIdMode = parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0);
        this.privEnableSpeakerId = false;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(value) {
        this.privRecognitionMode = value;
        this.privRecognitionActivityTimeout = value === RecognitionMode.Interactive ? 8e3 : 25e3;
        this.privSpeechServiceConfig.Recognition = RecognitionMode[value];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== RecognitionMode.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(Exports_js_12.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, void 0);
      }
      get sourceLanguageModels() {
        const models = [];
        let modelsExist = false;
        if (this.autoDetectSourceLanguages !== void 0) {
          for (const language of this.autoDetectSourceLanguages.split(",")) {
            const customProperty = language + Exports_js_12.PropertyId.SpeechServiceConnection_EndpointId.toString();
            const modelId = this.parameters.getProperty(customProperty, void 0);
            if (modelId !== void 0) {
              models.push({ language, endpoint: modelId });
              modelsExist = true;
            } else {
              models.push({ language, endpoint: "" });
            }
          }
        }
        return modelsExist ? models : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(value) {
        this.privEnableSpeakerId = value;
      }
    }
    exports.RecognizerConfig = RecognizerConfig2;
  })(RecognizerConfig);
  return RecognizerConfig;
}
var SpeechServiceInterfaces = {};
Object.defineProperty(SpeechServiceInterfaces, "__esModule", { value: true });
var WebsocketMessageFormatter$1 = {};
Object.defineProperty(WebsocketMessageFormatter$1, "__esModule", { value: true });
WebsocketMessageFormatter$1.WebsocketMessageFormatter = void 0;
const Exports_js_1$6 = requireExports$5();
const CRLF = "\r\n";
class WebsocketMessageFormatter {
  toConnectionMessage(message) {
    const deferral = new Exports_js_1$6.Deferred();
    try {
      if (message.messageType === Exports_js_1$6.MessageType.Text) {
        const textMessage = message.textContent;
        let headers = {};
        let body = null;
        if (textMessage) {
          const headerBodySplit = textMessage.split("\r\n\r\n");
          if (headerBodySplit && headerBodySplit.length > 0) {
            headers = this.parseHeaders(headerBodySplit[0]);
            if (headerBodySplit.length > 1) {
              body = headerBodySplit[1];
            }
          }
        }
        deferral.resolve(new Exports_js_1$6.ConnectionMessage(message.messageType, body, headers, message.id));
      } else if (message.messageType === Exports_js_1$6.MessageType.Binary) {
        const binaryMessage = message.binaryContent;
        let headers = {};
        let body = null;
        if (!binaryMessage || binaryMessage.byteLength < 2) {
          throw new Error("Invalid binary message format. Header length missing.");
        }
        const dataView = new DataView(binaryMessage);
        const headerLength = dataView.getInt16(0);
        if (binaryMessage.byteLength < headerLength + 2) {
          throw new Error("Invalid binary message format. Header content missing.");
        }
        let headersString = "";
        for (let i = 0; i < headerLength; i++) {
          headersString += String.fromCharCode(dataView.getInt8(i + 2));
        }
        headers = this.parseHeaders(headersString);
        if (binaryMessage.byteLength > headerLength + 2) {
          body = binaryMessage.slice(2 + headerLength);
        }
        deferral.resolve(new Exports_js_1$6.ConnectionMessage(message.messageType, body, headers, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. Error: ${e}`);
    }
    return deferral.promise;
  }
  fromConnectionMessage(message) {
    const deferral = new Exports_js_1$6.Deferred();
    try {
      if (message.messageType === Exports_js_1$6.MessageType.Text) {
        const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : ""}`;
        deferral.resolve(new Exports_js_1$6.RawWebsocketMessage(Exports_js_1$6.MessageType.Text, payload, message.id));
      } else if (message.messageType === Exports_js_1$6.MessageType.Binary) {
        const headersString = this.makeHeaders(message);
        const content2 = message.binaryBody;
        const headerBuffer = this.stringToArrayBuffer(headersString);
        const headerInt8Array = new Int8Array(headerBuffer);
        const headerLength = headerInt8Array.byteLength;
        const payloadInt8Array = new Int8Array(2 + headerLength + (content2 ? content2.byteLength : 0));
        payloadInt8Array[0] = headerLength >> 8 & 255;
        payloadInt8Array[1] = headerLength & 255;
        payloadInt8Array.set(headerInt8Array, 2);
        if (content2) {
          const bodyInt8Array = new Int8Array(content2);
          payloadInt8Array.set(bodyInt8Array, 2 + headerLength);
        }
        const payload = payloadInt8Array.buffer;
        deferral.resolve(new Exports_js_1$6.RawWebsocketMessage(Exports_js_1$6.MessageType.Binary, payload, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. ${e}`);
    }
    return deferral.promise;
  }
  makeHeaders(message) {
    let headersString = "";
    if (message.headers) {
      for (const header in message.headers) {
        if (header) {
          headersString += `${header}: ${message.headers[header]}${CRLF}`;
        }
      }
    }
    return headersString;
  }
  parseHeaders(headersString) {
    const headers = {};
    if (headersString) {
      const headerMatches = headersString.match(/[^\r\n]+/g);
      if (headers) {
        for (const header of headerMatches) {
          if (header) {
            const separatorIndex = header.indexOf(":");
            const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;
            const headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : "";
            headers[headerName] = headerValue;
          }
        }
      }
    }
    return headers;
  }
  stringToArrayBuffer(str) {
    const buffer = new ArrayBuffer(str.length);
    const view = new DataView(buffer);
    for (let i = 0; i < str.length; i++) {
      view.setUint8(i, str.charCodeAt(i));
    }
    return buffer;
  }
}
WebsocketMessageFormatter$1.WebsocketMessageFormatter = WebsocketMessageFormatter;
var SpeechConnectionFactory = {};
var hasRequiredSpeechConnectionFactory;
function requireSpeechConnectionFactory() {
  if (hasRequiredSpeechConnectionFactory) return SpeechConnectionFactory;
  hasRequiredSpeechConnectionFactory = 1;
  Object.defineProperty(SpeechConnectionFactory, "__esModule", { value: true });
  SpeechConnectionFactory.SpeechConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports();
  const Exports_js_3 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_4 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  let SpeechConnectionFactory$1 = class SpeechConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    constructor() {
      super(...arguments);
      this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1";
      this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1";
      this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1";
      this.universalUri = "/speech/universal/v";
    }
    create(config, authInfo, connectionId) {
      let endpoint = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const region = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Region, void 0);
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const host = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix);
      const queryParams = {};
      const endpointId = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_EndpointId, void 0);
      const language = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (endpointId) {
        if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId) === -1) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
        }
      } else if (language) {
        if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.Language) === -1) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
        }
      }
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.Format) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = config.parameters.getProperty(Exports_js_2.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]).toLowerCase();
      }
      if (config.autoDetectSourceLanguages !== void 0) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableLanguageId] = "true";
      }
      this.setCommonUrlParams(config, queryParams, endpoint);
      if (!endpoint) {
        switch (config.recognitionMode) {
          case Exports_js_4.RecognitionMode.Conversation:
            if (config.parameters.getProperty(Exports_js_2.ForceDictationPropertyName, "false") === "true") {
              endpoint = host + this.dictationRelativeUri;
            } else {
              if (config.recognitionEndpointVersion !== void 0 && parseInt(config.recognitionEndpointVersion, 10) > 1) {
                endpoint = `${host}${this.universalUri}${config.recognitionEndpointVersion}`;
              } else {
                endpoint = host + this.conversationRelativeUri;
              }
            }
            break;
          case Exports_js_4.RecognitionMode.Dictation:
            endpoint = host + this.dictationRelativeUri;
            break;
          default:
            if (config.recognitionEndpointVersion !== void 0 && parseInt(config.recognitionEndpointVersion, 10) > 1) {
              endpoint = `${host}${this.universalUri}${config.recognitionEndpointVersion}`;
            } else {
              endpoint = host + this.interactiveRelativeUri;
            }
            break;
        }
      }
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      const webSocketConnection = new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_4.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
      const uri = webSocketConnection.uri;
      config.parameters.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Url, uri);
      return webSocketConnection;
    }
  };
  SpeechConnectionFactory.SpeechConnectionFactory = SpeechConnectionFactory$1;
  return SpeechConnectionFactory;
}
var ConversationTranscriberConnectionFactory = {};
var hasRequiredConversationTranscriberConnectionFactory;
function requireConversationTranscriberConnectionFactory() {
  if (hasRequiredConversationTranscriberConnectionFactory) return ConversationTranscriberConnectionFactory;
  hasRequiredConversationTranscriberConnectionFactory = 1;
  Object.defineProperty(ConversationTranscriberConnectionFactory, "__esModule", { value: true });
  ConversationTranscriberConnectionFactory.ConversationTranscriberConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_4 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  let ConversationTranscriberConnectionFactory$1 = class ConversationTranscriberConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    constructor() {
      super(...arguments);
      this.universalUri = "/speech/universal/v2";
    }
    create(config, authInfo, connectionId) {
      let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, void 0);
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix);
      const queryParams = {};
      const endpointId = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, void 0);
      const language = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (endpointId) {
        if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId) === -1) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
        }
      } else if (language) {
        if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.Language) === -1) {
          queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
        }
      }
      if (config.autoDetectSourceLanguages !== void 0) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableLanguageId] = "true";
      }
      this.setV2UrlParams(config, queryParams, endpoint);
      if (!endpoint) {
        endpoint = `${host}${this.universalUri}`;
      }
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      const webSocketConnection = new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_4.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
      const uri = webSocketConnection.uri;
      config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, uri);
      return webSocketConnection;
    }
    setV2UrlParams(config, queryParams, endpoint) {
      const propertyIdToParameterMap = /* @__PURE__ */ new Map([
        [Exports_js_2.PropertyId.Speech_SegmentationSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames_js_1.QueryParameterNames.EnableAudioLogging],
        [Exports_js_2.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.EndSilenceTimeoutMs],
        [Exports_js_2.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.InitialSilenceTimeoutMs],
        [Exports_js_2.PropertyId.SpeechServiceResponse_PostProcessingOption, QueryParameterNames_js_1.QueryParameterNames.Postprocessing],
        [Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames_js_1.QueryParameterNames.Profanity],
        [Exports_js_2.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames_js_1.QueryParameterNames.StableIntermediateThreshold]
      ]);
      propertyIdToParameterMap.forEach((parameterName, propertyId) => {
        this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
      });
      const serviceProperties = JSON.parse(config.parameters.getProperty(Exports_js_3.ServicePropertiesPropertyName, "{}"));
      Object.keys(serviceProperties).forEach((value) => {
        queryParams[value] = serviceProperties[value];
      });
    }
  };
  ConversationTranscriberConnectionFactory.ConversationTranscriberConnectionFactory = ConversationTranscriberConnectionFactory$1;
  return ConversationTranscriberConnectionFactory;
}
var TranscriberConnectionFactory = {};
var hasRequiredTranscriberConnectionFactory;
function requireTranscriberConnectionFactory() {
  if (hasRequiredTranscriberConnectionFactory) return TranscriberConnectionFactory;
  hasRequiredTranscriberConnectionFactory = 1;
  Object.defineProperty(TranscriberConnectionFactory, "__esModule", { value: true });
  TranscriberConnectionFactory.TranscriberConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_3 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  let TranscriberConnectionFactory$1 = class TranscriberConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    constructor() {
      super(...arguments);
      this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(config, authInfo, connectionId) {
      let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, "centralus");
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const hostDefault = "wss://transcribe." + region + ".cts.speech" + hostSuffix + this.multiaudioRelativeUri;
      const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, hostDefault);
      const queryParams = {};
      this.setQueryParams(queryParams, config, endpoint);
      if (!endpoint) {
        endpoint = host;
      }
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
    setQueryParams(queryParams, config, endpointUrl) {
      const endpointId = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, void 0);
      const language = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (endpointId && !(QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId in queryParams)) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
      }
      if (language && !(QueryParameterNames_js_1.QueryParameterNames.Language in queryParams)) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
      }
      const wordLevelTimings = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true";
      const detailed = config.parameters.getProperty(Exports_js_3.OutputFormatPropertyName, Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Simple]) !== Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Simple];
      if (wordLevelTimings || detailed) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Detailed].toLowerCase();
      }
      this.setCommonUrlParams(config, queryParams, endpointUrl);
    }
  };
  TranscriberConnectionFactory.TranscriberConnectionFactory = TranscriberConnectionFactory$1;
  return TranscriberConnectionFactory;
}
var TranslationConnectionFactory = {};
var hasRequiredTranslationConnectionFactory;
function requireTranslationConnectionFactory() {
  if (hasRequiredTranslationConnectionFactory) return TranslationConnectionFactory;
  hasRequiredTranslationConnectionFactory = 1;
  Object.defineProperty(TranslationConnectionFactory, "__esModule", { value: true });
  TranslationConnectionFactory.TranslationConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const StringUtils_js_1 = StringUtils$1;
  const Exports_js_2 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const Exports_js_3 = requireExports();
  const HeaderNames_js_12 = HeaderNames$1;
  const QueryParameterNames_js_1 = QueryParameterNames$1;
  let TranslationConnectionFactory$1 = class TranslationConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    create(config, authInfo, connectionId) {
      const endpoint = this.getEndpointUrl(config);
      const queryParams = {};
      if (config.autoDetectSourceLanguages !== void 0) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableLanguageId] = "true";
      }
      this.setQueryParams(queryParams, config, endpoint);
      const headers = {};
      if (authInfo.token !== void 0 && authInfo.token !== "") {
        headers[authInfo.headerName] = authInfo.token;
      }
      headers[HeaderNames_js_12.HeaderNames.ConnectionId] = connectionId;
      config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
    getEndpointUrl(config, returnRegionPlaceholder) {
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      let endpointUrl = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!endpointUrl) {
        if (config.autoDetectSourceLanguages !== void 0) {
          const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + hostSuffix);
          endpointUrl = host + "/speech/universal/v2";
        } else {
          const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + hostSuffix);
          endpointUrl = host + "/speech/translation/cognitiveservices/v1";
        }
      }
      if (returnRegionPlaceholder === true) {
        return endpointUrl;
      }
      return StringUtils_js_1.StringUtils.formatString(endpointUrl, { region });
    }
    setQueryParams(queryParams, config, endpointUrl) {
      queryParams.from = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);
      queryParams.to = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages);
      queryParams.scenario = config.recognitionMode === Exports_js_3.RecognitionMode.Interactive ? "interactive" : config.recognitionMode === Exports_js_3.RecognitionMode.Conversation ? "conversation" : "";
      this.setCommonUrlParams(config, queryParams, endpointUrl);
      this.setUrlParameter(Exports_js_2.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, QueryParameterNames_js_1.QueryParameterNames.StableTranslation, config, queryParams, endpointUrl);
      const translationVoice = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      if (translationVoice !== void 0) {
        queryParams.voice = translationVoice;
        queryParams.features = "texttospeech";
      }
    }
  };
  TranslationConnectionFactory.TranslationConnectionFactory = TranslationConnectionFactory$1;
  return TranslationConnectionFactory;
}
var EnumTranslation = {};
var hasRequiredEnumTranslation;
function requireEnumTranslation() {
  if (hasRequiredEnumTranslation) return EnumTranslation;
  hasRequiredEnumTranslation = 1;
  Object.defineProperty(EnumTranslation, "__esModule", { value: true });
  EnumTranslation.EnumTranslation = void 0;
  const Exports_js_12 = requireExports$3();
  const Exports_js_2 = requireExports();
  let EnumTranslation$1 = class EnumTranslation {
    static implTranslateRecognitionResult(recognitionStatus, expectEndOfDictation = false) {
      let reason = Exports_js_12.ResultReason.Canceled;
      switch (recognitionStatus) {
        case Exports_js_2.RecognitionStatus.Success:
          reason = Exports_js_12.ResultReason.RecognizedSpeech;
          break;
        case Exports_js_2.RecognitionStatus.EndOfDictation:
          reason = expectEndOfDictation ? Exports_js_12.ResultReason.RecognizedSpeech : Exports_js_12.ResultReason.NoMatch;
          break;
        case Exports_js_2.RecognitionStatus.NoMatch:
        case Exports_js_2.RecognitionStatus.InitialSilenceTimeout:
        case Exports_js_2.RecognitionStatus.BabbleTimeout:
          reason = Exports_js_12.ResultReason.NoMatch;
          break;
        case Exports_js_2.RecognitionStatus.Error:
        case Exports_js_2.RecognitionStatus.BadRequest:
        case Exports_js_2.RecognitionStatus.Forbidden:
        default:
          reason = Exports_js_12.ResultReason.Canceled;
          break;
      }
      return reason;
    }
    static implTranslateCancelResult(recognitionStatus) {
      let reason = Exports_js_12.CancellationReason.EndOfStream;
      switch (recognitionStatus) {
        case Exports_js_2.RecognitionStatus.Success:
        case Exports_js_2.RecognitionStatus.EndOfDictation:
        case Exports_js_2.RecognitionStatus.NoMatch:
          reason = Exports_js_12.CancellationReason.EndOfStream;
          break;
        case Exports_js_2.RecognitionStatus.InitialSilenceTimeout:
        case Exports_js_2.RecognitionStatus.BabbleTimeout:
        case Exports_js_2.RecognitionStatus.Error:
        case Exports_js_2.RecognitionStatus.BadRequest:
        case Exports_js_2.RecognitionStatus.Forbidden:
        default:
          reason = Exports_js_12.CancellationReason.Error;
          break;
      }
      return reason;
    }
    static implTranslateCancelErrorCode(recognitionStatus) {
      let reason = Exports_js_12.CancellationErrorCode.NoError;
      switch (recognitionStatus) {
        case Exports_js_2.RecognitionStatus.Error:
          reason = Exports_js_12.CancellationErrorCode.ServiceError;
          break;
        case Exports_js_2.RecognitionStatus.TooManyRequests:
          reason = Exports_js_12.CancellationErrorCode.TooManyRequests;
          break;
        case Exports_js_2.RecognitionStatus.BadRequest:
          reason = Exports_js_12.CancellationErrorCode.BadRequestParameters;
          break;
        case Exports_js_2.RecognitionStatus.Forbidden:
          reason = Exports_js_12.CancellationErrorCode.Forbidden;
          break;
        default:
          reason = Exports_js_12.CancellationErrorCode.NoError;
          break;
      }
      return reason;
    }
    static implTranslateErrorDetails(cancellationErrorCode) {
      let errorDetails = "The speech service encountered an internal error and could not continue.";
      switch (cancellationErrorCode) {
        case Exports_js_12.CancellationErrorCode.Forbidden:
          errorDetails = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case Exports_js_12.CancellationErrorCode.BadRequestParameters:
          errorDetails = "Invalid parameter or unsupported audio format in the request.";
          break;
        case Exports_js_12.CancellationErrorCode.TooManyRequests:
          errorDetails = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return errorDetails;
    }
  };
  EnumTranslation.EnumTranslation = EnumTranslation$1;
  return EnumTranslation;
}
var Enums = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecognitionStatus = exports.SynthesisStatus = void 0;
  (function(SynthesisStatus) {
    SynthesisStatus[SynthesisStatus["Success"] = 0] = "Success";
    SynthesisStatus[SynthesisStatus["SynthesisEnd"] = 1] = "SynthesisEnd";
    SynthesisStatus[SynthesisStatus["Error"] = 2] = "Error";
  })(exports.SynthesisStatus || (exports.SynthesisStatus = {}));
  (function(RecognitionStatus) {
    RecognitionStatus[RecognitionStatus["Success"] = 0] = "Success";
    RecognitionStatus[RecognitionStatus["NoMatch"] = 1] = "NoMatch";
    RecognitionStatus[RecognitionStatus["InitialSilenceTimeout"] = 2] = "InitialSilenceTimeout";
    RecognitionStatus[RecognitionStatus["BabbleTimeout"] = 3] = "BabbleTimeout";
    RecognitionStatus[RecognitionStatus["Error"] = 4] = "Error";
    RecognitionStatus[RecognitionStatus["EndOfDictation"] = 5] = "EndOfDictation";
    RecognitionStatus[RecognitionStatus["TooManyRequests"] = 6] = "TooManyRequests";
    RecognitionStatus[RecognitionStatus["BadRequest"] = 7] = "BadRequest";
    RecognitionStatus[RecognitionStatus["Forbidden"] = 8] = "Forbidden";
  })(exports.RecognitionStatus || (exports.RecognitionStatus = {}));
})(Enums);
var TranslationSynthesisEnd = {};
var hasRequiredTranslationSynthesisEnd;
function requireTranslationSynthesisEnd() {
  if (hasRequiredTranslationSynthesisEnd) return TranslationSynthesisEnd;
  hasRequiredTranslationSynthesisEnd = 1;
  Object.defineProperty(TranslationSynthesisEnd, "__esModule", { value: true });
  TranslationSynthesisEnd.TranslationSynthesisEnd = void 0;
  const Exports_js_12 = requireExports();
  let TranslationSynthesisEnd$1 = class TranslationSynthesisEnd2 {
    constructor(json) {
      this.privSynthesisEnd = JSON.parse(json);
      if (!!this.privSynthesisEnd.SynthesisStatus) {
        this.privSynthesisEnd.SynthesisStatus = Exports_js_12.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus];
      }
      if (!!this.privSynthesisEnd.Status) {
        this.privSynthesisEnd.SynthesisStatus = Exports_js_12.SynthesisStatus[this.privSynthesisEnd.Status];
      }
    }
    static fromJSON(json) {
      return new TranslationSynthesisEnd2(json);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  TranslationSynthesisEnd.TranslationSynthesisEnd = TranslationSynthesisEnd$1;
  return TranslationSynthesisEnd;
}
var TranslationHypothesis$1 = {};
Object.defineProperty(TranslationHypothesis$1, "__esModule", { value: true });
TranslationHypothesis$1.TranslationHypothesis = void 0;
const Contracts_js_1 = Contracts$1;
const TranslationStatus_js_1 = TranslationStatus;
class TranslationHypothesis {
  constructor(hypothesis) {
    this.privTranslationHypothesis = hypothesis;
    this.privTranslationHypothesis.Translation.TranslationStatus = TranslationStatus_js_1.TranslationStatus[this.privTranslationHypothesis.Translation.TranslationStatus];
  }
  static fromJSON(json) {
    return new TranslationHypothesis(JSON.parse(json));
  }
  static fromTranslationResponse(translationHypothesis) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(translationHypothesis, "translationHypothesis");
    const hypothesis = translationHypothesis.SpeechHypothesis;
    translationHypothesis.SpeechHypothesis = void 0;
    hypothesis.Translation = translationHypothesis;
    return new TranslationHypothesis(hypothesis);
  }
  get Duration() {
    return this.privTranslationHypothesis.Duration;
  }
  get Offset() {
    return this.privTranslationHypothesis.Offset;
  }
  get Text() {
    return this.privTranslationHypothesis.Text;
  }
  get Translation() {
    return this.privTranslationHypothesis.Translation;
  }
  get Language() {
    var _a2;
    return (_a2 = this.privTranslationHypothesis.PrimaryLanguage) == null ? void 0 : _a2.Language;
  }
}
TranslationHypothesis$1.TranslationHypothesis = TranslationHypothesis;
var TranslationPhrase = {};
var hasRequiredTranslationPhrase;
function requireTranslationPhrase() {
  if (hasRequiredTranslationPhrase) return TranslationPhrase;
  hasRequiredTranslationPhrase = 1;
  Object.defineProperty(TranslationPhrase, "__esModule", { value: true });
  TranslationPhrase.TranslationPhrase = void 0;
  const Contracts_js_12 = Contracts$1;
  const Exports_js_12 = requireExports();
  const TranslationStatus_js_12 = TranslationStatus;
  let TranslationPhrase$1 = class TranslationPhrase2 {
    constructor(phrase) {
      this.privTranslationPhrase = phrase;
      this.privTranslationPhrase.RecognitionStatus = Exports_js_12.RecognitionStatus[this.privTranslationPhrase.RecognitionStatus];
      if (this.privTranslationPhrase.Translation !== void 0) {
        this.privTranslationPhrase.Translation.TranslationStatus = TranslationStatus_js_12.TranslationStatus[this.privTranslationPhrase.Translation.TranslationStatus];
      }
    }
    static fromJSON(json) {
      return new TranslationPhrase2(JSON.parse(json));
    }
    static fromTranslationResponse(translationResponse) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(translationResponse, "translationResponse");
      const phrase = translationResponse.SpeechPhrase;
      translationResponse.SpeechPhrase = void 0;
      phrase.Translation = translationResponse;
      phrase.Text = phrase.DisplayText;
      return new TranslationPhrase2(phrase);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      var _a2;
      return (_a2 = this.privTranslationPhrase.PrimaryLanguage) == null ? void 0 : _a2.Language;
    }
    get Confidence() {
      var _a2;
      return (_a2 = this.privTranslationPhrase.PrimaryLanguage) == null ? void 0 : _a2.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
  };
  TranslationPhrase.TranslationPhrase = TranslationPhrase$1;
  return TranslationPhrase;
}
var TranslationServiceRecognizer = {};
var hasRequiredTranslationServiceRecognizer;
function requireTranslationServiceRecognizer() {
  if (hasRequiredTranslationServiceRecognizer) return TranslationServiceRecognizer;
  hasRequiredTranslationServiceRecognizer = 1;
  Object.defineProperty(TranslationServiceRecognizer, "__esModule", { value: true });
  TranslationServiceRecognizer.TranslationServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$5();
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  let TranslationServiceRecognizer$1 = class TranslationServiceRecognizer extends Exports_js_3.ConversationServiceRecognizer {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);
      this.privTranslationRecognizer = translationRecognizer;
      this.connectionEvents.attach((connectionEvent) => {
        if (connectionEvent.name === "ConnectionEstablishedEvent") {
          this.privTranslationRecognizer.onConnection();
        }
      });
    }
    async processTypeSpecificMessages(connectionMessage) {
      const resultProps = new Exports_js_2.PropertyCollection();
      let processed = await this.processSpeechMessages(connectionMessage);
      if (processed) {
        return true;
      }
      const handleTranslationPhrase = async (translatedPhrase) => {
        this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset + translatedPhrase.Duration);
        if (translatedPhrase.RecognitionStatus === Exports_js_3.RecognitionStatus.Success) {
          const result = this.fireEventForResult(translatedPhrase, resultProps);
          if (!!this.privTranslationRecognizer.recognized) {
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);
            } catch (error) {
            }
          }
          if (!!this.privSuccessCallback) {
            try {
              this.privSuccessCallback(result.result);
            } catch (e) {
              if (!!this.privErrorCallback) {
                this.privErrorCallback(e);
              }
            }
            this.privSuccessCallback = void 0;
            this.privErrorCallback = void 0;
          }
        } else {
          const reason = Exports_js_3.EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);
          const result = new Exports_js_2.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, this.privRequestSession.currentTurnAudioOffset + translatedPhrase.Offset, translatedPhrase.Language, translatedPhrase.Confidence, void 0, connectionMessage.textBody, resultProps);
          if (reason === Exports_js_2.ResultReason.Canceled) {
            const cancelReason = Exports_js_3.EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);
            const cancellationErrorCode = Exports_js_3.EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);
            await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_3.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
          } else {
            if (!(this.privRequestSession.isSpeechEnded && reason === Exports_js_2.ResultReason.NoMatch && translatedPhrase.RecognitionStatus !== Exports_js_3.RecognitionStatus.InitialSilenceTimeout)) {
              const ev = new Exports_js_2.TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
              if (!!this.privTranslationRecognizer.recognized) {
                try {
                  this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);
                } catch (error) {
                }
              }
            }
            if (!!this.privSuccessCallback) {
              try {
                this.privSuccessCallback(result);
              } catch (e) {
                if (!!this.privErrorCallback) {
                  this.privErrorCallback(e);
                }
              }
              this.privSuccessCallback = void 0;
              this.privErrorCallback = void 0;
            }
          }
          processed = true;
        }
      };
      const handleTranslationHypothesis = (hypothesis, resultProperties) => {
        const result = this.fireEventForResult(hypothesis, resultProperties);
        this.privRequestSession.onHypothesis(this.privRequestSession.currentTurnAudioOffset + result.offset);
        if (!!this.privTranslationRecognizer.recognizing) {
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);
          } catch (error) {
          }
        }
        processed = true;
      };
      if (connectionMessage.messageType === Exports_js_12.MessageType.Text) {
        resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      }
      switch (connectionMessage.path.toLowerCase()) {
        case "translation.hypothesis":
          handleTranslationHypothesis(Exports_js_3.TranslationHypothesis.fromJSON(connectionMessage.textBody), resultProps);
          break;
        case "translation.response":
          const phrase = JSON.parse(connectionMessage.textBody);
          if (!!phrase.SpeechPhrase) {
            await handleTranslationPhrase(Exports_js_3.TranslationPhrase.fromTranslationResponse(phrase));
          } else {
            const hypothesis = JSON.parse(connectionMessage.textBody);
            if (!!hypothesis.SpeechHypothesis) {
              handleTranslationHypothesis(Exports_js_3.TranslationHypothesis.fromTranslationResponse(hypothesis), resultProps);
            }
          }
          break;
        case "translation.phrase":
          await handleTranslationPhrase(Exports_js_3.TranslationPhrase.fromJSON(connectionMessage.textBody));
          break;
        case "translation.synthesis":
          this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);
          processed = true;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const synthEnd = Exports_js_3.TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);
          switch (synthEnd.SynthesisStatus) {
            case Exports_js_3.SynthesisStatus.Error:
              if (!!this.privTranslationRecognizer.synthesizing) {
                const result = new Exports_js_2.TranslationSynthesisResult(Exports_js_2.ResultReason.Canceled, void 0);
                const retEvent = new Exports_js_2.TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);
                } catch (error) {
                }
              }
              if (!!this.privTranslationRecognizer.canceled) {
                const canceledResult = new Exports_js_2.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, Exports_js_2.CancellationReason.Error, synthEnd.FailureReason, Exports_js_2.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);
                } catch (error) {
                }
              }
              break;
            case Exports_js_3.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          processed = true;
          break;
      }
      return processed;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_2.PropertyCollection();
      properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
      if (!!this.privTranslationRecognizer.canceled) {
        const cancelEvent = new Exports_js_2.TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);
        } catch {
        }
      }
      if (!!this.privSuccessCallback) {
        const result = new Exports_js_2.TranslationRecognitionResult(
          void 0,
          // Translations
          requestId,
          Exports_js_2.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          error,
          void 0,
          // Json
          properties
        );
        try {
          this.privSuccessCallback(result);
          this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(result, duration, sessionId) {
      try {
        const ev = new Exports_js_2.TranslationRecognitionEventArgs(Exports_js_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), duration, sessionId);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, ev);
      } catch (error) {
      }
    }
    handleRecognizedCallback(result, offset, sessionId) {
      try {
        const ev = new Exports_js_2.TranslationRecognitionEventArgs(Exports_js_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);
      } catch (error) {
      }
    }
    fireEventForResult(serviceResult, properties) {
      let translations;
      if (void 0 !== serviceResult.Translation.Translations) {
        translations = new Exports_js_2.Translations();
        for (const translation of serviceResult.Translation.Translations) {
          translations.set(translation.Language, translation.Text || translation.DisplayText);
        }
      }
      let resultReason;
      let confidence;
      if (serviceResult instanceof Exports_js_3.TranslationPhrase) {
        if (!!serviceResult.Translation && serviceResult.Translation.TranslationStatus === Exports_js_12.TranslationStatus.Success) {
          resultReason = Exports_js_2.ResultReason.TranslatedSpeech;
        } else {
          resultReason = Exports_js_2.ResultReason.RecognizedSpeech;
        }
        confidence = serviceResult.Confidence;
      } else {
        resultReason = Exports_js_2.ResultReason.TranslatingSpeech;
      }
      const language = serviceResult.Language;
      const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;
      const result = new Exports_js_2.TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, offset, language, confidence, serviceResult.Translation.FailureReason, JSON.stringify(serviceResult), properties);
      const ev = new Exports_js_2.TranslationRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);
      return ev;
    }
    sendSynthesisAudio(audio, sessionId) {
      const reason = void 0 === audio ? Exports_js_2.ResultReason.SynthesizingAudioCompleted : Exports_js_2.ResultReason.SynthesizingAudio;
      const result = new Exports_js_2.TranslationSynthesisResult(reason, audio);
      const retEvent = new Exports_js_2.TranslationSynthesisEventArgs(result, sessionId);
      if (!!this.privTranslationRecognizer.synthesizing) {
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);
        } catch (error) {
        }
      }
    }
  };
  TranslationServiceRecognizer.TranslationServiceRecognizer = TranslationServiceRecognizer$1;
  return TranslationServiceRecognizer;
}
var SpeechDetected$1 = {};
Object.defineProperty(SpeechDetected$1, "__esModule", { value: true });
SpeechDetected$1.SpeechDetected = void 0;
class SpeechDetected {
  constructor(json) {
    this.privSpeechStartDetected = JSON.parse(json);
  }
  static fromJSON(json) {
    return new SpeechDetected(json);
  }
  get Offset() {
    return this.privSpeechStartDetected.Offset;
  }
}
SpeechDetected$1.SpeechDetected = SpeechDetected;
var SpeechHypothesis$1 = {};
Object.defineProperty(SpeechHypothesis$1, "__esModule", { value: true });
SpeechHypothesis$1.SpeechHypothesis = void 0;
class SpeechHypothesis {
  constructor(json) {
    this.privSpeechHypothesis = JSON.parse(json);
  }
  static fromJSON(json) {
    return new SpeechHypothesis(json);
  }
  get Text() {
    return this.privSpeechHypothesis.Text;
  }
  get Offset() {
    return this.privSpeechHypothesis.Offset;
  }
  get Duration() {
    return this.privSpeechHypothesis.Duration;
  }
  get Language() {
    return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
  }
  get LanguageDetectionConfidence() {
    return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
  }
  get SpeakerId() {
    return this.privSpeechHypothesis.SpeakerId;
  }
}
SpeechHypothesis$1.SpeechHypothesis = SpeechHypothesis;
var SpeechKeyword$1 = {};
Object.defineProperty(SpeechKeyword$1, "__esModule", { value: true });
SpeechKeyword$1.SpeechKeyword = void 0;
class SpeechKeyword {
  constructor(json) {
    this.privSpeechKeyword = JSON.parse(json);
  }
  static fromJSON(json) {
    return new SpeechKeyword(json);
  }
  get Status() {
    return this.privSpeechKeyword.Status;
  }
  get Text() {
    return this.privSpeechKeyword.Text;
  }
  get Offset() {
    return this.privSpeechKeyword.Offset;
  }
  get Duration() {
    return this.privSpeechKeyword.Duration;
  }
}
SpeechKeyword$1.SpeechKeyword = SpeechKeyword;
var SpeechServiceRecognizer = {};
var hasRequiredSpeechServiceRecognizer;
function requireSpeechServiceRecognizer() {
  if (hasRequiredSpeechServiceRecognizer) return SpeechServiceRecognizer;
  hasRequiredSpeechServiceRecognizer = 1;
  Object.defineProperty(SpeechServiceRecognizer, "__esModule", { value: true });
  SpeechServiceRecognizer.SpeechServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$3();
  const Exports_js_2 = requireExports();
  let SpeechServiceRecognizer$1 = class SpeechServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer);
      this.privSpeechRecognizer = speechRecognizer;
    }
    async processTypeSpecificMessages(connectionMessage) {
      let result;
      const resultProps = new Exports_js_12.PropertyCollection();
      resultProps.setProperty(Exports_js_12.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      let processed = false;
      switch (connectionMessage.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(connectionMessage.textBody);
          const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
          result = new Exports_js_12.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            Exports_js_12.ResultReason.RecognizingSpeech,
            hypothesis.Text,
            hypothesis.Duration,
            offset,
            hypothesis.Language,
            hypothesis.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            connectionMessage.textBody,
            resultProps
          );
          this.privRequestSession.onHypothesis(offset);
          const ev = new Exports_js_12.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
          if (!!this.privSpeechRecognizer.recognizing) {
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, ev);
            } catch (error) {
            }
          }
          processed = true;
          break;
        case "speech.phrase":
          const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
          const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus, this.privExpectContentAssessmentResponse);
          this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);
          if (Exports_js_12.ResultReason.Canceled === resultReason) {
            const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
            const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
            await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
          } else {
            if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_js_12.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_js_2.RecognitionStatus.InitialSilenceTimeout)) {
              if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_12.OutputFormat[Exports_js_12.OutputFormat.Simple]) {
                result = new Exports_js_12.SpeechRecognitionResult(
                  this.privRequestSession.requestId,
                  resultReason,
                  simple.DisplayText,
                  simple.Duration,
                  simple.Offset + this.privRequestSession.currentTurnAudioOffset,
                  simple.Language,
                  simple.LanguageDetectionConfidence,
                  void 0,
                  // Speaker Id
                  void 0,
                  connectionMessage.textBody,
                  resultProps
                );
              } else {
                const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);
                const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;
                const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
                result = new Exports_js_12.SpeechRecognitionResult(
                  this.privRequestSession.requestId,
                  resultReason,
                  detailed.RecognitionStatus === Exports_js_2.RecognitionStatus.Success ? detailed.NBest[0].Display : void 0,
                  detailed.Duration,
                  totalOffset,
                  detailed.Language,
                  detailed.LanguageDetectionConfidence,
                  void 0,
                  // Speaker Id
                  void 0,
                  offsetCorrectedJson,
                  resultProps
                );
              }
              const event = new Exports_js_12.SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
              if (!!this.privSpeechRecognizer.recognized) {
                try {
                  this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, event);
                } catch (error) {
                }
              }
            }
            if (!!this.privSuccessCallback) {
              try {
                this.privSuccessCallback(result);
              } catch (e) {
                if (!!this.privErrorCallback) {
                  this.privErrorCallback(e);
                }
              }
              this.privSuccessCallback = void 0;
              this.privErrorCallback = void 0;
            }
          }
          processed = true;
          break;
      }
      return processed;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_12.PropertyCollection();
      properties.setProperty(Exports_js_2.CancellationErrorCodePropertyName, Exports_js_12.CancellationErrorCode[errorCode]);
      if (!!this.privSpeechRecognizer.canceled) {
        const cancelEvent = new Exports_js_12.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, cancelEvent);
        } catch {
        }
      }
      if (!!this.privSuccessCallback) {
        const result = new Exports_js_12.SpeechRecognitionResult(
          requestId,
          Exports_js_12.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          error,
          void 0,
          // Json
          properties
        );
        try {
          this.privSuccessCallback(result);
          this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  SpeechServiceRecognizer.SpeechServiceRecognizer = SpeechServiceRecognizer$1;
  return SpeechServiceRecognizer;
}
var ConversationTranscriptionServiceRecognizer = {};
var hasRequiredConversationTranscriptionServiceRecognizer;
function requireConversationTranscriptionServiceRecognizer() {
  if (hasRequiredConversationTranscriptionServiceRecognizer) return ConversationTranscriptionServiceRecognizer;
  hasRequiredConversationTranscriptionServiceRecognizer = 1;
  Object.defineProperty(ConversationTranscriptionServiceRecognizer, "__esModule", { value: true });
  ConversationTranscriptionServiceRecognizer.ConversationTranscriptionServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$3();
  const Exports_js_2 = requireExports();
  let ConversationTranscriptionServiceRecognizer$1 = class ConversationTranscriptionServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber);
      this.privConversationTranscriber = conversationTranscriber;
      this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const phraseDetection = this.privSpeechContext.getSection("phraseDetection");
        phraseDetection.mode = "Conversation";
        const speakerDiarization = {};
        speakerDiarization.mode = "Anonymous";
        speakerDiarization.audioSessionId = this.privDiarizationSessionId;
        speakerDiarization.audioOffsetMs = 0;
        phraseDetection.speakerDiarization = speakerDiarization;
        this.privSpeechContext.setSection("phraseDetection", phraseDetection);
      }
    }
    async processTypeSpecificMessages(connectionMessage) {
      let result;
      const resultProps = new Exports_js_12.PropertyCollection();
      resultProps.setProperty(Exports_js_12.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      let processed = false;
      switch (connectionMessage.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(connectionMessage.textBody);
          const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
          result = new Exports_js_12.ConversationTranscriptionResult(
            this.privRequestSession.requestId,
            Exports_js_12.ResultReason.RecognizingSpeech,
            hypothesis.Text,
            hypothesis.Duration,
            offset,
            hypothesis.Language,
            hypothesis.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            connectionMessage.textBody,
            resultProps
          );
          this.privRequestSession.onHypothesis(offset);
          const ev = new Exports_js_12.ConversationTranscriptionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
          if (!!this.privConversationTranscriber.transcribing) {
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, ev);
            } catch (error) {
            }
          }
          processed = true;
          break;
        case "speech.phrase":
          const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
          const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
          this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);
          if (Exports_js_12.ResultReason.Canceled === resultReason) {
            const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
            const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
            await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
          } else {
            if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_js_12.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_js_2.RecognitionStatus.InitialSilenceTimeout)) {
              if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_12.OutputFormat[Exports_js_12.OutputFormat.Simple]) {
                result = new Exports_js_12.ConversationTranscriptionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, void 0, connectionMessage.textBody, resultProps);
              } else {
                const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);
                const totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;
                const offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
                result = new Exports_js_12.ConversationTranscriptionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === Exports_js_2.RecognitionStatus.Success ? detailed.NBest[0].Display : void 0, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, simple.SpeakerId, void 0, offsetCorrectedJson, resultProps);
              }
              const event = new Exports_js_12.ConversationTranscriptionEventArgs(result, result.offset, this.privRequestSession.sessionId);
              if (!!this.privConversationTranscriber.transcribed) {
                try {
                  this.privConversationTranscriber.transcribed(this.privConversationTranscriber, event);
                } catch (error) {
                }
              }
            }
          }
          processed = true;
          break;
      }
      return processed;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_12.PropertyCollection();
      properties.setProperty(Exports_js_2.CancellationErrorCodePropertyName, Exports_js_12.CancellationErrorCode[errorCode]);
      if (!!this.privConversationTranscriber.canceled) {
        const cancelEvent = new Exports_js_12.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, cancelEvent);
        } catch {
        }
      }
    }
  };
  ConversationTranscriptionServiceRecognizer.ConversationTranscriptionServiceRecognizer = ConversationTranscriptionServiceRecognizer$1;
  return ConversationTranscriptionServiceRecognizer;
}
var TranscriptionServiceRecognizer = {};
var hasRequiredTranscriptionServiceRecognizer;
function requireTranscriptionServiceRecognizer() {
  if (hasRequiredTranscriptionServiceRecognizer) return TranscriptionServiceRecognizer;
  hasRequiredTranscriptionServiceRecognizer = 1;
  Object.defineProperty(TranscriptionServiceRecognizer, "__esModule", { value: true });
  TranscriptionServiceRecognizer.TranscriptionServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$5();
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  const SpeechConnectionMessage_Internal_js_1 = SpeechConnectionMessage_Internal;
  let TranscriptionServiceRecognizer$1 = class TranscriptionServiceRecognizer extends Exports_js_3.ConversationServiceRecognizer {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, transcriber) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, transcriber);
      this.privTranscriberRecognizer = transcriber;
      this.sendPrePayloadJSONOverride = (connection) => this.sendTranscriptionStartJSON(connection);
      if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true") {
        this.privSpeechContext.setWordLevelTimings();
      }
    }
    async sendSpeechEventAsync(info, command) {
      if (!!this.privRequestSession.isRecognizing) {
        const connection = await this.fetchConnection();
        await this.sendSpeechEvent(connection, this.createSpeechEventPayload(info, command));
      }
    }
    async sendMeetingSpeechEventAsync(info, command) {
      if (!!this.privRequestSession.isRecognizing) {
        const connection = await this.fetchConnection();
        await this.sendSpeechEvent(connection, this.createMeetingSpeechEventPayload(info, command));
      }
    }
    processTypeSpecificMessages(connectionMessage) {
      return this.processSpeechMessages(connectionMessage);
    }
    handleRecognizedCallback(result, offset, sessionId) {
      try {
        const event = new Exports_js_2.SpeechRecognitionEventArgs(result, offset, sessionId);
        this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, event);
        if (!!this.privSuccessCallback) {
          try {
            this.privSuccessCallback(result);
          } catch (e) {
            if (!!this.privErrorCallback) {
              this.privErrorCallback(e);
            }
          }
          this.privSuccessCallback = void 0;
          this.privErrorCallback = void 0;
        }
      } catch (error) {
      }
    }
    handleRecognizingCallback(result, duration, sessionId) {
      try {
        const ev = new Exports_js_2.SpeechRecognitionEventArgs(result, duration, sessionId);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, ev);
      } catch (error) {
      }
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_2.PropertyCollection();
      properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
      if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (!!this.privTranscriberRecognizer.canceled) {
          const cancelEvent = new Exports_js_2.MeetingTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);
          } catch {
          }
        }
      } else {
        if (!!this.privTranscriberRecognizer.canceled) {
          const cancelEvent = new Exports_js_2.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);
          } catch {
          }
        }
      }
      if (!!this.privSuccessCallback) {
        const result = new Exports_js_2.SpeechRecognitionResult(
          requestId,
          Exports_js_2.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          error,
          void 0,
          // Json
          properties
        );
        try {
          this.privSuccessCallback(result);
          this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(connection) {
      await this.sendSpeechContext(connection, true);
      if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const info = this.privTranscriberRecognizer.getMeetingInfo();
        const payload = this.createMeetingSpeechEventPayload(info, "start");
        await this.sendSpeechEvent(connection, payload);
      } else {
        const info = this.privTranscriberRecognizer.getConversationInfo();
        const payload = this.createSpeechEventPayload(info, "start");
        await this.sendSpeechEvent(connection, payload);
      }
      await this.sendWaveHeader(connection);
      return;
    }
    sendSpeechEvent(connection, payload) {
      const speechEventJson = JSON.stringify(payload);
      if (speechEventJson) {
        return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_12.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", speechEventJson));
      }
      return;
    }
    createSpeechEventPayload(info, command) {
      const eventDict = { id: "meeting", name: command, meeting: info.conversationProperties };
      eventDict.meeting.id = info.id;
      eventDict.meeting.attendees = info.participants;
      return eventDict;
    }
    createMeetingSpeechEventPayload(info, command) {
      const eventDict = { id: "meeting", name: command, meeting: info.meetingProperties };
      eventDict.meeting.id = info.id;
      eventDict.meeting.attendees = info.participants;
      return eventDict;
    }
  };
  TranscriptionServiceRecognizer.TranscriptionServiceRecognizer = TranscriptionServiceRecognizer$1;
  return TranscriptionServiceRecognizer;
}
var DetailedSpeechPhrase = {};
var hasRequiredDetailedSpeechPhrase;
function requireDetailedSpeechPhrase() {
  if (hasRequiredDetailedSpeechPhrase) return DetailedSpeechPhrase;
  hasRequiredDetailedSpeechPhrase = 1;
  Object.defineProperty(DetailedSpeechPhrase, "__esModule", { value: true });
  DetailedSpeechPhrase.DetailedSpeechPhrase = void 0;
  const Exports_js_12 = requireExports();
  let DetailedSpeechPhrase$1 = class DetailedSpeechPhrase2 {
    constructor(json) {
      this.privDetailedSpeechPhrase = JSON.parse(json);
      this.privDetailedSpeechPhrase.RecognitionStatus = Exports_js_12.RecognitionStatus[this.privDetailedSpeechPhrase.RecognitionStatus];
    }
    static fromJSON(json) {
      return new DetailedSpeechPhrase2(json);
    }
    getJsonWithCorrectedOffsets(baseOffset) {
      if (!!this.privDetailedSpeechPhrase.NBest) {
        let firstWordOffset;
        for (const phrase of this.privDetailedSpeechPhrase.NBest) {
          if (!!phrase.Words && !!phrase.Words[0]) {
            firstWordOffset = phrase.Words[0].Offset;
            break;
          }
        }
        if (!!firstWordOffset && firstWordOffset < baseOffset) {
          const offset = baseOffset - firstWordOffset;
          for (const details of this.privDetailedSpeechPhrase.NBest) {
            if (!!details.Words) {
              for (const word of details.Words) {
                word.Offset += offset;
              }
            }
            if (!!details.DisplayWords) {
              for (const word of details.DisplayWords) {
                word.Offset += offset;
              }
            }
          }
        }
      }
      return JSON.stringify(this.privDetailedSpeechPhrase);
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      if (!!this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0]) {
        return this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText;
      }
      return this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
  };
  DetailedSpeechPhrase.DetailedSpeechPhrase = DetailedSpeechPhrase$1;
  return DetailedSpeechPhrase;
}
var SimpleSpeechPhrase = {};
var hasRequiredSimpleSpeechPhrase;
function requireSimpleSpeechPhrase() {
  if (hasRequiredSimpleSpeechPhrase) return SimpleSpeechPhrase;
  hasRequiredSimpleSpeechPhrase = 1;
  Object.defineProperty(SimpleSpeechPhrase, "__esModule", { value: true });
  SimpleSpeechPhrase.SimpleSpeechPhrase = void 0;
  const Exports_js_12 = requireExports();
  let SimpleSpeechPhrase$1 = class SimpleSpeechPhrase2 {
    constructor(json) {
      this.privSimpleSpeechPhrase = JSON.parse(json);
      this.privSimpleSpeechPhrase.RecognitionStatus = Exports_js_12.RecognitionStatus[this.privSimpleSpeechPhrase.RecognitionStatus];
    }
    static fromJSON(json) {
      return new SimpleSpeechPhrase2(json);
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
  };
  SimpleSpeechPhrase.SimpleSpeechPhrase = SimpleSpeechPhrase$1;
  return SimpleSpeechPhrase;
}
var AddedLmIntent$1 = {};
Object.defineProperty(AddedLmIntent$1, "__esModule", { value: true });
AddedLmIntent$1.AddedLmIntent = void 0;
class AddedLmIntent {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param modelImpl - The model.
   * @param intentName - The intent name.
   */
  constructor(modelImpl, intentName) {
    this.modelImpl = modelImpl;
    this.intentName = intentName;
  }
}
AddedLmIntent$1.AddedLmIntent = AddedLmIntent;
var IntentServiceRecognizer = {};
var hasRequiredIntentServiceRecognizer;
function requireIntentServiceRecognizer() {
  if (hasRequiredIntentServiceRecognizer) return IntentServiceRecognizer;
  hasRequiredIntentServiceRecognizer = 1;
  Object.defineProperty(IntentServiceRecognizer, "__esModule", { value: true });
  IntentServiceRecognizer.IntentServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$5();
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  let IntentServiceRecognizer$1 = class IntentServiceRecognizer extends Exports_js_3.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
      this.privIntentRecognizer = recognizer;
      this.privIntentDataSent = false;
    }
    setIntents(addedIntents, umbrellaIntent) {
      this.privAddedLmIntents = addedIntents;
      this.privUmbrellaIntent = umbrellaIntent;
      this.privIntentDataSent = true;
    }
    processTypeSpecificMessages(connectionMessage) {
      let result;
      let ev;
      let processed = false;
      const resultProps = new Exports_js_2.PropertyCollection();
      if (connectionMessage.messageType === Exports_js_12.MessageType.Text) {
        resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      }
      switch (connectionMessage.path.toLowerCase()) {
        case "speech.hypothesis":
          const speechHypothesis = Exports_js_3.SpeechHypothesis.fromJSON(connectionMessage.textBody);
          result = new Exports_js_2.IntentRecognitionResult(void 0, this.privRequestSession.requestId, Exports_js_2.ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, void 0, connectionMessage.textBody, resultProps);
          this.privRequestSession.onHypothesis(result.offset);
          ev = new Exports_js_2.IntentRecognitionEventArgs(result, speechHypothesis.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
          if (!!this.privIntentRecognizer.recognizing) {
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);
            } catch (error) {
            }
          }
          processed = true;
          break;
        case "speech.phrase":
          const simple = Exports_js_3.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
          result = new Exports_js_2.IntentRecognitionResult(void 0, this.privRequestSession.requestId, Exports_js_3.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, void 0, connectionMessage.textBody, resultProps);
          ev = new Exports_js_2.IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
          const sendEvent = () => {
            if (!!this.privIntentRecognizer.recognized) {
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);
              } catch (error) {
              }
            }
            if (!!this.privSuccessCallback) {
              try {
                this.privSuccessCallback(result);
              } catch (e) {
                if (!!this.privErrorCallback) {
                  this.privErrorCallback(e);
                }
              }
              this.privSuccessCallback = void 0;
              this.privErrorCallback = void 0;
            }
          };
          if (false === this.privIntentDataSent || Exports_js_2.ResultReason.NoMatch === ev.result.reason) {
            this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);
            sendEvent();
          } else {
            this.privPendingIntentArgs = ev;
          }
          processed = true;
          break;
        case "response":
          ev = this.privPendingIntentArgs;
          this.privPendingIntentArgs = void 0;
          if (void 0 === ev) {
            if ("" === connectionMessage.textBody) {
              return;
            }
            ev = new Exports_js_2.IntentRecognitionEventArgs(new Exports_js_2.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const intentResponse = Exports_js_3.IntentResponse.fromJSON(connectionMessage.textBody);
          if (null !== intentResponse && !!intentResponse.topScoringIntent && !!intentResponse.topScoringIntent.intent) {
            let addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0) {
              addedIntent = this.privUmbrellaIntent;
            }
            if (!!addedIntent) {
              const intentId = addedIntent === void 0 || addedIntent.intentName === void 0 ? intentResponse.topScoringIntent.intent : addedIntent.intentName;
              let reason = ev.result.reason;
              if (void 0 !== intentId) {
                reason = Exports_js_2.ResultReason.RecognizedIntent;
              }
              const properties = void 0 !== ev.result.properties ? ev.result.properties : new Exports_js_2.PropertyCollection();
              properties.setProperty(Exports_js_2.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);
              ev = new Exports_js_2.IntentRecognitionEventArgs(new Exports_js_2.IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, void 0, void 0, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);
            }
          }
          this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);
          if (!!this.privIntentRecognizer.recognized) {
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);
            } catch (error) {
            }
          }
          if (!!this.privSuccessCallback) {
            try {
              this.privSuccessCallback(ev.result);
            } catch (e) {
              if (!!this.privErrorCallback) {
                this.privErrorCallback(e);
              }
            }
            this.privSuccessCallback = void 0;
            this.privErrorCallback = void 0;
          }
          processed = true;
          break;
      }
      const defferal = new Exports_js_12.Deferred();
      defferal.resolve(processed);
      return defferal.promise;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_2.PropertyCollection();
      properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
      if (!!this.privIntentRecognizer.canceled) {
        const cancelEvent = new Exports_js_2.IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, void 0, void 0, sessionId);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);
        } catch {
        }
      }
      if (!!this.privSuccessCallback) {
        const result = new Exports_js_2.IntentRecognitionResult(
          void 0,
          // Intent Id
          requestId,
          Exports_js_2.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          error,
          void 0,
          // Json
          properties
        );
        try {
          this.privSuccessCallback(result);
          this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  IntentServiceRecognizer.IntentServiceRecognizer = IntentServiceRecognizer$1;
  return IntentServiceRecognizer;
}
var IntentResponse$1 = {};
Object.defineProperty(IntentResponse$1, "__esModule", { value: true });
IntentResponse$1.IntentResponse = void 0;
class IntentResponse {
  constructor(json) {
    if (json === "") {
      this.privIntentResponse = {};
    } else {
      this.privIntentResponse = JSON.parse(json);
    }
  }
  static fromJSON(json) {
    return new IntentResponse(json);
  }
  get query() {
    return this.privIntentResponse.query;
  }
  get topScoringIntent() {
    return this.privIntentResponse.topScoringIntent;
  }
  get entities() {
    return this.privIntentResponse.entities;
  }
}
IntentResponse$1.IntentResponse = IntentResponse;
var SpeakerResponse = {};
Object.defineProperty(SpeakerResponse, "__esModule", { value: true });
var RequestSession$1 = {};
var ServiceTelemetryListener_Internal = {};
Object.defineProperty(ServiceTelemetryListener_Internal, "__esModule", { value: true });
ServiceTelemetryListener_Internal.ServiceTelemetryListener = void 0;
const Exports_js_1$5 = requireExports$5();
const RecognitionEvents_js_1$1 = RecognitionEvents;
class ServiceTelemetryListener {
  constructor(requestId, audioSourceId, audioNodeId) {
    this.privIsDisposed = false;
    this.privListeningTriggerMetric = null;
    this.privMicMetric = null;
    this.privConnectionEstablishMetric = null;
    this.privRequestId = requestId;
    this.privAudioSourceId = audioSourceId;
    this.privAudioNodeId = audioNodeId;
    this.privReceivedMessages = {};
    this.privPhraseLatencies = [];
    this.privHypothesisLatencies = [];
  }
  phraseReceived(audioReceivedTime) {
    if (audioReceivedTime > 0) {
      this.privPhraseLatencies.push(Date.now() - audioReceivedTime);
    }
  }
  hypothesisReceived(audioReceivedTime) {
    if (audioReceivedTime > 0) {
      this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);
    }
  }
  onEvent(e) {
    if (this.privIsDisposed) {
      return;
    }
    if (e instanceof RecognitionEvents_js_1$1.RecognitionTriggeredEvent && e.requestId === this.privRequestId) {
      this.privListeningTriggerMetric = {
        End: e.eventTime,
        Name: "ListeningTrigger",
        Start: e.eventTime
      };
    }
    if (e instanceof Exports_js_1$5.AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      this.privMicStartTime = e.eventTime;
    }
    if (e instanceof Exports_js_1$5.AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      this.privMicStartTime = e.eventTime;
    }
    if (e instanceof Exports_js_1$5.AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {
      if (!this.privMicMetric) {
        this.privMicMetric = {
          End: e.eventTime,
          Error: e.error,
          Name: "Microphone",
          Start: this.privMicStartTime
        };
      }
    }
    if (e instanceof Exports_js_1$5.AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      if (!this.privMicMetric) {
        this.privMicMetric = {
          End: e.eventTime,
          Error: e.error,
          Name: "Microphone",
          Start: this.privMicStartTime
        };
      }
    }
    if (e instanceof Exports_js_1$5.AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      if (!this.privMicMetric) {
        this.privMicMetric = {
          End: e.eventTime,
          Name: "Microphone",
          Start: this.privMicStartTime
        };
      }
    }
    if (e instanceof RecognitionEvents_js_1$1.ConnectingToServiceEvent && e.requestId === this.privRequestId) {
      this.privConnectionId = e.sessionId;
    }
    if (e instanceof Exports_js_1$5.ConnectionStartEvent && e.connectionId === this.privConnectionId) {
      this.privConnectionStartTime = e.eventTime;
    }
    if (e instanceof Exports_js_1$5.ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {
      if (!this.privConnectionEstablishMetric) {
        this.privConnectionEstablishMetric = {
          End: e.eventTime,
          Id: this.privConnectionId,
          Name: "Connection",
          Start: this.privConnectionStartTime
        };
      }
    }
    if (e instanceof Exports_js_1$5.ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {
      if (!this.privConnectionEstablishMetric) {
        this.privConnectionEstablishMetric = {
          End: e.eventTime,
          Error: this.getConnectionError(e.statusCode),
          Id: this.privConnectionId,
          Name: "Connection",
          Start: this.privConnectionStartTime
        };
      }
    }
    if (e instanceof Exports_js_1$5.ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {
      if (e.message && e.message.headers && e.message.headers.path) {
        if (!this.privReceivedMessages[e.message.headers.path]) {
          this.privReceivedMessages[e.message.headers.path] = new Array();
        }
        const maxMessagesToSend = 50;
        if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {
          this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);
        }
      }
    }
  }
  getTelemetry() {
    const metrics = new Array();
    if (this.privListeningTriggerMetric) {
      metrics.push(this.privListeningTriggerMetric);
    }
    if (this.privMicMetric) {
      metrics.push(this.privMicMetric);
    }
    if (this.privConnectionEstablishMetric) {
      metrics.push(this.privConnectionEstablishMetric);
    }
    if (this.privPhraseLatencies.length > 0) {
      metrics.push({
        PhraseLatencyMs: this.privPhraseLatencies
      });
    }
    if (this.privHypothesisLatencies.length > 0) {
      metrics.push({
        FirstHypothesisLatencyMs: this.privHypothesisLatencies
      });
    }
    const telemetry = {
      Metrics: metrics,
      ReceivedMessages: this.privReceivedMessages
    };
    const json = JSON.stringify(telemetry);
    this.privReceivedMessages = {};
    this.privListeningTriggerMetric = null;
    this.privMicMetric = null;
    this.privConnectionEstablishMetric = null;
    this.privPhraseLatencies = [];
    this.privHypothesisLatencies = [];
    return json;
  }
  // Determines if there are any telemetry events to send to the service.
  get hasTelemetry() {
    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
  }
  dispose() {
    this.privIsDisposed = true;
  }
  getConnectionError(statusCode) {
    switch (statusCode) {
      case 400:
      case 1002:
      case 1003:
      case 1005:
      case 1007:
      case 1008:
      case 1009:
        return "BadRequest";
      case 401:
        return "Unauthorized";
      case 403:
        return "Forbidden";
      case 503:
      case 1001:
        return "ServerUnavailable";
      case 500:
      case 1011:
        return "ServerError";
      case 408:
      case 504:
        return "Timeout";
      default:
        return "statuscode:" + statusCode.toString();
    }
  }
}
ServiceTelemetryListener_Internal.ServiceTelemetryListener = ServiceTelemetryListener;
Object.defineProperty(RequestSession$1, "__esModule", { value: true });
RequestSession$1.RequestSession = void 0;
const Exports_js_1$4 = requireExports$5();
const RecognitionEvents_js_1 = RecognitionEvents;
const ServiceTelemetryListener_Internal_js_1 = ServiceTelemetryListener_Internal;
class RequestSession {
  constructor(audioSourceId) {
    this.privIsDisposed = false;
    this.privDetachables = new Array();
    this.privIsAudioNodeDetached = false;
    this.privIsRecognizing = false;
    this.privIsSpeechEnded = false;
    this.privTurnStartAudioOffset = 0;
    this.privLastRecoOffset = 0;
    this.privHypothesisReceived = false;
    this.privBytesSent = 0;
    this.privRecognitionBytesSent = 0;
    this.privRecogNumber = 0;
    this.privInTurn = false;
    this.privConnectionAttempts = 0;
    this.privAudioSourceId = audioSourceId;
    this.privRequestId = Exports_js_1$4.createNoDashGuid();
    this.privAudioNodeId = Exports_js_1$4.createNoDashGuid();
    this.privTurnDeferral = new Exports_js_1$4.Deferred();
    this.privTurnDeferral.resolve();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
  get turnCompletionPromise() {
    return this.privTurnDeferral.promise;
  }
  get isSpeechEnded() {
    return this.privIsSpeechEnded;
  }
  get isRecognizing() {
    return this.privIsRecognizing;
  }
  get currentTurnAudioOffset() {
    return this.privTurnStartAudioOffset;
  }
  get recogNumber() {
    return this.privRecogNumber;
  }
  get numConnectionAttempts() {
    return this.privConnectionAttempts;
  }
  // The number of bytes sent for the current connection.
  // Counter is reset to 0 each time a connection is established.
  get bytesSent() {
    return this.privBytesSent;
  }
  // The number of bytes sent for the current recognition.
  // Counter is reset to 0 each time recognition is started.
  get recognitionBytesSent() {
    return this.privRecognitionBytesSent;
  }
  listenForServiceTelemetry(eventSource) {
    if (!!this.privServiceTelemetryListener) {
      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));
    }
  }
  startNewRecognition() {
    this.privRecognitionBytesSent = 0;
    this.privIsSpeechEnded = false;
    this.privIsRecognizing = true;
    this.privTurnStartAudioOffset = 0;
    this.privLastRecoOffset = 0;
    this.privRecogNumber++;
    this.privServiceTelemetryListener = new ServiceTelemetryListener_Internal_js_1.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);
    this.onEvent(new RecognitionEvents_js_1.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
  }
  async onAudioSourceAttachCompleted(audioNode, isError) {
    this.privAudioNode = audioNode;
    this.privIsAudioNodeDetached = false;
    if (isError) {
      await this.onComplete();
    } else {
      this.onEvent(new RecognitionEvents_js_1.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
  }
  onPreConnectionStart(authFetchEventId, connectionId) {
    this.privAuthFetchEventId = authFetchEventId;
    this.privSessionId = connectionId;
    this.onEvent(new RecognitionEvents_js_1.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
  }
  async onAuthCompleted(isError) {
    if (isError) {
      await this.onComplete();
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async onConnectionEstablishCompleted(statusCode, reason) {
    if (statusCode === 200) {
      this.onEvent(new RecognitionEvents_js_1.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));
      if (!!this.privAudioNode) {
        this.privAudioNode.replay();
      }
      this.privTurnStartAudioOffset = this.privLastRecoOffset;
      this.privBytesSent = 0;
      return;
    } else if (statusCode === 403) {
      await this.onComplete();
    }
  }
  async onServiceTurnEndResponse(continuousRecognition) {
    this.privTurnDeferral.resolve();
    if (!continuousRecognition || this.isSpeechEnded) {
      await this.onComplete();
      this.privInTurn = false;
    } else {
      this.privTurnStartAudioOffset = this.privLastRecoOffset;
      this.privAudioNode.replay();
    }
  }
  onSpeechContext() {
    this.privRequestId = Exports_js_1$4.createNoDashGuid();
  }
  onServiceTurnStartResponse() {
    if (!!this.privTurnDeferral && !!this.privInTurn) {
      this.privTurnDeferral.reject("Another turn started before current completed.");
      this.privTurnDeferral.promise.then().catch(() => {
      });
    }
    this.privInTurn = true;
    this.privTurnDeferral = new Exports_js_1$4.Deferred();
  }
  onHypothesis(offset) {
    if (!this.privHypothesisReceived) {
      this.privHypothesisReceived = true;
      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));
    }
  }
  onPhraseRecognized(offset) {
    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));
    this.onServiceRecognized(offset);
  }
  onServiceRecognized(offset) {
    this.privLastRecoOffset = offset;
    this.privHypothesisReceived = false;
    this.privAudioNode.shrinkBuffers(offset);
    this.privConnectionAttempts = 0;
  }
  onAudioSent(bytesSent) {
    this.privBytesSent += bytesSent;
    this.privRecognitionBytesSent += bytesSent;
  }
  onRetryConnection() {
    this.privConnectionAttempts++;
  }
  async dispose() {
    if (!this.privIsDisposed) {
      this.privIsDisposed = true;
      for (const detachable of this.privDetachables) {
        await detachable.detach();
      }
      if (!!this.privServiceTelemetryListener) {
        this.privServiceTelemetryListener.dispose();
      }
      this.privIsRecognizing = false;
    }
  }
  getTelemetry() {
    if (this.privServiceTelemetryListener.hasTelemetry) {
      return this.privServiceTelemetryListener.getTelemetry();
    } else {
      return null;
    }
  }
  async onStopRecognizing() {
    await this.onComplete();
  }
  // Should be called with the audioNode for this session has indicated that it is out of speech.
  onSpeechEnded() {
    this.privIsSpeechEnded = true;
  }
  onEvent(event) {
    if (!!this.privServiceTelemetryListener) {
      this.privServiceTelemetryListener.onEvent(event);
    }
    Exports_js_1$4.Events.instance.onEvent(event);
  }
  async onComplete() {
    if (!!this.privIsRecognizing) {
      this.privIsRecognizing = false;
      await this.detachAudioNode();
    }
  }
  async detachAudioNode() {
    if (!this.privIsAudioNodeDetached) {
      this.privIsAudioNodeDetached = true;
      if (this.privAudioNode) {
        await this.privAudioNode.detach();
      }
    }
  }
}
RequestSession$1.RequestSession = RequestSession;
var SpeechContext$1 = {};
Object.defineProperty(SpeechContext$1, "__esModule", { value: true });
SpeechContext$1.SpeechContext = void 0;
class SpeechContext {
  constructor(dynamicGrammar) {
    this.privContext = {};
    this.privDynamicGrammar = dynamicGrammar;
  }
  /**
   * Gets a section of the speech.context object.
   * @param sectionName Name of the section to get.
   * @return string or Context JSON serializable object that represents the value.
   */
  getSection(sectionName) {
    return this.privContext[sectionName] || {};
  }
  /**
   * Adds a section to the speech.context object.
   * @param sectionName Name of the section to add.
   * @param value JSON serializable object that represents the value.
   */
  setSection(sectionName, value) {
    this.privContext[sectionName] = value;
  }
  /**
   * @Internal
   * This is only used by pronunciation assessment config.
   * Do not use externally, object returned will change without warning or notice.
   */
  setPronunciationAssessmentParams(params, contentAssessmentTopic, isSpeakerDiarizationEnabled = false) {
    if (this.privContext.phraseDetection === void 0) {
      this.privContext.phraseDetection = {
        enrichment: {
          pronunciationAssessment: {}
        }
      };
    }
    if (this.privContext.phraseDetection.enrichment === void 0) {
      this.privContext.phraseDetection.enrichment = {
        pronunciationAssessment: {}
      };
    }
    this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(params);
    if (isSpeakerDiarizationEnabled) {
      this.privContext.phraseDetection.mode = "Conversation";
    }
    this.setWordLevelTimings();
    this.privContext.phraseOutput.detailed.options.push("PronunciationAssessment");
    if (this.privContext.phraseOutput.detailed.options.indexOf("SNR") === -1) {
      this.privContext.phraseOutput.detailed.options.push("SNR");
    }
    if (!!contentAssessmentTopic) {
      this.privContext.phraseDetection.enrichment.contentAssessment = {
        topic: contentAssessmentTopic
      };
      this.privContext.phraseOutput.detailed.options.push("ContentAssessment");
    }
  }
  setDetailedOutputFormat() {
    if (this.privContext.phraseOutput === void 0) {
      this.privContext.phraseOutput = {
        detailed: {
          options: []
        },
        format: {}
      };
    }
    if (this.privContext.phraseOutput.detailed === void 0) {
      this.privContext.phraseOutput.detailed = {
        options: []
      };
    }
    this.privContext.phraseOutput.format = "Detailed";
  }
  setWordLevelTimings() {
    if (this.privContext.phraseOutput === void 0) {
      this.privContext.phraseOutput = {
        detailed: {
          options: []
        },
        format: {}
      };
    }
    if (this.privContext.phraseOutput.detailed === void 0) {
      this.privContext.phraseOutput.detailed = {
        options: []
      };
    }
    this.privContext.phraseOutput.format = "Detailed";
    if (this.privContext.phraseOutput.detailed.options.indexOf("WordTimings") === -1) {
      this.privContext.phraseOutput.detailed.options.push("WordTimings");
    }
  }
  setSpeakerDiarizationAudioOffsetMs(audioOffsetMs) {
    this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = audioOffsetMs;
  }
  toJSON() {
    const dgi = this.privDynamicGrammar.generateGrammarObject();
    this.setSection("dgi", dgi);
    const ret = JSON.stringify(this.privContext);
    return ret;
  }
}
SpeechContext$1.SpeechContext = SpeechContext;
var DynamicGrammarBuilder$1 = {};
Object.defineProperty(DynamicGrammarBuilder$1, "__esModule", { value: true });
DynamicGrammarBuilder$1.DynamicGrammarBuilder = void 0;
class DynamicGrammarBuilder {
  // Adds one more reference phrases to the dynamic grammar to send.
  // All added phrases are generic phrases.
  addPhrase(phrase) {
    if (!this.privPhrases) {
      this.privPhrases = [];
    }
    if (phrase instanceof Array) {
      this.privPhrases = this.privPhrases.concat(phrase);
    } else {
      this.privPhrases.push(phrase);
    }
  }
  // Clears all phrases stored in the current object.
  clearPhrases() {
    this.privPhrases = void 0;
  }
  // Adds one or more reference grammars to the current grammar.
  addReferenceGrammar(grammar) {
    if (!this.privGrammars) {
      this.privGrammars = [];
    }
    if (grammar instanceof Array) {
      this.privGrammars = this.privGrammars.concat(grammar);
    } else {
      this.privGrammars.push(grammar);
    }
  }
  // clears all grammars stored on the recognizer.
  clearGrammars() {
    this.privGrammars = void 0;
  }
  // Generates an object that represents the dynamic grammar used by the Speech Service.
  // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
  // of a DynamicGrammarBuilder
  generateGrammarObject() {
    if (this.privGrammars === void 0 && this.privPhrases === void 0) {
      return void 0;
    }
    const retObj = {};
    retObj.ReferenceGrammars = this.privGrammars;
    if (void 0 !== this.privPhrases && 0 !== this.privPhrases.length) {
      const retPhrases = [];
      this.privPhrases.forEach((value) => {
        retPhrases.push({
          Text: value
        });
      });
      retObj.Groups = [{ Type: "Generic", Items: retPhrases }];
    }
    return retObj;
  }
}
DynamicGrammarBuilder$1.DynamicGrammarBuilder = DynamicGrammarBuilder;
var DynamicGrammarInterfaces = {};
Object.defineProperty(DynamicGrammarInterfaces, "__esModule", { value: true });
var DialogServiceAdapter = {};
var DialogServiceTurnStateManager$1 = {};
var DialogServiceTurnState$1 = {};
var ActivityResponsePayload = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageDataStreamType = exports.ActivityPayloadResponse = void 0;
  class ActivityPayloadResponse {
    constructor(json) {
      this.privActivityResponse = JSON.parse(json);
    }
    static fromJSON(json) {
      return new ActivityPayloadResponse(json);
    }
    get conversationId() {
      return this.privActivityResponse.conversationId;
    }
    get messageDataStreamType() {
      return this.privActivityResponse.messageDataStreamType;
    }
    get messagePayload() {
      return this.privActivityResponse.messagePayload;
    }
    get version() {
      return this.privActivityResponse.version;
    }
  }
  exports.ActivityPayloadResponse = ActivityPayloadResponse;
  (function(MessageDataStreamType) {
    MessageDataStreamType[MessageDataStreamType["None"] = 0] = "None";
    MessageDataStreamType[MessageDataStreamType["TextToSpeechAudio"] = 1] = "TextToSpeechAudio";
  })(exports.MessageDataStreamType || (exports.MessageDataStreamType = {}));
})(ActivityResponsePayload);
Object.defineProperty(DialogServiceTurnState$1, "__esModule", { value: true });
DialogServiceTurnState$1.DialogServiceTurnState = void 0;
const AudioOutputFormat_js_1 = AudioOutputFormat;
const AudioOutputStream_js_1 = AudioOutputStream$1;
const ActivityResponsePayload_js_1 = ActivityResponsePayload;
class DialogServiceTurnState {
  constructor(manager, requestId) {
    this.privRequestId = requestId;
    this.privIsCompleted = false;
    this.privAudioStream = null;
    this.privTurnManager = manager;
    this.resetTurnEndTimeout();
  }
  get audioStream() {
    this.resetTurnEndTimeout();
    return this.privAudioStream;
  }
  processActivityPayload(payload, audioFormat) {
    if (payload.messageDataStreamType === ActivityResponsePayload_js_1.MessageDataStreamType.TextToSpeechAudio) {
      this.privAudioStream = AudioOutputStream_js_1.AudioOutputStream.createPullStream();
      this.privAudioStream.format = audioFormat !== void 0 ? audioFormat : AudioOutputFormat_js_1.AudioOutputFormatImpl.getDefaultOutputFormat();
    }
    return this.privAudioStream;
  }
  endAudioStream() {
    if (this.privAudioStream !== null && !this.privAudioStream.isClosed) {
      this.privAudioStream.close();
    }
  }
  complete() {
    if (this.privTimeoutToken !== void 0) {
      clearTimeout(this.privTimeoutToken);
    }
    this.endAudioStream();
  }
  resetTurnEndTimeout() {
    if (this.privTimeoutToken !== void 0) {
      clearTimeout(this.privTimeoutToken);
    }
    this.privTimeoutToken = setTimeout(() => {
      this.privTurnManager.CompleteTurn(this.privRequestId);
      return;
    }, 2e3);
  }
}
DialogServiceTurnState$1.DialogServiceTurnState = DialogServiceTurnState;
Object.defineProperty(DialogServiceTurnStateManager$1, "__esModule", { value: true });
DialogServiceTurnStateManager$1.DialogServiceTurnStateManager = void 0;
const Error_js_1 = _Error;
const DialogServiceTurnState_js_1 = DialogServiceTurnState$1;
class DialogServiceTurnStateManager {
  constructor() {
    this.privTurnMap = /* @__PURE__ */ new Map();
    return;
  }
  StartTurn(id2) {
    if (this.privTurnMap.has(id2)) {
      throw new Error_js_1.InvalidOperationError("Service error: There is already a turn with id:" + id2);
    }
    const turnState = new DialogServiceTurnState_js_1.DialogServiceTurnState(this, id2);
    this.privTurnMap.set(id2, turnState);
    return this.privTurnMap.get(id2);
  }
  GetTurn(id2) {
    return this.privTurnMap.get(id2);
  }
  CompleteTurn(id2) {
    if (!this.privTurnMap.has(id2)) {
      throw new Error_js_1.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + id2);
    }
    const turnState = this.privTurnMap.get(id2);
    turnState.complete();
    this.privTurnMap.delete(id2);
    return turnState;
  }
}
DialogServiceTurnStateManager$1.DialogServiceTurnStateManager = DialogServiceTurnStateManager;
var hasRequiredDialogServiceAdapter;
function requireDialogServiceAdapter() {
  if (hasRequiredDialogServiceAdapter) return DialogServiceAdapter;
  hasRequiredDialogServiceAdapter = 1;
  Object.defineProperty(DialogServiceAdapter, "__esModule", { value: true });
  DialogServiceAdapter.DialogServiceAdapter = void 0;
  const Exports_js_12 = requireExports$2();
  const DialogEvents_js_1 = DialogEvents;
  const Exports_js_2 = requireExports$5();
  const AudioOutputFormat_js_12 = AudioOutputFormat;
  const Exports_js_3 = requireExports$3();
  const DialogServiceTurnStateManager_js_1 = DialogServiceTurnStateManager$1;
  const Exports_js_4 = requireExports();
  const ActivityResponsePayload_js_12 = ActivityResponsePayload;
  const SpeechConnectionMessage_Internal_js_1 = SpeechConnectionMessage_Internal;
  let DialogServiceAdapter$1 = class DialogServiceAdapter extends Exports_js_4.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);
      this.privEvents = new Exports_js_2.EventSource();
      this.privDialogServiceConnector = dialogServiceConnector;
      this.receiveMessageOverride = () => this.receiveDialogMessageOverride();
      this.privTurnStateManager = new DialogServiceTurnStateManager_js_1.DialogServiceTurnStateManager();
      this.recognizeOverride = (recoMode, successCallback, errorCallback) => this.listenOnce(recoMode, successCallback, errorCallback);
      this.postConnectImplOverride = (connection) => this.dialogConnectImpl(connection);
      this.configConnectionOverride = (connection) => this.configConnection(connection);
      this.disconnectOverride = () => this.privDisconnect();
      this.privDialogAudioSource = audioSource;
      this.agentConfigSent = false;
      this.privLastResult = null;
      this.connectionEvents.attach((connectionEvent) => {
        if (connectionEvent.name === "ConnectionClosedEvent") {
          this.terminateMessageLoop = true;
        }
      });
    }
    async sendMessage(message) {
      const interactionGuid = Exports_js_2.createGuid();
      const requestId = Exports_js_2.createNoDashGuid();
      const agentMessage = {
        context: {
          interactionId: interactionGuid
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(message),
        version: 0.5
      };
      const agentMessageJson = JSON.stringify(agentMessage);
      const connection = await this.fetchConnection();
      await connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "agent", requestId, "application/json", agentMessageJson));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.NoError, "Disconnecting");
      this.terminateMessageLoop = true;
      this.agentConfigSent = false;
      return;
    }
    processTypeSpecificMessages(connectionMessage) {
      const resultProps = new Exports_js_3.PropertyCollection();
      if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {
        resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      }
      let result;
      let processed;
      switch (connectionMessage.path.toLowerCase()) {
        case "speech.phrase":
          const speechPhrase = Exports_js_4.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);
          this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);
          if (speechPhrase.RecognitionStatus !== Exports_js_4.RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== Exports_js_4.RecognitionStatus.Error) {
            const args = this.fireEventForResult(speechPhrase, resultProps);
            this.privLastResult = args.result;
            if (!!this.privDialogServiceConnector.recognized) {
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);
              } catch (error) {
              }
            }
          }
          processed = true;
          break;
        case "speech.hypothesis":
          const hypothesis = Exports_js_4.SpeechHypothesis.fromJSON(connectionMessage.textBody);
          const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
          result = new Exports_js_3.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_js_3.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, void 0, void 0, connectionMessage.textBody, resultProps);
          this.privRequestSession.onHypothesis(offset);
          const ev = new Exports_js_3.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
          if (!!this.privDialogServiceConnector.recognizing) {
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);
            } catch (error) {
            }
          }
          processed = true;
          break;
        case "speech.keyword":
          const keyword = Exports_js_4.SpeechKeyword.fromJSON(connectionMessage.textBody);
          result = new Exports_js_3.SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === "Accepted" ? Exports_js_3.ResultReason.RecognizedKeyword : Exports_js_3.ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, void 0, void 0, void 0, void 0, connectionMessage.textBody, resultProps);
          if (keyword.Status !== "Accepted") {
            this.privLastResult = result;
          }
          const event = new Exports_js_3.SpeechRecognitionEventArgs(result, result.duration, result.resultId);
          if (!!this.privDialogServiceConnector.recognized) {
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);
            } catch (error) {
            }
          }
          processed = true;
          break;
        case "audio":
          {
            const audioRequestId = connectionMessage.requestId.toUpperCase();
            const turn = this.privTurnStateManager.GetTurn(audioRequestId);
            try {
              if (!connectionMessage.binaryBody) {
                turn.endAudioStream();
              } else {
                turn.audioStream.write(connectionMessage.binaryBody);
              }
            } catch (error) {
            }
          }
          processed = true;
          break;
        case "response":
          {
            this.handleResponseMessage(connectionMessage);
          }
          processed = true;
          break;
      }
      const defferal = new Exports_js_2.Deferred();
      defferal.resolve(processed);
      return defferal.promise;
    }
    // Cancels recognition.
    async cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      this.terminateMessageLoop = true;
      if (!!this.privRequestSession.isRecognizing) {
        await this.privRequestSession.onStopRecognizing();
      }
      if (!!this.privDialogServiceConnector.canceled) {
        const properties = new Exports_js_3.PropertyCollection();
        properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);
        const cancelEvent = new Exports_js_3.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);
        } catch {
        }
        if (!!this.privSuccessCallback) {
          const result = new Exports_js_3.SpeechRecognitionResult(
            void 0,
            // ResultId
            Exports_js_3.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            error,
            void 0,
            // Json
            properties
          );
          try {
            this.privSuccessCallback(result);
            this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(recoMode, successCallback, errorCallback) {
      this.privRecognizerConfig.recognitionMode = recoMode;
      this.privSuccessCallback = successCallback;
      this.privErrorCallback = errorCallback;
      this.privRequestSession.startNewRecognition();
      this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);
      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const conPromise = this.connectImpl();
      const preAudioPromise = this.sendPreAudioMessages();
      const node2 = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);
      const format = await this.privDialogAudioSource.format;
      const deviceInfo = await this.privDialogAudioSource.deviceInfo;
      const audioNode = new Exports_js_12.ReplayableAudioNode(node2, format.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };
      try {
        await conPromise;
        await preAudioPromise;
      } catch (error) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, error);
        return Promise.resolve();
      }
      const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
      if (!!this.privRecognizer.sessionStarted) {
        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
      }
      const audioSendPromise = this.sendAudio(audioNode);
      audioSendPromise.then(() => {
      }, async (error) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(connection) {
      this.privConnectionLoop = this.startMessageLoop();
      return connection;
    }
    receiveDialogMessageOverride() {
      const communicationCustodian = new Exports_js_2.Deferred();
      const loop = async () => {
        try {
          const isDisposed = this.isDisposed();
          const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;
          if (isDisposed || terminateMessageLoop) {
            communicationCustodian.resolve(void 0);
            return;
          }
          const connection = await this.fetchConnection();
          const message = await connection.read();
          if (!message) {
            return loop();
          }
          const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);
          switch (connectionMessage.path.toLowerCase()) {
            case "turn.start":
              {
                const turnRequestId = connectionMessage.requestId.toUpperCase();
                const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();
                if (turnRequestId !== audioSessionReqId) {
                  this.privTurnStateManager.StartTurn(turnRequestId);
                } else {
                  this.privRequestSession.onServiceTurnStartResponse();
                }
              }
              break;
            case "speech.startdetected":
              const speechStartDetected = Exports_js_4.SpeechDetected.fromJSON(connectionMessage.textBody);
              const speechStartEventArgs = new Exports_js_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
              if (!!this.privRecognizer.speechStartDetected) {
                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
              }
              break;
            case "speech.enddetected":
              let json;
              if (connectionMessage.textBody.length > 0) {
                json = connectionMessage.textBody;
              } else {
                json = "{ Offset: 0 }";
              }
              const speechStopDetected = Exports_js_4.SpeechDetected.fromJSON(json);
              this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);
              const speechStopEventArgs = new Exports_js_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              if (!!this.privRecognizer.speechEndDetected) {
                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
              }
              break;
            case "turn.end":
              {
                const turnEndRequestId = connectionMessage.requestId.toUpperCase();
                const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();
                if (turnEndRequestId !== audioSessionReqId) {
                  this.privTurnStateManager.CompleteTurn(turnEndRequestId);
                } else {
                  const sessionStopEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
                  await this.privRequestSession.onServiceTurnEndResponse(false);
                  if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                    if (!!this.privRecognizer.sessionStopped) {
                      this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);
                    }
                  }
                  if (!!this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult);
                      this.privLastResult = null;
                    } catch (e) {
                      if (!!this.privErrorCallback) {
                        this.privErrorCallback(e);
                      }
                    }
                    this.privSuccessCallback = void 0;
                    this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                const processed = await this.processTypeSpecificMessages(connectionMessage);
                if (!processed) {
                  if (!!this.serviceEvents) {
                    this.serviceEvents.onEvent(new Exports_js_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                  }
                }
              } catch (e) {
              }
          }
          const ret = loop();
          return ret;
        } catch (error) {
          this.terminateMessageLoop = true;
          communicationCustodian.resolve();
        }
      };
      loop().catch((reason) => {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));
      });
      return communicationCustodian.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = false;
      try {
        await this.receiveDialogMessageOverride();
      } catch (error) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(connection) {
      if (this.terminateMessageLoop) {
        this.terminateMessageLoop = false;
        return Promise.reject("Connection to service terminated.");
      }
      await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());
      await this.sendAgentConfig(connection);
      return connection;
    }
    async sendPreAudioMessages() {
      const connection = await this.fetchConnection();
      this.addKeywordContextData();
      await this.sendSpeechContext(connection, true);
      await this.sendAgentContext(connection);
      await this.sendWaveHeader(connection);
    }
    sendAgentConfig(connection) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.Conversation_DialogType) === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands) {
          const config = this.agentConfig.get();
          config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us");
          this.agentConfig.set(config);
        }
        this.onEvent(new DialogEvents_js_1.SendingAgentContextMessageEvent(this.agentConfig));
        const agentConfigJson = this.agentConfig.toJsonString();
        this.agentConfigSent = true;
        return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", agentConfigJson));
      }
      return;
    }
    sendAgentContext(connection) {
      const guid = Exports_js_2.createGuid();
      const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(Exports_js_3.PropertyId.Conversation_Speech_Activity_Template);
      const agentContext = {
        channelData: "",
        context: {
          interactionId: guid
        },
        messagePayload: typeof speechActivityTemplate === void 0 ? void 0 : speechActivityTemplate,
        version: 0.5
      };
      const agentContextJson = JSON.stringify(agentContext);
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", agentContextJson));
    }
    fireEventForResult(serviceResult, properties) {
      const resultReason = Exports_js_4.EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);
      const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;
      const result = new Exports_js_3.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, void 0, void 0, JSON.stringify(serviceResult), properties);
      const ev = new Exports_js_3.SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);
      return ev;
    }
    handleResponseMessage(responseMessage) {
      const responsePayload = JSON.parse(responseMessage.textBody);
      switch (responsePayload.messageType.toLowerCase()) {
        case "message":
          const responseRequestId = responseMessage.requestId.toUpperCase();
          const activityPayload = ActivityResponsePayload_js_12.ActivityPayloadResponse.fromJSON(responseMessage.textBody);
          const turn = this.privTurnStateManager.GetTurn(responseRequestId);
          if (activityPayload.conversationId) {
            const updateAgentConfig = this.agentConfig.get();
            updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;
            this.agentConfig.set(updateAgentConfig);
          }
          const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormat_js_12.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)));
          const activity = new Exports_js_3.ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);
          if (!!this.privDialogServiceConnector.activityReceived) {
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);
            } catch (error) {
            }
          }
          break;
        case "messagestatus":
          if (!!this.privDialogServiceConnector.turnStatusReceived) {
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new Exports_js_3.TurnStatusReceivedEventArgs(responseMessage.textBody));
            } catch (error) {
            }
          }
          break;
        default:
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(event) {
      this.privEvents.onEvent(event);
      Exports_js_2.Events.instance.onEvent(event);
    }
    addKeywordContextData() {
      const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (keywordPropertyValue === void 0) {
        return;
      }
      const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets");
      const keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations");
      const keywords = keywordPropertyValue.split(";");
      const keywordOffsets = keywordOffsetPropertyValue === void 0 ? [] : keywordOffsetPropertyValue.split(";");
      const keywordDurations = keywordDurationPropertyValue === void 0 ? [] : keywordDurationPropertyValue.split(";");
      const keywordDefinitionArray = [];
      for (let i = 0; i < keywords.length; i++) {
        const definition2 = {};
        definition2.text = keywords[i];
        if (i < keywordOffsets.length) {
          definition2.offset = Number(keywordOffsets[i]);
        }
        if (i < keywordDurations.length) {
          definition2.duration = Number(keywordDurations[i]);
        }
        keywordDefinitionArray.push(definition2);
      }
      this.speechContext.setSection("invocationSource", "VoiceActivationWithKeyword");
      this.speechContext.setSection("keywordDetection", [{
        clientDetectedKeywords: keywordDefinitionArray,
        onReject: { action: "EndOfTurn" },
        type: "startTrigger"
      }]);
    }
  };
  DialogServiceAdapter.DialogServiceAdapter = DialogServiceAdapter$1;
  return DialogServiceAdapter;
}
var AgentConfig$1 = {};
Object.defineProperty(AgentConfig$1, "__esModule", { value: true });
AgentConfig$1.AgentConfig = void 0;
class AgentConfig {
  toJsonString() {
    return JSON.stringify(this.iPrivConfig);
  }
  get() {
    return this.iPrivConfig;
  }
  /**
   * Setter for the agent.config object.
   * @param value a JSON serializable object.
   */
  set(value) {
    this.iPrivConfig = value;
  }
}
AgentConfig$1.AgentConfig = AgentConfig;
var Exports$1 = {};
var ConversationManager = {};
var ConversationConnectionConfig$1 = {};
Object.defineProperty(ConversationConnectionConfig$1, "__esModule", { value: true });
ConversationConnectionConfig$1.ConversationConnectionConfig = void 0;
const RestConfigBase_js_1 = RestConfigBase$1;
class ConversationConnectionConfig extends RestConfigBase_js_1.RestConfigBase {
  static get host() {
    return ConversationConnectionConfig.privHost;
  }
  static get apiVersion() {
    return ConversationConnectionConfig.privApiVersion;
  }
  static get clientAppId() {
    return ConversationConnectionConfig.privClientAppId;
  }
  static get defaultLanguageCode() {
    return ConversationConnectionConfig.privDefaultLanguageCode;
  }
  static get restPath() {
    return ConversationConnectionConfig.privRestPath;
  }
  static get webSocketPath() {
    return ConversationConnectionConfig.privWebSocketPath;
  }
  static get transcriptionEventKeys() {
    return ConversationConnectionConfig.privTranscriptionEventKeys;
  }
}
ConversationConnectionConfig$1.ConversationConnectionConfig = ConversationConnectionConfig;
ConversationConnectionConfig.privHost = "dev.microsofttranslator.com";
ConversationConnectionConfig.privRestPath = "/capito/room";
ConversationConnectionConfig.privApiVersion = "2.0";
ConversationConnectionConfig.privDefaultLanguageCode = "en-US";
ConversationConnectionConfig.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15";
ConversationConnectionConfig.privWebSocketPath = "/capito/translate";
ConversationConnectionConfig.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"];
var hasRequiredConversationManager;
function requireConversationManager() {
  if (hasRequiredConversationManager) return ConversationManager;
  hasRequiredConversationManager = 1;
  Object.defineProperty(ConversationManager, "__esModule", { value: true });
  ConversationManager.ConversationManager = void 0;
  const Exports_js_12 = requireExports$2();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  const ConversationConnectionConfig_js_1 = ConversationConnectionConfig$1;
  let ConversationManager$1 = class ConversationManager {
    constructor() {
      this.privRequestParams = ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams;
      this.privErrors = ConversationConnectionConfig_js_1.ConversationConnectionConfig.restErrors;
      this.privHost = ConversationConnectionConfig_js_1.ConversationConnectionConfig.host;
      this.privApiVersion = ConversationConnectionConfig_js_1.ConversationConnectionConfig.apiVersion;
      this.privRestPath = ConversationConnectionConfig_js_1.ConversationConnectionConfig.restPath;
      this.privRestAdapter = new Exports_js_12.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(args, conversationCode, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfNullOrUndefined(args, "args");
        const languageCode = args.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, ConversationConnectionConfig_js_1.ConversationConnectionConfig.defaultLanguageCode);
        const nickname = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_Name, "conversation_host");
        const endpointHost = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_Host, this.privHost);
        const correlationId = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_CorrelationId);
        const subscriptionKey = args.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key);
        const subscriptionRegion = args.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
        const authToken = args.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(languageCode, "languageCode");
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(endpointHost, "endpointHost");
        const queryParams = {};
        queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;
        queryParams[this.privRequestParams.languageCode] = languageCode;
        queryParams[this.privRequestParams.nickname] = nickname;
        const headers = {};
        if (correlationId) {
          headers[this.privRequestParams.correlationId] = correlationId;
        }
        headers[this.privRequestParams.clientAppId] = ConversationConnectionConfig_js_1.ConversationConnectionConfig.clientAppId;
        if (conversationCode !== void 0) {
          queryParams[this.privRequestParams.roomId] = conversationCode;
        } else {
          Contracts_js_12.Contracts.throwIfNullOrUndefined(subscriptionRegion, this.privErrors.authInvalidSubscriptionRegion);
          headers[this.privRequestParams.subscriptionRegion] = subscriptionRegion;
          if (subscriptionKey) {
            headers[this.privRequestParams.subscriptionKey] = subscriptionKey;
          } else if (authToken) {
            headers[this.privRequestParams.authorization] = `Bearer ${authToken}`;
          } else {
            Contracts_js_12.Contracts.throwIfNullOrUndefined(subscriptionKey, this.privErrors.authInvalidSubscriptionKey);
          }
        }
        const config = {};
        config.headers = headers;
        this.privRestAdapter.options = config;
        const endpoint = `https://${endpointHost}${this.privRestPath}`;
        this.privRestAdapter.request(Exports_js_12.RestRequestType.Post, endpoint, queryParams, null).then((response) => {
          const requestId = Exports_js_12.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, response.headers);
          if (!response.ok) {
            if (!!err2) {
              let errorMessage = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", response.status.toString());
              let errMessageRaw;
              try {
                errMessageRaw = JSON.parse(response.data);
                errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;
              } catch (e) {
                errorMessage += ` [${response.data}]`;
              }
              if (requestId) {
                errorMessage += ` ${requestId}`;
              }
              err2(errorMessage);
            }
            return;
          }
          const conversation = JSON.parse(response.data);
          if (conversation) {
            conversation.requestId = requestId;
          }
          if (!!cb2) {
            try {
              cb2(conversation);
            } catch (e) {
              if (!!err2) {
                err2(e);
              }
            }
            cb2 = void 0;
          }
        }).catch(() => {
        });
      } catch (error) {
        if (!!err2) {
          if (error instanceof Error) {
            const typedError = error;
            err2(typedError.name + ": " + typedError.message);
          } else {
            err2(error);
          }
        }
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(args, sessionToken) {
      return new Promise((resolve, reject) => {
        try {
          Contracts_js_12.Contracts.throwIfNullOrUndefined(args, this.privErrors.invalidArgs.replace("{arg}", "config"));
          Contracts_js_12.Contracts.throwIfNullOrWhitespace(sessionToken, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const endpointHost = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_Host, this.privHost);
          const correlationId = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_CorrelationId);
          const queryParams = {};
          queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;
          queryParams[this.privRequestParams.sessionToken] = sessionToken;
          const headers = {};
          if (correlationId) {
            headers[this.privRequestParams.correlationId] = correlationId;
          }
          const config = {};
          config.headers = headers;
          this.privRestAdapter.options = config;
          const endpoint = `https://${endpointHost}${this.privRestPath}`;
          this.privRestAdapter.request(Exports_js_12.RestRequestType.Delete, endpoint, queryParams, null).then((response) => {
            if (!response.ok) {
            }
            resolve();
          }).catch(() => {
          });
        } catch (error) {
          if (error instanceof Error) {
            const typedError = error;
            reject(typedError.name + ": " + typedError.message);
          } else {
            reject(error);
          }
        }
      });
    }
  };
  ConversationManager.ConversationManager = ConversationManager$1;
  return ConversationManager;
}
var ConversationTranslatorRecognizer = {};
var ConversationConnectionFactory = {};
var ConversationWebsocketMessageFormatter$1 = {};
var ConversationConnectionMessage$1 = {};
Object.defineProperty(ConversationConnectionMessage$1, "__esModule", { value: true });
ConversationConnectionMessage$1.ConversationConnectionMessage = void 0;
const Exports_js_1$3 = requireExports$5();
class ConversationConnectionMessage extends Exports_js_1$3.ConnectionMessage {
  constructor(messageType, body, headers, id2) {
    super(messageType, body, headers, id2);
    const json = JSON.parse(this.textBody);
    if (json.type !== void 0) {
      this.privConversationMessageType = json.type;
    }
  }
  get conversationMessageType() {
    return this.privConversationMessageType;
  }
}
ConversationConnectionMessage$1.ConversationConnectionMessage = ConversationConnectionMessage;
Object.defineProperty(ConversationWebsocketMessageFormatter$1, "__esModule", { value: true });
ConversationWebsocketMessageFormatter$1.ConversationWebsocketMessageFormatter = void 0;
const Exports_js_1$2 = requireExports$5();
const ConversationConnectionMessage_js_1 = ConversationConnectionMessage$1;
class ConversationWebsocketMessageFormatter {
  /**
   * Format incoming messages: text (speech partial/final, IM) or binary (tts)
   */
  toConnectionMessage(message) {
    const deferral = new Exports_js_1$2.Deferred();
    try {
      if (message.messageType === Exports_js_1$2.MessageType.Text) {
        const incomingMessage = new ConversationConnectionMessage_js_1.ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);
        deferral.resolve(incomingMessage);
      } else if (message.messageType === Exports_js_1$2.MessageType.Binary) {
        deferral.resolve(new ConversationConnectionMessage_js_1.ConversationConnectionMessage(message.messageType, message.binaryContent, void 0, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. Error: ${e}`);
    }
    return deferral.promise;
  }
  /**
   * Format outgoing messages: text (commands or IM)
   */
  fromConnectionMessage(message) {
    const deferral = new Exports_js_1$2.Deferred();
    try {
      if (message.messageType === Exports_js_1$2.MessageType.Text) {
        const payload = `${message.textBody ? message.textBody : ""}`;
        deferral.resolve(new Exports_js_1$2.RawWebsocketMessage(Exports_js_1$2.MessageType.Text, payload, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. ${e}`);
    }
    return deferral.promise;
  }
}
ConversationWebsocketMessageFormatter$1.ConversationWebsocketMessageFormatter = ConversationWebsocketMessageFormatter;
var hasRequiredConversationConnectionFactory;
function requireConversationConnectionFactory() {
  if (hasRequiredConversationConnectionFactory) return ConversationConnectionFactory;
  hasRequiredConversationConnectionFactory = 1;
  Object.defineProperty(ConversationConnectionFactory, "__esModule", { value: true });
  ConversationConnectionFactory.ConversationConnectionFactory = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const ConversationConnectionConfig_js_1 = ConversationConnectionConfig$1;
  const ConversationWebsocketMessageFormatter_js_1 = ConversationWebsocketMessageFormatter$1;
  let ConversationConnectionFactory$1 = class ConversationConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
    create(config, authInfo, connectionId) {
      const endpointHost = config.parameters.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Host, ConversationConnectionConfig_js_1.ConversationConnectionConfig.host);
      const correlationId = config.parameters.getProperty(Exports_js_3.PropertyId.ConversationTranslator_CorrelationId, Exports_js_2.createGuid());
      const endpoint = `wss://${endpointHost}${ConversationConnectionConfig_js_1.ConversationConnectionConfig.webSocketPath}`;
      const token = config.parameters.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Token, void 0);
      Contracts_js_12.Contracts.throwIfNullOrUndefined(token, "token");
      const queryParams = {};
      queryParams[ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams.apiVersion] = ConversationConnectionConfig_js_1.ConversationConnectionConfig.apiVersion;
      queryParams[ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams.token] = token;
      queryParams[ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams.correlationId] = correlationId;
      const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new Exports_js_12.WebsocketConnection(endpoint, queryParams, {}, new ConversationWebsocketMessageFormatter_js_1.ConversationWebsocketMessageFormatter(), Exports_js_12.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    }
  };
  ConversationConnectionFactory.ConversationConnectionFactory = ConversationConnectionFactory$1;
  return ConversationConnectionFactory;
}
var ConversationServiceAdapter = {};
var ConversationRequestSession$1 = {};
Object.defineProperty(ConversationRequestSession$1, "__esModule", { value: true });
ConversationRequestSession$1.ConversationRequestSession = void 0;
const Exports_js_1$1 = requireExports$5();
class ConversationRequestSession {
  constructor(sessionId) {
    this.privIsDisposed = false;
    this.privDetachables = new Array();
    this.privSessionId = sessionId;
    this.privRequestId = Exports_js_1$1.createNoDashGuid();
    this.privRequestCompletionDeferral = new Exports_js_1$1.Deferred();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get completionPromise() {
    return this.privRequestCompletionDeferral.promise;
  }
  onPreConnectionStart(authFetchEventId, connectionId) {
    this.privSessionId = connectionId;
  }
  onAuthCompleted(isError) {
    if (isError) {
      this.onComplete();
    }
  }
  onConnectionEstablishCompleted(statusCode) {
    if (statusCode === 200) {
      return;
    } else if (statusCode === 403) {
      this.onComplete();
    }
  }
  onServiceTurnEndResponse(continuousRecognition) {
    if (!continuousRecognition) {
      this.onComplete();
    } else {
      this.privRequestId = Exports_js_1$1.createNoDashGuid();
    }
  }
  async dispose() {
    if (!this.privIsDisposed) {
      this.privIsDisposed = true;
      for (const detachable of this.privDetachables) {
        await detachable.detach();
      }
    }
  }
  onComplete() {
  }
}
ConversationRequestSession$1.ConversationRequestSession = ConversationRequestSession;
var ConversationTranslatorEventArgs = {};
var hasRequiredConversationTranslatorEventArgs;
function requireConversationTranslatorEventArgs() {
  if (hasRequiredConversationTranslatorEventArgs) return ConversationTranslatorEventArgs;
  hasRequiredConversationTranslatorEventArgs = 1;
  Object.defineProperty(ConversationTranslatorEventArgs, "__esModule", { value: true });
  ConversationTranslatorEventArgs.ConversationReceivedTranslationEventArgs = ConversationTranslatorEventArgs.ParticipantsListEventArgs = ConversationTranslatorEventArgs.ParticipantAttributeEventArgs = ConversationTranslatorEventArgs.ParticipantEventArgs = ConversationTranslatorEventArgs.LockRoomEventArgs = ConversationTranslatorEventArgs.MuteAllEventArgs = void 0;
  const Exports_js_12 = requireExports$3();
  class MuteAllEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(isMuted, sessionId) {
      super(sessionId);
      this.privIsMuted = isMuted;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  ConversationTranslatorEventArgs.MuteAllEventArgs = MuteAllEventArgs;
  class LockRoomEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(isLocked, sessionId) {
      super(sessionId);
      this.privIsLocked = isLocked;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  ConversationTranslatorEventArgs.LockRoomEventArgs = LockRoomEventArgs;
  class ParticipantEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(participant, sessionId) {
      super(sessionId);
      this.privParticipant = participant;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  ConversationTranslatorEventArgs.ParticipantEventArgs = ParticipantEventArgs;
  class ParticipantAttributeEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(participantId, key, value, sessionId) {
      super(sessionId);
      this.privKey = key;
      this.privValue = value;
      this.privParticipantId = participantId;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  ConversationTranslatorEventArgs.ParticipantAttributeEventArgs = ParticipantAttributeEventArgs;
  class ParticipantsListEventArgs extends Exports_js_12.SessionEventArgs {
    constructor(conversationId, token, translateTo, profanityFilter, roomProfanityFilter, isRoomLocked, isMuteAll, participants, sessionId) {
      super(sessionId);
      this.privRoomId = conversationId;
      this.privSessionToken = token;
      this.privTranslateTo = translateTo;
      this.privProfanityFilter = profanityFilter;
      this.privRoomProfanityFilter = roomProfanityFilter;
      this.privIsRoomLocked = isRoomLocked;
      this.privIsRoomLocked = isMuteAll;
      this.privParticipants = participants;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  ConversationTranslatorEventArgs.ParticipantsListEventArgs = ParticipantsListEventArgs;
  class ConversationReceivedTranslationEventArgs {
    constructor(command, payload, sessionId) {
      this.privPayload = payload;
      this.privCommand = command;
      this.privSessionId = sessionId;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  ConversationTranslatorEventArgs.ConversationReceivedTranslationEventArgs = ConversationReceivedTranslationEventArgs;
  return ConversationTranslatorEventArgs;
}
var ConversationTranslatorInterfaces = {};
Object.defineProperty(ConversationTranslatorInterfaces, "__esModule", { value: true });
ConversationTranslatorInterfaces.ConversationTranslatorCommandTypes = ConversationTranslatorInterfaces.ConversationTranslatorMessageTypes = ConversationTranslatorInterfaces.InternalParticipants = void 0;
class InternalParticipants {
  constructor(participants = [], meId) {
    this.participants = participants;
    this.meId = meId;
  }
  /**
   * Add or update a participant
   * @param value
   */
  addOrUpdateParticipant(value) {
    if (value === void 0) {
      return;
    }
    const exists = this.getParticipantIndex(value.id);
    if (exists > -1) {
      this.participants.splice(exists, 1, value);
    } else {
      this.participants.push(value);
    }
    return this.getParticipant(value.id);
  }
  /**
   * Find the participant's position in the participants list.
   * @param id
   */
  getParticipantIndex(id2) {
    return this.participants.findIndex((p2) => p2.id === id2);
  }
  /**
   * Find the participant by id.
   * @param id
   */
  getParticipant(id2) {
    return this.participants.find((p2) => p2.id === id2);
  }
  /**
   * Remove a participant from the participants list.
   */
  deleteParticipant(id2) {
    this.participants = this.participants.filter((p2) => p2.id !== id2);
  }
  /**
   * Helper to return the conversation host.
   */
  get host() {
    return this.participants.find((p2) => p2.isHost === true);
  }
  /**
   * Helper to return the current user.
   */
  get me() {
    return this.getParticipant(this.meId);
  }
}
ConversationTranslatorInterfaces.InternalParticipants = InternalParticipants;
ConversationTranslatorInterfaces.ConversationTranslatorMessageTypes = {
  command: "command",
  final: "final",
  info: "info",
  instantMessage: "instant_message",
  keepAlive: "keep_alive",
  partial: "partial",
  participantCommand: "participant_command",
  translatedMessage: "translated_message"
};
ConversationTranslatorInterfaces.ConversationTranslatorCommandTypes = {
  changeNickname: "ChangeNickname",
  disconnectSession: "DisconnectSession",
  ejectParticipant: "EjectParticipant",
  instant_message: "instant_message",
  joinSession: "JoinSession",
  leaveSession: "LeaveSession",
  participantList: "ParticipantList",
  roomExpirationWarning: "RoomExpirationWarning",
  setLockState: "SetLockState",
  setMute: "SetMute",
  setMuteAll: "SetMuteAll",
  setProfanityFiltering: "SetProfanityFiltering",
  setTranslateToLanguages: "SetTranslateToLanguages",
  setUseTTS: "SetUseTTS"
};
var Exports = {};
var CommandResponsePayload$1 = {};
Object.defineProperty(CommandResponsePayload$1, "__esModule", { value: true });
CommandResponsePayload$1.CommandResponsePayload = void 0;
const parseCommandResponse = (json) => JSON.parse(json);
class CommandResponsePayload {
  constructor(json) {
    this.privCommandResponse = parseCommandResponse(json);
  }
  get type() {
    return this.privCommandResponse.type;
  }
  get command() {
    return this.privCommandResponse.command;
  }
  get id() {
    return this.privCommandResponse.id;
  }
  get nickname() {
    return this.privCommandResponse.nickname;
  }
  get participantId() {
    return this.privCommandResponse.participantId;
  }
  get roomid() {
    return this.privCommandResponse.roomid;
  }
  get value() {
    return this.privCommandResponse.value;
  }
  get token() {
    return this.privCommandResponse.token;
  }
  static fromJSON(json) {
    return new CommandResponsePayload(json);
  }
}
CommandResponsePayload$1.CommandResponsePayload = CommandResponsePayload;
var ParticipantResponsePayload = {};
Object.defineProperty(ParticipantResponsePayload, "__esModule", { value: true });
ParticipantResponsePayload.ParticipantPayloadResponse = ParticipantResponsePayload.ParticipantsListPayloadResponse = void 0;
const parseListResponse = (json) => JSON.parse(json);
const parseParticipantResponse = (json) => JSON.parse(json);
class ParticipantsListPayloadResponse {
  constructor(json) {
    this.privParticipantsPayloadResponse = parseListResponse(json);
  }
  get roomid() {
    return this.privParticipantsPayloadResponse.roomid;
  }
  get id() {
    return this.privParticipantsPayloadResponse.id;
  }
  get command() {
    return this.privParticipantsPayloadResponse.command;
  }
  get participants() {
    return this.privParticipantsPayloadResponse.participants;
  }
  get token() {
    return this.privParticipantsPayloadResponse.token;
  }
  get translateTo() {
    return this.privParticipantsPayloadResponse.translateTo;
  }
  get profanityFilter() {
    return this.privParticipantsPayloadResponse.profanityFilter;
  }
  get roomProfanityFilter() {
    return this.privParticipantsPayloadResponse.roomProfanityFilter;
  }
  get roomLocked() {
    return this.privParticipantsPayloadResponse.roomLocked;
  }
  get muteAll() {
    return this.privParticipantsPayloadResponse.muteAll;
  }
  get type() {
    return this.privParticipantsPayloadResponse.type;
  }
  static fromJSON(json) {
    return new ParticipantsListPayloadResponse(json);
  }
}
ParticipantResponsePayload.ParticipantsListPayloadResponse = ParticipantsListPayloadResponse;
class ParticipantPayloadResponse {
  constructor(json) {
    this.privParticipantPayloadResponse = parseParticipantResponse(json);
  }
  get nickname() {
    return this.privParticipantPayloadResponse.nickname;
  }
  get locale() {
    return this.privParticipantPayloadResponse.locale;
  }
  get usetts() {
    return this.privParticipantPayloadResponse.usetts;
  }
  get ismuted() {
    return this.privParticipantPayloadResponse.ismuted;
  }
  get ishost() {
    return this.privParticipantPayloadResponse.ishost;
  }
  get participantId() {
    return this.privParticipantPayloadResponse.participantId;
  }
  get avatar() {
    return this.privParticipantPayloadResponse.avatar;
  }
  static fromJSON(json) {
    return new ParticipantPayloadResponse(json);
  }
}
ParticipantResponsePayload.ParticipantPayloadResponse = ParticipantPayloadResponse;
var TranslationResponsePayload = {};
Object.defineProperty(TranslationResponsePayload, "__esModule", { value: true });
TranslationResponsePayload.TextResponsePayload = TranslationResponsePayload.SpeechResponsePayload = void 0;
const parseSpeechResponse = (json) => JSON.parse(json);
const parseTextResponse = (json) => JSON.parse(json);
class SpeechResponsePayload {
  constructor(json) {
    this.privSpeechResponse = parseSpeechResponse(json);
  }
  get recognition() {
    return this.privSpeechResponse.recognition;
  }
  get translations() {
    return this.privSpeechResponse.translations;
  }
  get id() {
    return this.privSpeechResponse.id;
  }
  get language() {
    return this.privSpeechResponse.language;
  }
  get nickname() {
    return this.privSpeechResponse.nickname;
  }
  get participantId() {
    return this.privSpeechResponse.participantId;
  }
  get roomid() {
    return this.privSpeechResponse.roomid;
  }
  get timestamp() {
    return this.privSpeechResponse.timestamp;
  }
  get type() {
    return this.privSpeechResponse.type;
  }
  get isFinal() {
    return this.privSpeechResponse.type === "final";
  }
  static fromJSON(json) {
    return new SpeechResponsePayload(json);
  }
}
TranslationResponsePayload.SpeechResponsePayload = SpeechResponsePayload;
class TextResponsePayload {
  constructor(json) {
    this.privTextResponse = parseTextResponse(json);
  }
  get originalText() {
    return this.privTextResponse.originalText;
  }
  get translations() {
    return this.privTextResponse.translations;
  }
  get id() {
    return this.privTextResponse.id;
  }
  get language() {
    return this.privTextResponse.language;
  }
  get nickname() {
    return this.privTextResponse.nickname;
  }
  get participantId() {
    return this.privTextResponse.participantId;
  }
  get roomid() {
    return this.privTextResponse.roomid;
  }
  get timestamp() {
    return this.privTextResponse.timestamp;
  }
  get type() {
    return this.privTextResponse.type;
  }
  static fromJSON(json) {
    return new TextResponsePayload(json);
  }
}
TranslationResponsePayload.TextResponsePayload = TextResponsePayload;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CommandResponsePayload_js_1 = CommandResponsePayload$1;
  Object.defineProperty(exports, "CommandResponsePayload", { enumerable: true, get: function() {
    return CommandResponsePayload_js_1.CommandResponsePayload;
  } });
  var ParticipantResponsePayload_js_1 = ParticipantResponsePayload;
  Object.defineProperty(exports, "ParticipantsListPayloadResponse", { enumerable: true, get: function() {
    return ParticipantResponsePayload_js_1.ParticipantsListPayloadResponse;
  } });
  Object.defineProperty(exports, "ParticipantPayloadResponse", { enumerable: true, get: function() {
    return ParticipantResponsePayload_js_1.ParticipantPayloadResponse;
  } });
  var TranslationResponsePayload_js_1 = TranslationResponsePayload;
  Object.defineProperty(exports, "SpeechResponsePayload", { enumerable: true, get: function() {
    return TranslationResponsePayload_js_1.SpeechResponsePayload;
  } });
  Object.defineProperty(exports, "TextResponsePayload", { enumerable: true, get: function() {
    return TranslationResponsePayload_js_1.TextResponsePayload;
  } });
})(Exports);
var hasRequiredConversationServiceAdapter;
function requireConversationServiceAdapter() {
  if (hasRequiredConversationServiceAdapter) return ConversationServiceAdapter;
  hasRequiredConversationServiceAdapter = 1;
  Object.defineProperty(ConversationServiceAdapter, "__esModule", { value: true });
  ConversationServiceAdapter.ConversationServiceAdapter = void 0;
  const Exports_js_12 = requireExports$5();
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  const ConversationConnectionMessage_js_12 = ConversationConnectionMessage$1;
  const ConversationRequestSession_js_1 = ConversationRequestSession$1;
  const ConversationTranslatorEventArgs_js_1 = requireConversationTranslatorEventArgs();
  const ConversationTranslatorInterfaces_js_1 = ConversationTranslatorInterfaces;
  const Exports_js_4 = Exports;
  let ConversationServiceAdapter$1 = class ConversationServiceAdapter extends Exports_js_3.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);
      this.privConnectionConfigPromise = void 0;
      this.privLastPartialUtteranceId = "";
      this.privConversationServiceConnector = conversationServiceConnector;
      this.privConversationAuthentication = authentication;
      this.receiveMessageOverride = () => this.receiveConversationMessageOverride();
      this.recognizeOverride = () => this.noOp();
      this.postConnectImplOverride = (connection) => this.conversationConnectImpl(connection);
      this.configConnectionOverride = () => this.configConnection();
      this.disconnectOverride = () => this.privDisconnect();
      this.privConversationRequestSession = new ConversationRequestSession_js_1.ConversationRequestSession(Exports_js_12.createNoDashGuid());
      this.privConversationConnectionFactory = connectionFactory;
      this.privConversationIsDisposed = false;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(reason) {
      this.privConversationIsDisposed = true;
      if (this.privConnectionConfigPromise !== void 0) {
        const connection = await this.privConnectionConfigPromise;
        await connection.dispose(reason);
      }
      await super.dispose(reason);
    }
    async sendMessage(message) {
      const connection = await this.fetchConnection();
      return connection.send(new ConversationConnectionMessage_js_12.ConversationConnectionMessage(Exports_js_12.MessageType.Text, message));
    }
    async sendMessageAsync(message) {
      const connection = await this.fetchConnection();
      await connection.send(new ConversationConnectionMessage_js_12.ConversationConnectionMessage(Exports_js_12.MessageType.Text, message));
    }
    privDisconnect() {
      if (this.terminateMessageLoop) {
        return;
      }
      this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.NoError, "Disconnecting");
      this.terminateMessageLoop = true;
      return Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return true;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      this.terminateMessageLoop = true;
      const cancelEvent = new Exports_js_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
      try {
        if (!!this.privConversationServiceConnector.canceled) {
          this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);
        }
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(connection) {
      this.privConnectionLoop = this.startMessageLoop();
      return connection;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop) {
        return Promise.resolve();
      }
      const communicationCustodian = new Exports_js_12.Deferred();
      try {
        const connection = await this.fetchConnection();
        const message = await connection.read();
        if (this.isDisposed() || this.terminateMessageLoop) {
          communicationCustodian.resolve();
          return Promise.resolve();
        }
        if (!message) {
          return this.receiveConversationMessageOverride();
        }
        const sessionId = this.privConversationRequestSession.sessionId;
        const conversationMessageType = message.conversationMessageType.toLowerCase();
        let sendFinal = false;
        try {
          switch (conversationMessageType) {
            case "info":
            case "participant_command":
            case "command":
              const commandPayload = Exports_js_4.CommandResponsePayload.fromJSON(message.textBody);
              switch (commandPayload.command.toLowerCase()) {
                case "participantlist":
                  const participantsPayload = Exports_js_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);
                  const participantsResult = participantsPayload.participants.map((p2) => {
                    const participant = {
                      avatar: p2.avatar,
                      displayName: p2.nickname,
                      id: p2.participantId,
                      isHost: p2.ishost,
                      isMuted: p2.ismuted,
                      isUsingTts: p2.usetts,
                      preferredLanguage: p2.locale
                    };
                    return participant;
                  });
                  if (!!this.privConversationServiceConnector.participantsListReceived) {
                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));
                  }
                  break;
                case "settranslatetolanguages":
                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));
                  }
                  break;
                case "setprofanityfiltering":
                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));
                  }
                  break;
                case "setmute":
                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));
                  }
                  break;
                case "setmuteall":
                  if (!!this.privConversationServiceConnector.muteAllCommandReceived) {
                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.MuteAllEventArgs(commandPayload.value, sessionId));
                  }
                  break;
                case "roomexpirationwarning":
                  if (!!this.privConversationServiceConnector.conversationExpiration) {
                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new Exports_js_2.ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));
                  }
                  break;
                case "setusetts":
                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));
                  }
                  break;
                case "setlockstate":
                  if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {
                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.LockRoomEventArgs(commandPayload.value, sessionId));
                  }
                  break;
                case "changenickname":
                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload.value, sessionId));
                  }
                  break;
                case "joinsession":
                  const joinParticipantPayload = Exports_js_4.ParticipantPayloadResponse.fromJSON(message.textBody);
                  const joiningParticipant = {
                    avatar: joinParticipantPayload.avatar,
                    displayName: joinParticipantPayload.nickname,
                    id: joinParticipantPayload.participantId,
                    isHost: joinParticipantPayload.ishost,
                    isMuted: joinParticipantPayload.ismuted,
                    isUsingTts: joinParticipantPayload.usetts,
                    preferredLanguage: joinParticipantPayload.locale
                  };
                  if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {
                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantEventArgs(joiningParticipant, sessionId));
                  }
                  break;
                case "leavesession":
                  const leavingParticipant = {
                    id: commandPayload.participantId
                  };
                  if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {
                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantEventArgs(leavingParticipant, sessionId));
                  }
                  break;
                case "disconnectsession":
                  const disconnectParticipant = {
                    id: commandPayload.participantId
                  };
                  break;
                case "token":
                  const token = new Exports_js_3.CognitiveTokenAuthentication(() => {
                    const authorizationToken = commandPayload.token;
                    return Promise.resolve(authorizationToken);
                  }, () => {
                    const authorizationToken = commandPayload.token;
                    return Promise.resolve(authorizationToken);
                  });
                  this.authentication = token;
                  this.privConversationServiceConnector.onToken(token);
                  break;
                default:
                  break;
              }
              break;
            case "partial":
            case "final":
              const speechPayload = Exports_js_4.SpeechResponsePayload.fromJSON(message.textBody);
              const conversationResultReason = conversationMessageType === "final" ? Exports_js_2.ResultReason.TranslatedParticipantSpeech : Exports_js_2.ResultReason.TranslatingParticipantSpeech;
              const speechResult = new Exports_js_2.ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, speechPayload.id, conversationResultReason, speechPayload.recognition, void 0, void 0, message.textBody, void 0);
              if (speechPayload.isFinal) {
                if (speechResult.text !== void 0 && speechResult.text.length > 0) {
                  sendFinal = true;
                } else if (speechPayload.id === this.privLastPartialUtteranceId) {
                  sendFinal = true;
                } else {
                }
                if (sendFinal) {
                  if (!!this.privConversationServiceConnector.translationReceived) {
                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));
                  }
                }
              } else if (speechResult.text !== void 0) {
                this.privLastPartialUtteranceId = speechPayload.id;
                if (!!this.privConversationServiceConnector.translationReceived) {
                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));
                }
              }
              break;
            case "translated_message":
              const textPayload = Exports_js_4.TextResponsePayload.fromJSON(message.textBody);
              const textResult = new Exports_js_2.ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, void 0, void 0, textPayload.originalText, void 0, void 0, void 0, message.textBody, void 0);
              if (!!this.privConversationServiceConnector.translationReceived) {
                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));
              }
              break;
            default:
              break;
          }
        } catch (e) {
        }
        return this.receiveConversationMessageOverride();
      } catch (e) {
        this.terminateMessageLoop = true;
      }
      return communicationCustodian.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed()) {
        return Promise.resolve();
      }
      this.terminateMessageLoop = false;
      const messageRetrievalPromise = this.receiveConversationMessageOverride();
      try {
        const r2 = await messageRetrievalPromise;
        return r2;
      } catch (error) {
        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.RuntimeError, error);
        return null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      if (this.isDisposed()) {
        return Promise.resolve(void 0);
      }
      if (this.privConnectionConfigPromise !== void 0) {
        return this.privConnectionConfigPromise.then((connection) => {
          if (connection.state() === Exports_js_12.ConnectionState.Disconnected) {
            this.privConnectionId = null;
            this.privConnectionConfigPromise = void 0;
            return this.configConnection();
          }
          return this.privConnectionConfigPromise;
        }, () => {
          this.privConnectionId = null;
          this.privConnectionConfigPromise = void 0;
          return this.configConnection();
        });
      }
      if (this.terminateMessageLoop) {
        return Promise.resolve(void 0);
      }
      this.privConnectionConfigPromise = this.connectImpl().then((connection) => connection);
      return this.privConnectionConfigPromise;
    }
    getTranslations(serviceResultTranslations) {
      let translations;
      if (void 0 !== serviceResultTranslations) {
        translations = new Exports_js_2.Translations();
        for (const translation of serviceResultTranslations) {
          translations.set(translation.lang, translation.translation);
        }
      }
      return translations;
    }
  };
  ConversationServiceAdapter.ConversationServiceAdapter = ConversationServiceAdapter$1;
  return ConversationServiceAdapter;
}
var hasRequiredConversationTranslatorRecognizer;
function requireConversationTranslatorRecognizer() {
  if (hasRequiredConversationTranslatorRecognizer) return ConversationTranslatorRecognizer;
  hasRequiredConversationTranslatorRecognizer = 1;
  Object.defineProperty(ConversationTranslatorRecognizer, "__esModule", { value: true });
  ConversationTranslatorRecognizer.ConversationTranslatorRecognizer = ConversationTranslatorRecognizer.ConversationRecognizerFactory = void 0;
  const Exports_js_12 = requireExports();
  const Exports_js_2 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_3 = requireExports$3();
  const ConversationConnectionFactory_js_1 = requireConversationConnectionFactory();
  const ConversationServiceAdapter_js_1 = requireConversationServiceAdapter();
  class ConversationRecognizerFactory {
    static fromConfig(conversation, speechConfig, audioConfig) {
      return new ConversationTranslatorRecognizer$1(conversation, speechConfig, audioConfig);
    }
  }
  ConversationTranslatorRecognizer.ConversationRecognizerFactory = ConversationRecognizerFactory;
  let ConversationTranslatorRecognizer$1 = class ConversationTranslatorRecognizer extends Exports_js_3.Recognizer {
    constructor(conversation, speechConfig, audioConfig) {
      const serviceConfigImpl = speechConfig;
      Contracts_js_12.Contracts.throwIfNull(serviceConfigImpl, "speechConfig");
      const conversationImpl = conversation;
      Contracts_js_12.Contracts.throwIfNull(conversationImpl, "conversationImpl");
      super(audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory_js_1.ConversationConnectionFactory());
      this.privConversation = conversationImpl;
      this.privIsDisposed = false;
      this.privProperties = serviceConfigImpl.properties.clone();
      this.privConnection = Exports_js_3.Connection.fromRecognizer(this);
      const webWorkerLoadType = this.privProperties.getProperty(Exports_js_3.PropertyId.WebWorkerLoadType, "on").toLowerCase();
      if (webWorkerLoadType === "on" && typeof Blob !== "undefined" && typeof Worker !== "undefined") {
        this.privSetTimeout = Exports_js_2.Timeout.setTimeout;
        this.privClearTimeout = Exports_js_2.Timeout.clearTimeout;
      } else {
        if (typeof window !== "undefined") {
          this.privSetTimeout = window.setTimeout.bind(window);
          this.privClearTimeout = window.clearTimeout.bind(window);
        } else {
          this.privSetTimeout = setTimeout;
          this.privClearTimeout = clearTimeout;
        }
      }
    }
    set connected(cb2) {
      this.privConnection.connected = cb2;
    }
    set disconnected(cb2) {
      this.privConnection.disconnected = cb2;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(token, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
        this.privReco.conversationTranslatorToken = token;
        this.resetConversationTimeout();
        this.privReco.connectAsync(cb2, err2);
      } catch (error) {
        if (!!err2) {
          if (error instanceof Error) {
            const typedError = error;
            err2(typedError.name + ": " + typedError.message);
          } else {
            err2(error);
          }
        }
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        if (this.privTimeoutToken !== void 0) {
          this.privClearTimeout(this.privTimeoutToken);
        }
        this.privReco.disconnect().then(() => {
          if (!!cb2) {
            cb2();
          }
        }, (error) => {
          if (!!err2) {
            err2(error);
          }
        });
      } catch (error) {
        if (!!err2) {
          if (error instanceof Error) {
            const typedError = error;
            err2(typedError.name + ": " + typedError.message);
          } else {
            err2(error);
          }
        }
        this.dispose(true).catch((reason) => {
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(command, cb2, err2) {
      try {
        Contracts_js_12.Contracts.throwIfDisposed(this.privIsDisposed);
        this.sendMessage(command, cb2, err2);
      } catch (error) {
        if (!!err2) {
          if (error instanceof Error) {
            const typedError = error;
            err2(typedError.name + ": " + typedError.message);
          } else {
            err2(error);
          }
        }
        this.dispose(true).catch((reason) => {
          Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(token) {
      this.privConversation.onToken(token);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      if (!this.privIsDisposed) {
        if (!!this.privConnection) {
          this.privConnection.closeConnection();
          this.privConnection.close();
        }
        this.privConnection = void 0;
        await this.dispose(true);
      }
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(disposing) {
      if (this.privIsDisposed) {
        return;
      }
      if (disposing) {
        if (this.privTimeoutToken !== void 0) {
          this.privClearTimeout(this.privTimeoutToken);
        }
        this.privIsDisposed = true;
        if (!!this.privConnection) {
          this.privConnection.closeConnection();
          this.privConnection.close();
          this.privConnection = void 0;
        }
        await super.dispose(disposing);
      }
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(speechConfig) {
      return new Exports_js_12.RecognizerConfig(speechConfig, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const audioSource = audioConfig;
      return new ConversationServiceAdapter_js_1.ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
    }
    sendMessage(msg, cb2, err2) {
      const withAsync = this.privReco;
      const PromiseToEmptyCallback = (promise, cb3, err3) => {
        if (promise !== void 0) {
          promise.then(() => {
            try {
              if (!!cb3) {
                cb3();
              }
            } catch (e) {
              if (!!err3) {
                err3(`'Unhandled error on promise callback: ${e}'`);
              }
            }
          }, (reason) => {
            try {
              if (!!err3) {
                err3(reason);
              }
            } catch (error) {
            }
          });
        } else {
          if (!!err3) {
            err3("Null promise");
          }
        }
      };
      PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb2, err2);
      this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      if (this.privTimeoutToken !== void 0) {
        this.privClearTimeout(this.privTimeoutToken);
      }
      this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  ConversationTranslatorRecognizer.ConversationTranslatorRecognizer = ConversationTranslatorRecognizer$1;
  return ConversationTranslatorRecognizer;
}
var TranscriberRecognizer = {};
var hasRequiredTranscriberRecognizer;
function requireTranscriberRecognizer() {
  if (hasRequiredTranscriberRecognizer) return TranscriberRecognizer;
  hasRequiredTranscriberRecognizer = 1;
  Object.defineProperty(TranscriberRecognizer, "__esModule", { value: true });
  TranscriberRecognizer.TranscriberRecognizer = void 0;
  const Exports_js_12 = requireExports$5();
  const Contracts_js_12 = Contracts$1;
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  let TranscriberRecognizer$1 = class TranscriberRecognizer extends Exports_js_2.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(speechTranslationConfig, audioConfig) {
      const speechTranslationConfigImpl = speechTranslationConfig;
      Contracts_js_12.Contracts.throwIfNull(speechTranslationConfigImpl, "speechTranslationConfig");
      const audioConfigImpl = audioConfig;
      Contracts_js_12.Contracts.throwIfNull(audioConfigImpl, "audioConfigImpl");
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(speechTranslationConfigImpl.speechRecognitionLanguage, Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage]);
      super(audioConfig, speechTranslationConfigImpl.properties, new Exports_js_3.TranscriberConnectionFactory());
      this.privDisposedRecognizer = false;
      this.isMeetingRecognizer = false;
    }
    get speechRecognitionLanguage() {
      Contracts_js_12.Contracts.throwIfDisposed(this.privDisposedRecognizer);
      return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(token) {
      Contracts_js_12.Contracts.throwIfNullOrWhitespace(token, "token");
      this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);
    }
    set conversation(c) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(c, "Conversation");
      this.isMeetingRecognizer = false;
      this.privConversation = c;
    }
    getConversationInfo() {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation");
      return this.privConversation.conversationInfo;
    }
    set meeting(m2) {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(m2, "Meeting");
      this.isMeetingRecognizer = true;
      this.privMeeting = m2;
    }
    getMeetingInfo() {
      Contracts_js_12.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting");
      return this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(cb2, err2) {
      Exports_js_12.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_3.RecognitionMode.Conversation), cb2, err2);
    }
    stopContinuousRecognitionAsync(cb2, err2) {
      Exports_js_12.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb2, err2);
    }
    async close() {
      if (!this.privDisposedRecognizer) {
        await this.dispose(true);
      }
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(conversationInfo, command) {
      const reco = this.privReco;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(reco, "serviceRecognizer");
      await reco.sendSpeechEventAsync(conversationInfo, command);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(meetingInfo, command) {
      const reco = this.privReco;
      Contracts_js_12.Contracts.throwIfNullOrUndefined(reco, "serviceRecognizer");
      await reco.sendMeetingSpeechEventAsync(meetingInfo, command);
    }
    async enforceAudioGating() {
      const audioConfigImpl = this.audioConfig;
      const format = await audioConfigImpl.format;
      const channels = format.channels;
      if (channels === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true") {
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
        }
      } else if (channels !== 8) {
        throw new Error(`Unsupported audio configuration: Detected ${channels}-channel audio`);
      }
      return;
    }
    connectMeetingCallbacks(transcriber) {
      this.isMeetingRecognizer = true;
      this.canceled = (s, e) => {
        if (!!transcriber.canceled) {
          transcriber.canceled(transcriber, e);
        }
      };
      this.recognizing = (s, e) => {
        if (!!transcriber.transcribing) {
          transcriber.transcribing(transcriber, e);
        }
      };
      this.recognized = (s, e) => {
        if (!!transcriber.transcribed) {
          transcriber.transcribed(transcriber, e);
        }
      };
      this.sessionStarted = (s, e) => {
        if (!!transcriber.sessionStarted) {
          transcriber.sessionStarted(transcriber, e);
        }
      };
      this.sessionStopped = (s, e) => {
        if (!!transcriber.sessionStopped) {
          transcriber.sessionStopped(transcriber, e);
        }
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0;
      this.recognizing = void 0;
      this.recognized = void 0;
      this.sessionStarted = void 0;
      this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(disposing) {
      if (this.privDisposedRecognizer) {
        return;
      }
      if (disposing) {
        this.privDisposedRecognizer = true;
        await this.implRecognizerStop();
      }
      await super.dispose(disposing);
    }
    createRecognizerConfig(speechConfig) {
      return new Exports_js_3.RecognizerConfig(speechConfig, this.properties);
    }
    createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
      const configImpl = audioConfig;
      return new Exports_js_3.TranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
    }
  };
  TranscriberRecognizer.TranscriberRecognizer = TranscriberRecognizer$1;
  return TranscriberRecognizer;
}
var hasRequiredExports$1;
function requireExports$1() {
  if (hasRequiredExports$1) return Exports$1;
  hasRequiredExports$1 = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConversationManager_js_1 = requireConversationManager();
    Object.defineProperty(exports, "ConversationManager", { enumerable: true, get: function() {
      return ConversationManager_js_1.ConversationManager;
    } });
    var ConversationConnectionConfig_js_1 = ConversationConnectionConfig$1;
    Object.defineProperty(exports, "ConversationConnectionConfig", { enumerable: true, get: function() {
      return ConversationConnectionConfig_js_1.ConversationConnectionConfig;
    } });
    var ConversationTranslatorRecognizer_js_1 = requireConversationTranslatorRecognizer();
    Object.defineProperty(exports, "ConversationRecognizerFactory", { enumerable: true, get: function() {
      return ConversationTranslatorRecognizer_js_1.ConversationRecognizerFactory;
    } });
    var TranscriberRecognizer_js_1 = requireTranscriberRecognizer();
    Object.defineProperty(exports, "TranscriberRecognizer", { enumerable: true, get: function() {
      return TranscriberRecognizer_js_1.TranscriberRecognizer;
    } });
    var ConversationTranslatorEventArgs_js_1 = requireConversationTranslatorEventArgs();
    Object.defineProperty(exports, "ConversationReceivedTranslationEventArgs", { enumerable: true, get: function() {
      return ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs;
    } });
    Object.defineProperty(exports, "LockRoomEventArgs", { enumerable: true, get: function() {
      return ConversationTranslatorEventArgs_js_1.LockRoomEventArgs;
    } });
    Object.defineProperty(exports, "MuteAllEventArgs", { enumerable: true, get: function() {
      return ConversationTranslatorEventArgs_js_1.MuteAllEventArgs;
    } });
    Object.defineProperty(exports, "ParticipantAttributeEventArgs", { enumerable: true, get: function() {
      return ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs;
    } });
    Object.defineProperty(exports, "ParticipantEventArgs", { enumerable: true, get: function() {
      return ConversationTranslatorEventArgs_js_1.ParticipantEventArgs;
    } });
    Object.defineProperty(exports, "ParticipantsListEventArgs", { enumerable: true, get: function() {
      return ConversationTranslatorEventArgs_js_1.ParticipantsListEventArgs;
    } });
    var ConversationTranslatorInterfaces_js_1 = ConversationTranslatorInterfaces;
    Object.defineProperty(exports, "ConversationTranslatorCommandTypes", { enumerable: true, get: function() {
      return ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes;
    } });
    Object.defineProperty(exports, "ConversationTranslatorMessageTypes", { enumerable: true, get: function() {
      return ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes;
    } });
    Object.defineProperty(exports, "InternalParticipants", { enumerable: true, get: function() {
      return ConversationTranslatorInterfaces_js_1.InternalParticipants;
    } });
  })(Exports$1);
  return Exports$1;
}
var SynthesisAudioMetadata = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SynthesisAudioMetadata = exports.MetadataType = void 0;
  (function(MetadataType) {
    MetadataType["WordBoundary"] = "WordBoundary";
    MetadataType["Bookmark"] = "Bookmark";
    MetadataType["Viseme"] = "Viseme";
    MetadataType["SentenceBoundary"] = "SentenceBoundary";
    MetadataType["SessionEnd"] = "SessionEnd";
    MetadataType["AvatarSignal"] = "TalkingAvatarSignal";
  })(exports.MetadataType || (exports.MetadataType = {}));
  class SynthesisAudioMetadata2 {
    constructor(json) {
      this.privSynthesisAudioMetadata = JSON.parse(json);
    }
    static fromJSON(json) {
      return new SynthesisAudioMetadata2(json);
    }
    get Metadata() {
      return this.privSynthesisAudioMetadata.Metadata;
    }
  }
  exports.SynthesisAudioMetadata = SynthesisAudioMetadata2;
})(SynthesisAudioMetadata);
var SynthesisTurn = {};
var SynthesisEvents = {};
Object.defineProperty(SynthesisEvents, "__esModule", { value: true });
SynthesisEvents.SynthesisStartedEvent = SynthesisEvents.ConnectingToSynthesisServiceEvent = SynthesisEvents.SynthesisTriggeredEvent = SynthesisEvents.SpeechSynthesisEvent = void 0;
const Exports_js_1 = requireExports$5();
class SpeechSynthesisEvent extends Exports_js_1.PlatformEvent {
  constructor(eventName, requestId, eventType = Exports_js_1.EventType.Info) {
    super(eventName, eventType);
    this.privRequestId = requestId;
  }
  get requestId() {
    return this.privRequestId;
  }
}
SynthesisEvents.SpeechSynthesisEvent = SpeechSynthesisEvent;
class SynthesisTriggeredEvent extends SpeechSynthesisEvent {
  constructor(requestId, sessionAudioDestinationId, turnAudioDestinationId) {
    super("SynthesisTriggeredEvent", requestId);
    this.privSessionAudioDestinationId = sessionAudioDestinationId;
    this.privTurnAudioDestinationId = turnAudioDestinationId;
  }
  get audioSessionDestinationId() {
    return this.privSessionAudioDestinationId;
  }
  get audioTurnDestinationId() {
    return this.privTurnAudioDestinationId;
  }
}
SynthesisEvents.SynthesisTriggeredEvent = SynthesisTriggeredEvent;
class ConnectingToSynthesisServiceEvent extends SpeechSynthesisEvent {
  constructor(requestId, authFetchEventId) {
    super("ConnectingToSynthesisServiceEvent", requestId);
    this.privAuthFetchEventId = authFetchEventId;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
SynthesisEvents.ConnectingToSynthesisServiceEvent = ConnectingToSynthesisServiceEvent;
class SynthesisStartedEvent extends SpeechSynthesisEvent {
  constructor(requestId, authFetchEventId) {
    super("SynthesisStartedEvent", requestId);
    this.privAuthFetchEventId = authFetchEventId;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
SynthesisEvents.SynthesisStartedEvent = SynthesisStartedEvent;
var hasRequiredSynthesisTurn;
function requireSynthesisTurn() {
  if (hasRequiredSynthesisTurn) return SynthesisTurn;
  hasRequiredSynthesisTurn = 1;
  Object.defineProperty(SynthesisTurn, "__esModule", { value: true });
  SynthesisTurn.SynthesisTurn = void 0;
  const Exports_js_12 = requireExports$5();
  const AudioOutputStream_js_12 = AudioOutputStream$1;
  const Exports_js_2 = requireExports$3();
  const SynthesisAudioMetadata_js_1 = SynthesisAudioMetadata;
  const SynthesisEvents_js_1 = SynthesisEvents;
  let SynthesisTurn$1 = class SynthesisTurn2 {
    constructor() {
      this.privIsDisposed = false;
      this.privIsSynthesizing = false;
      this.privIsSynthesisEnded = false;
      this.privBytesReceived = 0;
      this.privInTurn = false;
      this.privTextOffset = 0;
      this.privNextSearchTextIndex = 0;
      this.privSentenceOffset = 0;
      this.privNextSearchSentenceIndex = 0;
      this.privRequestId = Exports_js_12.createNoDashGuid();
      this.privTurnDeferral = new Exports_js_12.Deferred();
      this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(value) {
      this.privStreamId = value;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(format) {
      this.privAudioOutputFormat = format;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (!!this.privWebRTCSDP) {
        const properties = new Exports_js_2.PropertyCollection();
        properties.setProperty(Exports_js_2.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP);
        return properties;
      }
      return void 0;
    }
    async getAllReceivedAudio() {
      if (!!this.privReceivedAudio) {
        return Promise.resolve(this.privReceivedAudio);
      }
      if (!this.privIsSynthesisEnded) {
        return null;
      }
      await this.readAllAudioFromStream();
      return Promise.resolve(this.privReceivedAudio);
    }
    async getAllReceivedAudioWithHeader() {
      if (!!this.privReceivedAudioWithHeader) {
        return this.privReceivedAudioWithHeader;
      }
      if (!this.privIsSynthesisEnded) {
        return null;
      }
      if (this.audioOutputFormat.hasHeader) {
        const audio = await this.getAllReceivedAudio();
        this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(audio);
        return this.privReceivedAudioWithHeader;
      } else {
        return this.getAllReceivedAudio();
      }
    }
    startNewSynthesis(requestId, rawText, isSSML, audioDestination) {
      this.privIsSynthesisEnded = false;
      this.privIsSynthesizing = true;
      this.privRequestId = requestId;
      this.privRawText = rawText;
      this.privIsSSML = isSSML;
      this.privAudioOutputStream = new AudioOutputStream_js_12.PullAudioOutputStreamImpl();
      this.privAudioOutputStream.format = this.privAudioOutputFormat;
      this.privReceivedAudio = null;
      this.privReceivedAudioWithHeader = null;
      this.privBytesReceived = 0;
      this.privTextOffset = 0;
      this.privNextSearchTextIndex = 0;
      this.privSentenceOffset = 0;
      this.privNextSearchSentenceIndex = 0;
      this.privPartialVisemeAnimation = "";
      this.privWebRTCSDP = "";
      if (audioDestination !== void 0) {
        this.privTurnAudioDestination = audioDestination;
        this.privTurnAudioDestination.format = this.privAudioOutputFormat;
      }
      this.onEvent(new SynthesisEvents_js_1.SynthesisTriggeredEvent(this.requestId, void 0, audioDestination === void 0 ? void 0 : audioDestination.id()));
    }
    onPreConnectionStart(authFetchEventId) {
      this.privAuthFetchEventId = authFetchEventId;
      this.onEvent(new SynthesisEvents_js_1.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(isError) {
      if (isError) {
        this.onComplete();
      }
    }
    onConnectionEstablishCompleted(statusCode) {
      if (statusCode === 200) {
        this.onEvent(new SynthesisEvents_js_1.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));
        this.privBytesReceived = 0;
        return;
      } else if (statusCode === 403) {
        this.onComplete();
      }
    }
    onServiceResponseMessage(responseJson) {
      const response = JSON.parse(responseJson);
      this.streamId = response.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = false;
      this.privTurnDeferral.resolve();
      this.onComplete();
    }
    onServiceTurnStartResponse(responseJson) {
      if (!!this.privTurnDeferral && !!this.privInTurn) {
        this.privTurnDeferral.reject("Another turn started before current completed.");
        this.privTurnDeferral.promise.then().catch(() => {
        });
      }
      this.privInTurn = true;
      this.privTurnDeferral = new Exports_js_12.Deferred();
      const response = JSON.parse(responseJson);
      if (!!response.webrtc) {
        this.privWebRTCSDP = response.webrtc.connectionString;
      }
    }
    onAudioChunkReceived(data) {
      if (this.isSynthesizing) {
        this.privAudioOutputStream.write(data);
        this.privBytesReceived += data.byteLength;
        if (this.privTurnAudioDestination !== void 0) {
          this.privTurnAudioDestination.write(data);
        }
      }
    }
    onTextBoundaryEvent(metadata) {
      this.updateTextOffset(metadata.Data.text.Text, metadata.Type);
    }
    onVisemeMetadataReceived(metadata) {
      if (metadata.Data.AnimationChunk !== void 0) {
        this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;
      }
    }
    onSessionEnd(metadata) {
      this.privAudioDuration = metadata.Data.Offset;
    }
    async constructSynthesisResult() {
      const audioBuffer = await this.getAllReceivedAudioWithHeader();
      return new Exports_js_2.SpeechSynthesisResult(this.requestId, Exports_js_2.ResultReason.SynthesizingAudioCompleted, audioBuffer, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = true;
      }
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const animation = this.privPartialVisemeAnimation;
      this.privPartialVisemeAnimation = "";
      return animation;
    }
    onEvent(event) {
      Exports_js_12.Events.instance.onEvent(event);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(text2) {
      return text2.length >= 2 && text2[0] === "<" && text2[text2.length - 1] === ">";
    }
    updateTextOffset(text2, type) {
      if (type === SynthesisAudioMetadata_js_1.MetadataType.WordBoundary) {
        this.privTextOffset = this.privRawText.indexOf(text2, this.privNextSearchTextIndex);
        if (this.privTextOffset >= 0) {
          this.privNextSearchTextIndex = this.privTextOffset + text2.length;
          if (this.privIsSSML) {
            if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn2.isXmlTag(text2)) {
              this.updateTextOffset(text2, type);
            }
          }
        }
      } else {
        this.privSentenceOffset = this.privRawText.indexOf(text2, this.privNextSearchSentenceIndex);
        if (this.privSentenceOffset >= 0) {
          this.privNextSearchSentenceIndex = this.privSentenceOffset + text2.length;
          if (this.privIsSSML) {
            if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn2.isXmlTag(text2)) {
              this.updateTextOffset(text2, type);
            }
          }
        }
      }
    }
    onComplete() {
      if (this.privIsSynthesizing) {
        this.privIsSynthesizing = false;
        this.privIsSynthesisEnded = true;
        this.privAudioOutputStream.close();
        this.privInTurn = false;
        if (this.privTurnAudioDestination !== void 0) {
          this.privTurnAudioDestination.close();
          this.privTurnAudioDestination = void 0;
        }
      }
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch (e) {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(idx) {
      return this.privRawText.indexOf("<", idx + 1) > this.privRawText.indexOf(">", idx + 1);
    }
  };
  SynthesisTurn.SynthesisTurn = SynthesisTurn$1;
  return SynthesisTurn;
}
var SynthesisAdapterBase = {};
var hasRequiredSynthesisAdapterBase;
function requireSynthesisAdapterBase() {
  if (hasRequiredSynthesisAdapterBase) return SynthesisAdapterBase;
  hasRequiredSynthesisAdapterBase = 1;
  Object.defineProperty(SynthesisAdapterBase, "__esModule", { value: true });
  SynthesisAdapterBase.SynthesisAdapterBase = void 0;
  const Exports_js_12 = requireExports$5();
  const Exports_js_2 = requireExports$3();
  const Exports_js_3 = requireExports();
  const SpeechConnectionMessage_Internal_js_1 = SpeechConnectionMessage_Internal;
  let SynthesisAdapterBase$1 = class SynthesisAdapterBase {
    constructor(authentication, connectionFactory, synthesizerConfig, audioDestination) {
      this.speakOverride = void 0;
      this.receiveMessageOverride = void 0;
      this.connectImplOverride = void 0;
      this.configConnectionOverride = void 0;
      this.privConnectionConfigurationPromise = void 0;
      if (!authentication) {
        throw new Exports_js_12.ArgumentNullError("authentication");
      }
      if (!connectionFactory) {
        throw new Exports_js_12.ArgumentNullError("connectionFactory");
      }
      if (!synthesizerConfig) {
        throw new Exports_js_12.ArgumentNullError("synthesizerConfig");
      }
      this.privAuthentication = authentication;
      this.privConnectionFactory = connectionFactory;
      this.privSynthesizerConfig = synthesizerConfig;
      this.privIsDisposed = false;
      this.privSessionAudioDestination = audioDestination;
      this.privSynthesisTurn = new Exports_js_3.SynthesisTurn();
      this.privConnectionEvents = new Exports_js_12.EventSource();
      this.privServiceEvents = new Exports_js_12.EventSource();
      this.privSynthesisContext = new Exports_js_3.SynthesisContext();
      this.privAgentConfig = new Exports_js_3.AgentConfig();
      this.connectionEvents.attach((connectionEvent) => {
        if (connectionEvent.name === "ConnectionClosedEvent") {
          const connectionClosedEvent = connectionEvent;
          if (connectionClosedEvent.statusCode !== 1e3) {
            this.cancelSynthesisLocal(Exports_js_2.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_js_2.CancellationErrorCode.BadRequestParameters : Exports_js_2.CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);
          }
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(messagePayload) {
      this.privActivityTemplate = messagePayload;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(format) {
      this.privAudioOutputFormat = format;
      this.privSynthesisTurn.audioOutputFormat = format;
      if (this.privSessionAudioDestination !== void 0) {
        this.privSessionAudioDestination.format = format;
      }
      if (this.synthesisContext !== void 0) {
        this.synthesisContext.audioOutputFormat = format;
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(reason) {
      this.privIsDisposed = true;
      if (this.privSessionAudioDestination !== void 0) {
        this.privSessionAudioDestination.close();
      }
      if (this.privConnectionConfigurationPromise !== void 0) {
        const connection = await this.privConnectionConfigurationPromise;
        await connection.dispose(reason);
      }
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(path, payload) {
      const type = typeof payload === "string" ? Exports_js_12.MessageType.Text : Exports_js_12.MessageType.Binary;
      const contentType = typeof payload === "string" ? "application/json" : "";
      const connection = await this.fetchConnection();
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));
    }
    async Speak(text2, isSSML, requestId, successCallback, errorCallBack, audioDestination) {
      let ssml;
      if (isSSML) {
        ssml = text2;
      } else {
        ssml = this.privSynthesizer.buildSsml(text2);
      }
      if (this.speakOverride !== void 0) {
        return this.speakOverride(ssml, requestId, successCallback, errorCallBack);
      }
      this.privSuccessCallback = successCallback;
      this.privErrorCallback = errorCallBack;
      this.privSynthesisTurn.startNewSynthesis(requestId, text2, isSSML, audioDestination);
      try {
        await this.connectImpl();
        const connection = await this.fetchConnection();
        await this.sendSynthesisContext(connection);
        await this.sendSsmlMessage(connection, ssml, requestId);
        this.onSynthesisStarted(requestId);
        void this.receiveMessage();
      } catch (e) {
        this.cancelSynthesisLocal(Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.ConnectionFailure, e);
        return Promise.reject(e);
      }
    }
    async stopSpeaking() {
      await this.connectImpl();
      const connection = await this.fetchConnection();
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_12.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(requestId, _cancellationReason, errorCode, error) {
      const properties = new Exports_js_2.PropertyCollection();
      properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
      const result = new Exports_js_2.SpeechSynthesisResult(requestId, Exports_js_2.ResultReason.Canceled, void 0, error, properties);
      this.onSynthesisCancelled(result);
      if (!!this.privSuccessCallback) {
        try {
          this.privSuccessCallback(result);
        } catch {
        }
      }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(cancellationReason, errorCode, error) {
      if (!!this.privSynthesisTurn.isSynthesizing) {
        this.privSynthesisTurn.onStopSynthesizing();
        this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(_connectionMessage) {
      return true;
    }
    async receiveMessage() {
      try {
        const connection = await this.fetchConnection();
        const message = await connection.read();
        if (this.receiveMessageOverride !== void 0) {
          return this.receiveMessageOverride();
        }
        if (this.privIsDisposed) {
          return;
        }
        if (!message) {
          if (!this.privSynthesisTurn.isSynthesizing) {
            return;
          } else {
            return this.receiveMessage();
          }
        }
        const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);
        if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {
          switch (connectionMessage.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(connectionMessage.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);
              break;
            case "audio":
              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {
                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);
                this.onSynthesizing(connectionMessage.binaryBody);
                if (this.privSessionAudioDestination !== void 0) {
                  this.privSessionAudioDestination.write(connectionMessage.binaryBody);
                }
              }
              break;
            case "audio.metadata":
              const metadataList = Exports_js_3.SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;
              for (const metadata of metadataList) {
                switch (metadata.Type) {
                  case Exports_js_3.MetadataType.WordBoundary:
                  case Exports_js_3.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);
                    const wordBoundaryEventArgs = new Exports_js_2.SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === Exports_js_3.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);
                    this.onWordBoundary(wordBoundaryEventArgs);
                    break;
                  case Exports_js_3.MetadataType.Bookmark:
                    const bookmarkEventArgs = new Exports_js_2.SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);
                    this.onBookmarkReached(bookmarkEventArgs);
                    break;
                  case Exports_js_3.MetadataType.Viseme:
                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);
                    if (metadata.Data.IsLastAnimation) {
                      const visemeEventArgs = new Exports_js_2.SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(visemeEventArgs);
                    }
                    break;
                  case Exports_js_3.MetadataType.AvatarSignal:
                    this.onAvatarEvent(metadata);
                    break;
                  case Exports_js_3.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(metadata);
                    break;
                }
              }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let result;
              try {
                result = await this.privSynthesisTurn.constructSynthesisResult();
                if (!!this.privSuccessCallback) {
                  this.privSuccessCallback(result);
                }
              } catch (error) {
                if (!!this.privErrorCallback) {
                  this.privErrorCallback(error);
                }
              }
              this.onSynthesisCompleted(result);
              break;
            default:
              if (!this.processTypeSpecificMessages(connectionMessage)) {
                if (!!this.privServiceEvents) {
                  this.serviceEvents.onEvent(new Exports_js_12.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                }
              }
          }
        }
        return this.receiveMessage();
      } catch (e) {
      }
    }
    sendSynthesisContext(connection) {
      this.setSynthesisContextSynthesisSection();
      const synthesisContextJson = this.synthesisContext.toJSON();
      if (synthesisContextJson) {
        return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_12.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", synthesisContextJson));
      }
      return;
    }
    setSpeechConfigSynthesisSection() {
      return;
    }
    connectImpl(isUnAuthorized = false) {
      if (this.privConnectionPromise != null) {
        return this.privConnectionPromise.then((connection) => {
          if (connection.state() === Exports_js_12.ConnectionState.Disconnected) {
            this.privConnectionId = null;
            this.privConnectionPromise = null;
            return this.connectImpl();
          }
          return this.privConnectionPromise;
        }, () => {
          this.privConnectionId = null;
          this.privConnectionPromise = null;
          return this.connectImpl();
        });
      }
      this.privAuthFetchEventId = Exports_js_12.createNoDashGuid();
      this.privConnectionId = Exports_js_12.createNoDashGuid();
      this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      this.privConnectionPromise = authPromise.then(async (result) => {
        this.privSynthesisTurn.onAuthCompleted(false);
        const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);
        connection.events.attach((event) => {
          this.connectionEvents.onEvent(event);
        });
        const response = await connection.open();
        if (response.statusCode === 200) {
          this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);
          return Promise.resolve(connection);
        } else if (response.statusCode === 403 && !isUnAuthorized) {
          return this.connectImpl(true);
        } else {
          this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);
          return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url)} Reason: ${response.reason}`);
        }
      }, (error) => {
        this.privSynthesisTurn.onAuthCompleted(true);
        throw new Error(error);
      });
      this.privConnectionPromise.catch(() => {
      });
      return this.privConnectionPromise;
    }
    sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {
      if (SpeechServiceConfigJson) {
        return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_12.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", SpeechServiceConfigJson));
      }
    }
    sendSsmlMessage(connection, ssml, requestId) {
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_12.MessageType.Text, "ssml", requestId, "application/ssml+xml", ssml));
    }
    async fetchConnection() {
      if (this.privConnectionConfigurationPromise !== void 0) {
        return this.privConnectionConfigurationPromise.then((connection) => {
          if (connection.state() === Exports_js_12.ConnectionState.Disconnected) {
            this.privConnectionId = null;
            this.privConnectionConfigurationPromise = void 0;
            return this.fetchConnection();
          }
          return this.privConnectionConfigurationPromise;
        }, () => {
          this.privConnectionId = null;
          this.privConnectionConfigurationPromise = void 0;
          return this.fetchConnection();
        });
      }
      this.privConnectionConfigurationPromise = this.configureConnection();
      return await this.privConnectionConfigurationPromise;
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const connection = await this.connectImpl();
      if (this.configConnectionOverride !== void 0) {
        return this.configConnectionOverride(connection);
      }
      this.setSpeechConfigSynthesisSection();
      await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());
      return connection;
    }
    onAvatarEvent(_metadata) {
      return;
    }
    onSynthesisStarted(_requestId) {
      return;
    }
    onSynthesizing(_audio) {
      return;
    }
    onSynthesisCancelled(_result) {
      return;
    }
    onSynthesisCompleted(_result) {
      return;
    }
    onWordBoundary(_wordBoundaryEventArgs) {
      return;
    }
    onVisemeReceived(_visemeEventArgs) {
      return;
    }
    onBookmarkReached(_bookmarkEventArgs) {
      return;
    }
  };
  SynthesisAdapterBase.SynthesisAdapterBase = SynthesisAdapterBase$1;
  SynthesisAdapterBase$1.telemetryDataEnabled = true;
  return SynthesisAdapterBase;
}
var AvatarSynthesisAdapter = {};
var hasRequiredAvatarSynthesisAdapter;
function requireAvatarSynthesisAdapter() {
  if (hasRequiredAvatarSynthesisAdapter) return AvatarSynthesisAdapter;
  hasRequiredAvatarSynthesisAdapter = 1;
  Object.defineProperty(AvatarSynthesisAdapter, "__esModule", { value: true });
  AvatarSynthesisAdapter.AvatarSynthesisAdapter = void 0;
  const Exports_js_12 = requireExports$3();
  const Exports_js_2 = requireExports();
  let AvatarSynthesisAdapter$1 = class AvatarSynthesisAdapter extends Exports_js_2.SynthesisAdapterBase {
    constructor(authentication, connectionFactory, synthesizerConfig, avatarSynthesizer, avatarConfig) {
      super(authentication, connectionFactory, synthesizerConfig, void 0);
      this.privAvatarSynthesizer = avatarSynthesizer;
      this.privSynthesizer = avatarSynthesizer;
      this.privAvatarConfig = avatarConfig;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q2;
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: (_a2 = this.privAvatarConfig.videoFormat) == null ? void 0 : _a2.bitrate,
          codec: (_b2 = this.privAvatarConfig.videoFormat) == null ? void 0 : _b2.codec,
          crop: {
            bottomRight: {
              x: (_e = (_d = (_c = this.privAvatarConfig.videoFormat) == null ? void 0 : _c.cropRange) == null ? void 0 : _d.bottomRight) == null ? void 0 : _e.x,
              y: (_h = (_g = (_f = this.privAvatarConfig.videoFormat) == null ? void 0 : _f.cropRange) == null ? void 0 : _g.bottomRight) == null ? void 0 : _h.y
            },
            topLeft: {
              x: (_k = (_j = (_i = this.privAvatarConfig.videoFormat) == null ? void 0 : _i.cropRange) == null ? void 0 : _j.topLeft) == null ? void 0 : _k.x,
              y: (_n = (_m = (_l = this.privAvatarConfig.videoFormat) == null ? void 0 : _l.cropRange) == null ? void 0 : _m.topLeft) == null ? void 0 : _n.y
            }
          },
          resolution: {
            height: (_o = this.privAvatarConfig.videoFormat) == null ? void 0 : _o.height,
            width: (_p = this.privAvatarConfig.videoFormat) == null ? void 0 : _p.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(Exports_js_12.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: (_q2 = this.privAvatarConfig.backgroundImage) == null ? void 0 : _q2.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style
        }
      };
    }
    onAvatarEvent(metadata) {
      if (!!this.privAvatarSynthesizer.avatarEventReceived) {
        const avatarEventArgs = new Exports_js_12.AvatarEventArgs(metadata.Data.Offset, metadata.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, avatarEventArgs);
        } catch (error) {
        }
      }
    }
  };
  AvatarSynthesisAdapter.AvatarSynthesisAdapter = AvatarSynthesisAdapter$1;
  return AvatarSynthesisAdapter;
}
var SpeechSynthesisAdapter = {};
var hasRequiredSpeechSynthesisAdapter;
function requireSpeechSynthesisAdapter() {
  if (hasRequiredSpeechSynthesisAdapter) return SpeechSynthesisAdapter;
  hasRequiredSpeechSynthesisAdapter = 1;
  Object.defineProperty(SpeechSynthesisAdapter, "__esModule", { value: true });
  SpeechSynthesisAdapter.SpeechSynthesisAdapter = void 0;
  const Exports_js_12 = requireExports$3();
  const Exports_js_2 = requireExports();
  let SpeechSynthesisAdapter$1 = class SpeechSynthesisAdapter extends Exports_js_2.SynthesisAdapterBase {
    constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {
      super(authentication, connectionFactory, synthesizerConfig, audioDestination);
      this.privSpeechSynthesizer = speechSynthesizer;
      this.privSynthesizer = speechSynthesizer;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(requestId) {
      const synthesisStartEventArgs = new Exports_js_12.SpeechSynthesisEventArgs(new Exports_js_12.SpeechSynthesisResult(requestId, Exports_js_12.ResultReason.SynthesizingAudioStarted));
      if (!!this.privSpeechSynthesizer.synthesisStarted) {
        this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);
      }
    }
    onSynthesizing(audio) {
      if (!!this.privSpeechSynthesizer.synthesizing) {
        try {
          const audioWithHeader = this.privSynthesisTurn.audioOutputFormat.addHeader(audio);
          const ev = new Exports_js_12.SpeechSynthesisEventArgs(new Exports_js_12.SpeechSynthesisResult(this.privSynthesisTurn.requestId, Exports_js_12.ResultReason.SynthesizingAudio, audioWithHeader));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);
        } catch (error) {
        }
      }
    }
    onSynthesisCancelled(result) {
      if (!!this.privSpeechSynthesizer.SynthesisCanceled) {
        const cancelEvent = new Exports_js_12.SpeechSynthesisEventArgs(result);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);
        } catch {
        }
      }
    }
    onSynthesisCompleted(result) {
      if (this.privSpeechSynthesizer.synthesisCompleted) {
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new Exports_js_12.SpeechSynthesisEventArgs(result));
        } catch (e) {
        }
      }
    }
    onWordBoundary(wordBoundaryEventArgs) {
      if (!!this.privSpeechSynthesizer.wordBoundary) {
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);
        } catch (error) {
        }
      }
    }
    onVisemeReceived(visemeEventArgs) {
      if (!!this.privSpeechSynthesizer.visemeReceived) {
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);
        } catch (error) {
        }
      }
    }
    onBookmarkReached(bookmarkEventArgs) {
      if (!!this.privSpeechSynthesizer.bookmarkReached) {
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);
        } catch (error) {
        }
      }
    }
  };
  SpeechSynthesisAdapter.SpeechSynthesisAdapter = SpeechSynthesisAdapter$1;
  return SpeechSynthesisAdapter;
}
var SynthesisRestAdapter = {};
var hasRequiredSynthesisRestAdapter;
function requireSynthesisRestAdapter() {
  if (hasRequiredSynthesisRestAdapter) return SynthesisRestAdapter;
  hasRequiredSynthesisRestAdapter = 1;
  Object.defineProperty(SynthesisRestAdapter, "__esModule", { value: true });
  SynthesisRestAdapter.SynthesisRestAdapter = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$3();
  const ConnectionFactoryBase_js_1 = requireConnectionFactoryBase();
  const HeaderNames_js_12 = HeaderNames$1;
  let SynthesisRestAdapter$1 = class SynthesisRestAdapter {
    constructor(config, authentication) {
      let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!endpoint) {
        const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, "westus");
        const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
        endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, `https://${region}.tts.speech${hostSuffix}`);
      }
      this.privUri = `${endpoint}/cognitiveservices/voices/list`;
      const options = Exports_js_12.RestConfigBase.requestOptions;
      this.privRestAdapter = new Exports_js_12.RestMessageAdapter(options);
      this.privAuthentication = authentication;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(connectionId) {
      this.privRestAdapter.setHeaders(HeaderNames_js_12.HeaderNames.ConnectionId, connectionId);
      return this.privAuthentication.fetch(connectionId).then((authInfo) => {
        this.privRestAdapter.setHeaders(authInfo.headerName, authInfo.token);
        return this.privRestAdapter.request(Exports_js_12.RestRequestType.Get, this.privUri);
      });
    }
  };
  SynthesisRestAdapter.SynthesisRestAdapter = SynthesisRestAdapter$1;
  return SynthesisRestAdapter;
}
var SynthesizerConfig = {};
var hasRequiredSynthesizerConfig;
function requireSynthesizerConfig() {
  if (hasRequiredSynthesizerConfig) return SynthesizerConfig;
  hasRequiredSynthesizerConfig = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SynthesizerConfig = exports.SynthesisServiceType = void 0;
    const Exports_js_12 = requireExports();
    var SynthesisServiceType;
    (function(SynthesisServiceType2) {
      SynthesisServiceType2[SynthesisServiceType2["Standard"] = 0] = "Standard";
      SynthesisServiceType2[SynthesisServiceType2["Custom"] = 1] = "Custom";
    })(SynthesisServiceType = exports.SynthesisServiceType || (exports.SynthesisServiceType = {}));
    class SynthesizerConfig2 {
      constructor(speechServiceConfig, parameters) {
        this.privSynthesisServiceType = SynthesisServiceType.Standard;
        this.avatarEnabled = false;
        this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new Exports_js_12.SpeechServiceConfig(new Exports_js_12.Context(null));
        this.privParameters = parameters;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(value) {
        this.privSynthesisServiceType = value;
      }
      set synthesisVideoSection(value) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: value
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    exports.SynthesizerConfig = SynthesizerConfig2;
  })(SynthesizerConfig);
  return SynthesizerConfig;
}
var SynthesisContext = {};
var hasRequiredSynthesisContext;
function requireSynthesisContext() {
  if (hasRequiredSynthesisContext) return SynthesisContext;
  hasRequiredSynthesisContext = 1;
  Object.defineProperty(SynthesisContext, "__esModule", { value: true });
  SynthesisContext.SynthesisContext = void 0;
  const Exports_js_12 = requireExports$3();
  let SynthesisContext$1 = class SynthesisContext {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(sectionName, value) {
      this.privContext[sectionName] = value;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(format) {
      this.privAudioOutputFormat = format;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(speechSynthesizer) {
      const synthesisSection = this.buildSynthesisContext(speechSynthesizer);
      this.setSection("synthesis", synthesisSection);
    }
    buildSynthesisContext(speechSynthesizer) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!(speechSynthesizer == null ? void 0 : speechSynthesizer.bookmarkReached),
            punctuationBoundaryEnabled: speechSynthesizer == null ? void 0 : speechSynthesizer.properties.getProperty(Exports_js_12.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!(speechSynthesizer == null ? void 0 : speechSynthesizer.wordBoundary)),
            sentenceBoundaryEnabled: speechSynthesizer == null ? void 0 : speechSynthesizer.properties.getProperty(Exports_js_12.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, false),
            sessionEndEnabled: true,
            visemeEnabled: !!(speechSynthesizer == null ? void 0 : speechSynthesizer.visemeReceived),
            wordBoundaryEnabled: speechSynthesizer == null ? void 0 : speechSynthesizer.properties.getProperty(Exports_js_12.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!(speechSynthesizer == null ? void 0 : speechSynthesizer.wordBoundary))
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: speechSynthesizer == null ? void 0 : speechSynthesizer.autoDetectSourceLanguage
        }
      };
    }
  };
  SynthesisContext.SynthesisContext = SynthesisContext$1;
  return SynthesisContext;
}
var SpeakerRecognitionConfig = {};
var hasRequiredSpeakerRecognitionConfig;
function requireSpeakerRecognitionConfig() {
  if (hasRequiredSpeakerRecognitionConfig) return SpeakerRecognitionConfig;
  hasRequiredSpeakerRecognitionConfig = 1;
  Object.defineProperty(SpeakerRecognitionConfig, "__esModule", { value: true });
  SpeakerRecognitionConfig.SpeakerRecognitionConfig = void 0;
  const Exports_js_12 = requireExports();
  let SpeakerRecognitionConfig$1 = class SpeakerRecognitionConfig {
    constructor(context, parameters) {
      this.privContext = context ? context : new Exports_js_12.Context(null);
      this.privParameters = parameters;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  SpeakerRecognitionConfig.SpeakerRecognitionConfig = SpeakerRecognitionConfig$1;
  return SpeakerRecognitionConfig;
}
var SpeakerServiceRecognizer = {};
var hasRequiredSpeakerServiceRecognizer;
function requireSpeakerServiceRecognizer() {
  if (hasRequiredSpeakerServiceRecognizer) return SpeakerServiceRecognizer;
  hasRequiredSpeakerServiceRecognizer = 1;
  Object.defineProperty(SpeakerServiceRecognizer, "__esModule", { value: true });
  SpeakerServiceRecognizer.SpeakerServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$5();
  const Exports_js_3 = requireExports$3();
  const Exports_js_4 = requireExports();
  const SpeechConnectionMessage_Internal_js_1 = SpeechConnectionMessage_Internal;
  let SpeakerServiceRecognizer$1 = class SpeakerServiceRecognizer extends Exports_js_4.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
      this.privSpeakerRecognizer = recognizer;
      this.privSpeakerAudioSource = audioSource;
      this.recognizeSpeaker = (model) => this.recognizeSpeakerOnce(model);
      this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(connectionMessage) {
      let processed = false;
      const resultProps = new Exports_js_3.PropertyCollection();
      if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {
        resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      }
      switch (connectionMessage.path.toLowerCase()) {
        case "speaker.response":
          const response = JSON.parse(connectionMessage.textBody);
          let result;
          if (response.status.statusCode.toLowerCase() !== "success") {
            result = new Exports_js_3.SpeakerRecognitionResult(response, Exports_js_3.ResultReason.Canceled, Exports_js_3.CancellationErrorCode.ServiceError, response.status.reason);
          } else {
            result = new Exports_js_3.SpeakerRecognitionResult(response, Exports_js_3.ResultReason.RecognizedSpeaker);
          }
          if (!!this.privResultDeferral) {
            this.privResultDeferral.resolve(result);
          }
          processed = true;
          break;
      }
      const defferal = new Exports_js_2.Deferred();
      defferal.resolve(processed);
      return defferal.promise;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_3.PropertyCollection();
      properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);
      if (!!this.privResultDeferral) {
        const result = new Exports_js_3.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: error, reason: error }
        }, Exports_js_3.ResultReason.Canceled, errorCode, error);
        try {
          this.privResultDeferral.resolve(result);
        } catch (error2) {
          this.privResultDeferral.reject(error2);
        }
      }
    }
    async recognizeSpeakerOnce(model) {
      this.privSpeakerModel = model;
      this.voiceProfileType = model.scenario;
      if (!this.privResultDeferral) {
        this.privResultDeferral = new Exports_js_2.Deferred();
      }
      this.privRequestSession.startNewRecognition();
      this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);
      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const conPromise = this.connectImpl();
      const preAudioPromise = this.sendPreAudioMessages(this.extractSpeakerContext(model));
      const node2 = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);
      const format = await this.privSpeakerAudioSource.format;
      const deviceInfo = await this.privSpeakerAudioSource.deviceInfo;
      const audioNode = new Exports_js_12.ReplayableAudioNode(node2, format.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };
      try {
        await conPromise;
        await preAudioPromise;
      } catch (err2) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, err2);
      }
      const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
      if (!!this.privRecognizer.sessionStarted) {
        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
      }
      void this.receiveMessage();
      const audioSendPromise = this.sendAudio(audioNode);
      audioSendPromise.then(() => {
      }, (error) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
      });
      return this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(context) {
      const connection = await this.fetchConnection();
      await this.sendSpeakerRecognition(connection, context);
    }
    async sendSpeakerRecognition(connection, context) {
      const speakerContextJson = JSON.stringify(context);
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", speakerContextJson));
    }
    extractSpeakerContext(model) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: model.profileIds,
        scenario: model.scenario
      };
    }
  };
  SpeakerServiceRecognizer.SpeakerServiceRecognizer = SpeakerServiceRecognizer$1;
  return SpeakerServiceRecognizer;
}
var VoiceServiceRecognizer = {};
var hasRequiredVoiceServiceRecognizer;
function requireVoiceServiceRecognizer() {
  if (hasRequiredVoiceServiceRecognizer) return VoiceServiceRecognizer;
  hasRequiredVoiceServiceRecognizer = 1;
  Object.defineProperty(VoiceServiceRecognizer, "__esModule", { value: true });
  VoiceServiceRecognizer.VoiceServiceRecognizer = void 0;
  const Exports_js_12 = requireExports$2();
  const Exports_js_2 = requireExports$5();
  const Exports_js_3 = requireExports$3();
  const Exports_js_4 = requireExports();
  const SpeechConnectionMessage_Internal_js_1 = SpeechConnectionMessage_Internal;
  let VoiceServiceRecognizer$1 = class VoiceServiceRecognizer extends Exports_js_4.ServiceRecognizerBase {
    constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
      super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
      this.privDeferralMap = new Exports_js_2.DeferralMap();
      this.privSpeakerAudioSource = audioSource;
      this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(audioSource) {
      this.privSpeakerAudioSource = audioSource;
    }
    processTypeSpecificMessages(connectionMessage) {
      let processed = false;
      const resultProps = new Exports_js_3.PropertyCollection();
      if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {
        resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
      }
      switch (connectionMessage.path.toLowerCase()) {
        case "speaker.profiles":
          const response = JSON.parse(connectionMessage.textBody);
          switch (response.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(response, connectionMessage.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(response, connectionMessage.requestId);
              break;
            case "fetch":
              const enrollmentResponse2 = JSON.parse(connectionMessage.textBody);
              this.handleFetchResponse(enrollmentResponse2, connectionMessage.requestId);
              break;
          }
          processed = true;
          break;
        case "speaker.phrases":
          const phraseResponse = JSON.parse(connectionMessage.textBody);
          this.handlePhrasesResponse(phraseResponse, connectionMessage.requestId);
          processed = true;
          break;
        case "speaker.profile.enrollment":
          const enrollmentResponse = JSON.parse(connectionMessage.textBody);
          const result = new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(!!enrollmentResponse.enrollment ? enrollmentResponse.enrollment.enrollmentStatus : enrollmentResponse.status.statusCode), !!enrollmentResponse.enrollment ? JSON.stringify(enrollmentResponse.enrollment) : void 0, enrollmentResponse.status.reason);
          if (!!this.privDeferralMap.getId(connectionMessage.requestId)) {
            this.privDeferralMap.complete(connectionMessage.requestId, result);
          }
          this.privRequestSession.onSpeechEnded();
          processed = true;
          break;
      }
      const defferal = new Exports_js_2.Deferred();
      defferal.resolve(processed);
      return defferal.promise;
    }
    // Cancels recognition.
    cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
      const properties = new Exports_js_3.PropertyCollection();
      properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);
      const result = new Exports_js_3.VoiceProfileEnrollmentResult(Exports_js_3.ResultReason.Canceled, error, error);
      if (!!this.privDeferralMap.getId(requestId)) {
        this.privDeferralMap.complete(requestId, result);
      }
    }
    async createProfile(profileType, locale) {
      this.voiceProfileType = profileType.toString();
      const conPromise = this.connectImpl();
      try {
        const createProfileDeferral = new Exports_js_2.Deferred();
        await conPromise;
        await this.sendCreateProfile(createProfileDeferral, profileType, locale);
        void this.receiveMessage();
        return createProfileDeferral.promise;
      } catch (err2) {
        throw err2;
      }
    }
    async resetProfile(profile) {
      this.voiceProfileType = profile.profileType.toString();
      return this.sendCommonRequest("reset", profile.profileType, profile);
    }
    async deleteProfile(profile) {
      this.voiceProfileType = profile.profileType.toString();
      return this.sendCommonRequest("delete", profile.profileType, profile);
    }
    async retrieveEnrollmentResult(profile) {
      this.voiceProfileType = profile.profileType.toString();
      this.privExpectedProfileId = profile.profileId;
      return this.sendCommonRequest("fetch", profile.profileType, profile);
    }
    async getAllProfiles(profileType) {
      this.voiceProfileType = profileType.toString();
      return this.sendCommonRequest("fetch", profileType);
    }
    async getActivationPhrases(profileType, lang) {
      this.voiceProfileType = profileType.toString();
      const conPromise = this.connectImpl();
      try {
        const getPhrasesDeferral = new Exports_js_2.Deferred();
        await conPromise;
        await this.sendPhrasesRequest(getPhrasesDeferral, profileType, lang);
        void this.receiveMessage();
        return getPhrasesDeferral.promise;
      } catch (err2) {
        throw err2;
      }
    }
    async enrollProfile(profile) {
      this.voiceProfileType = profile.profileType.toString();
      const enrollmentDeferral = new Exports_js_2.Deferred();
      this.privRequestSession.startNewRecognition();
      this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);
      this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const conPromise = this.connectImpl();
      const preAudioPromise = this.sendPreAudioMessages(profile, enrollmentDeferral);
      const node2 = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);
      const format = await this.privSpeakerAudioSource.format;
      const deviceInfo = await this.privSpeakerAudioSource.deviceInfo;
      const audioNode = new Exports_js_12.ReplayableAudioNode(node2, format.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };
      try {
        await conPromise;
        await preAudioPromise;
      } catch (err2) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, err2);
      }
      const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
      if (!!this.privRecognizer.sessionStarted) {
        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
      }
      void this.receiveMessage();
      const audioSendPromise = this.sendAudio(audioNode);
      audioSendPromise.then(() => {
      }, (error) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
      });
      return enrollmentDeferral.promise;
    }
    async sendPreAudioMessages(profile, enrollmentDeferral) {
      const connection = await this.fetchConnection();
      this.privRequestSession.onSpeechContext();
      this.privDeferralMap.add(this.privRequestSession.requestId, enrollmentDeferral);
      await this.sendBaseRequest(connection, "enroll", this.scenarioFrom(profile.profileType), profile);
    }
    async sendPhrasesRequest(getPhrasesDeferral, profileType, locale) {
      const connection = await this.fetchConnection();
      this.privRequestSession.onSpeechContext();
      this.privDeferralMap.add(this.privRequestSession.requestId, getPhrasesDeferral);
      const scenario = this.scenarioFrom(profileType);
      const profileCreateRequest = {
        locale,
        scenario
      };
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileCreateRequest)));
    }
    async sendCreateProfile(createProfileDeferral, profileType, locale) {
      const connection = await this.fetchConnection();
      this.privRequestSession.onSpeechContext();
      this.privDeferralMap.add(this.privRequestSession.requestId, createProfileDeferral);
      const scenario = profileType === Exports_js_3.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : profileType === Exports_js_3.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
      const profileCreateRequest = {
        locale,
        number: "1",
        scenario
      };
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileCreateRequest)));
    }
    async sendCommonRequest(operation, profileType, profile = void 0) {
      const conPromise = this.connectImpl();
      try {
        const deferral = new Exports_js_2.Deferred();
        this.privRequestSession.onSpeechContext();
        await conPromise;
        const connection = await this.fetchConnection();
        this.privDeferralMap.add(this.privRequestSession.requestId, deferral);
        await this.sendBaseRequest(connection, operation, this.scenarioFrom(profileType), profile);
        void this.receiveMessage();
        return deferral.promise;
      } catch (err2) {
        throw err2;
      }
    }
    async sendBaseRequest(connection, operation, scenario, profile) {
      const profileRequest = {
        scenario
      };
      if (!!profile) {
        profileRequest.profileIds = [profile.profileId];
      } else {
        profileRequest.maxPageSize = -1;
      }
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, `speaker.profile.${operation}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileRequest)));
    }
    extractSpeakerContext(model) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: model.profileIds,
        scenario: model.scenario
      };
    }
    handlePhrasesResponse(response, requestId) {
      if (!!this.privDeferralMap.getId(requestId)) {
        if (response.status.statusCode.toLowerCase() !== "success") {
          const reason = Exports_js_3.ResultReason.Canceled;
          const result = new Exports_js_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, []);
          this.privDeferralMap.complete(requestId, result);
        } else if (!!response.phrases && response.phrases.length > 0) {
          const reason = Exports_js_3.ResultReason.EnrollingVoiceProfile;
          const result = new Exports_js_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, response.phrases);
          this.privDeferralMap.complete(requestId, result);
        } else {
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
        }
      } else {
        throw new Error(`Voice Profile get activation phrases request for requestID ${requestId} not found`);
      }
    }
    handleCreateResponse(response, requestId) {
      if (!!response.profiles && response.profiles.length > 0) {
        if (!!this.privDeferralMap.getId(requestId)) {
          const profileIds = response.profiles.map((profile) => profile.profileId);
          this.privDeferralMap.complete(requestId, profileIds);
        } else {
          throw new Error(`Voice Profile create request for requestID ${requestId} not found`);
        }
      } else {
        throw new Error("Voice Profile create failed, no profile id received");
      }
    }
    handleResultResponse(response, requestId) {
      if (!!this.privDeferralMap.getId(requestId)) {
        const successReason = response.operation.toLowerCase() === "delete" ? Exports_js_3.ResultReason.DeletedVoiceProfile : Exports_js_3.ResultReason.ResetVoiceProfile;
        const reason = response.status.statusCode.toLowerCase() === "success" ? successReason : Exports_js_3.ResultReason.Canceled;
        const result = new Exports_js_3.VoiceProfileResult(reason, `statusCode: ${response.status.statusCode}, errorDetails: ${response.status.reason}`);
        this.privDeferralMap.complete(requestId, result);
      } else {
        throw new Error(`Voice Profile create request for requestID ${requestId} not found`);
      }
    }
    handleFetchResponse(enrollmentResponse, requestId) {
      if (!!this.privDeferralMap.getId(requestId) && !!enrollmentResponse.profiles[0]) {
        if (!!this.privExpectedProfileId && enrollmentResponse.profiles.length === 1 && enrollmentResponse.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const profileInfo = enrollmentResponse.profiles[0];
          const result = new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profileInfo.enrollmentStatus), JSON.stringify(profileInfo), enrollmentResponse.status.reason);
          this.privDeferralMap.complete(requestId, result);
        } else if (enrollmentResponse.profiles.length > 0) {
          const iProfiles = enrollmentResponse.profiles;
          const profileResults = [];
          for (const profile of iProfiles) {
            profileResults.push(new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profile.enrollmentStatus), JSON.stringify(profile), enrollmentResponse.status.reason));
          }
          this.privDeferralMap.complete(requestId, profileResults);
        }
      } else {
        throw new Error(`Voice Profile fetch request for requestID ${requestId} not found`);
      }
    }
    enrollmentReasonFrom(statusCode) {
      switch (statusCode.toLowerCase()) {
        case "enrolled":
          return Exports_js_3.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return Exports_js_3.ResultReason.Canceled;
        default:
          return Exports_js_3.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(profileType) {
      return profileType === Exports_js_3.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : profileType === Exports_js_3.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  VoiceServiceRecognizer.VoiceServiceRecognizer = VoiceServiceRecognizer$1;
  return VoiceServiceRecognizer;
}
var SpeechServiceConfig = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.type = exports.connectivity = exports.Device = exports.OS = exports.System = exports.Context = exports.SpeechServiceConfig = void 0;
  class SpeechServiceConfig2 {
    constructor(context) {
      this.context = context;
    }
    serialize() {
      return JSON.stringify(this, (key, value) => {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          const replacement = {};
          for (const k2 in value) {
            if (Object.hasOwnProperty.call(value, k2)) {
              replacement[k2 && k2.charAt(0).toLowerCase() + k2.substring(1)] = value[k2];
            }
          }
          return replacement;
        }
        return value;
      });
    }
    get Context() {
      return this.context;
    }
    get Recognition() {
      return this.recognition;
    }
    set Recognition(value) {
      this.recognition = value.toLowerCase();
    }
  }
  exports.SpeechServiceConfig = SpeechServiceConfig2;
  class Context {
    constructor(os) {
      this.system = new System();
      this.os = os;
    }
  }
  exports.Context = Context;
  class System {
    constructor() {
      const SPEECHSDK_CLIENTSDK_VERSION = "1.40.0";
      this.name = "SpeechSDK";
      this.version = SPEECHSDK_CLIENTSDK_VERSION;
      this.build = "JavaScript";
      this.lang = "JavaScript";
    }
  }
  exports.System = System;
  class OS {
    constructor(platform, name2, version2) {
      this.platform = platform;
      this.name = name2;
      this.version = version2;
    }
  }
  exports.OS = OS;
  class Device {
    constructor(manufacturer, model, version2) {
      this.manufacturer = manufacturer;
      this.model = model;
      this.version = version2;
    }
  }
  exports.Device = Device;
  (function(connectivity) {
    connectivity["Bluetooth"] = "Bluetooth";
    connectivity["Wired"] = "Wired";
    connectivity["WiFi"] = "WiFi";
    connectivity["Cellular"] = "Cellular";
    connectivity["InBuilt"] = "InBuilt";
    connectivity["Unknown"] = "Unknown";
  })(exports.connectivity || (exports.connectivity = {}));
  (function(type) {
    type["Phone"] = "Phone";
    type["Speaker"] = "Speaker";
    type["Car"] = "Car";
    type["Headset"] = "Headset";
    type["Thermostat"] = "Thermostat";
    type["Microphones"] = "Microphones";
    type["Deskphone"] = "Deskphone";
    type["RemoteControl"] = "RemoteControl";
    type["Unknown"] = "Unknown";
    type["File"] = "File";
    type["Stream"] = "Stream";
  })(exports.type || (exports.type = {}));
})(SpeechServiceConfig);
var hasRequiredExports;
function requireExports() {
  if (hasRequiredExports) return Exports$6;
  hasRequiredExports = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m2[k2];
    });
    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !exports2.hasOwnProperty(p2)) __createBinding2(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AutoDetectSourceLanguagesOpenRangeOptionName = exports.ForceDictationPropertyName = exports.ServicePropertiesPropertyName = exports.CancellationErrorCodePropertyName = exports.OutputFormatPropertyName = void 0;
    __exportStar(CognitiveSubscriptionKeyAuthentication$1, exports);
    __exportStar(CognitiveTokenAuthentication$1, exports);
    __exportStar(IAuthentication, exports);
    __exportStar(IConnectionFactory, exports);
    __exportStar(ISynthesisConnectionFactory, exports);
    __exportStar(requireIntentConnectionFactory(), exports);
    __exportStar(requireSpeakerRecognitionConnectionFactory(), exports);
    __exportStar(RecognitionEvents, exports);
    __exportStar(requireServiceRecognizerBase(), exports);
    __exportStar(requireConversationServiceRecognizer(), exports);
    __exportStar(requireRecognizerConfig(), exports);
    __exportStar(SpeechServiceInterfaces, exports);
    __exportStar(WebsocketMessageFormatter$1, exports);
    __exportStar(requireSpeechConnectionFactory(), exports);
    __exportStar(requireConversationTranscriberConnectionFactory(), exports);
    __exportStar(requireTranscriberConnectionFactory(), exports);
    __exportStar(requireTranslationConnectionFactory(), exports);
    __exportStar(requireSpeechSynthesisConnectionFactory(), exports);
    __exportStar(requireEnumTranslation(), exports);
    __exportStar(Enums, exports);
    __exportStar(requireTranslationSynthesisEnd(), exports);
    __exportStar(TranslationHypothesis$1, exports);
    __exportStar(requireTranslationPhrase(), exports);
    __exportStar(requireTranslationServiceRecognizer(), exports);
    __exportStar(SpeechDetected$1, exports);
    __exportStar(SpeechHypothesis$1, exports);
    __exportStar(SpeechKeyword$1, exports);
    __exportStar(requireSpeechServiceRecognizer(), exports);
    __exportStar(requireConversationTranscriptionServiceRecognizer(), exports);
    __exportStar(requireTranscriptionServiceRecognizer(), exports);
    __exportStar(requireDetailedSpeechPhrase(), exports);
    __exportStar(requireSimpleSpeechPhrase(), exports);
    __exportStar(AddedLmIntent$1, exports);
    __exportStar(requireIntentServiceRecognizer(), exports);
    __exportStar(IntentResponse$1, exports);
    __exportStar(SpeakerResponse, exports);
    __exportStar(RequestSession$1, exports);
    __exportStar(SpeechContext$1, exports);
    __exportStar(DynamicGrammarBuilder$1, exports);
    __exportStar(DynamicGrammarInterfaces, exports);
    __exportStar(requireDialogServiceAdapter(), exports);
    __exportStar(AgentConfig$1, exports);
    __exportStar(requireExports$1(), exports);
    __exportStar(SynthesisAudioMetadata, exports);
    __exportStar(requireSynthesisTurn(), exports);
    __exportStar(requireSynthesisAdapterBase(), exports);
    var AvatarSynthesisAdapter_js_1 = requireAvatarSynthesisAdapter();
    Object.defineProperty(exports, "AvatarSynthesisAdapter", { enumerable: true, get: function() {
      return AvatarSynthesisAdapter_js_1.AvatarSynthesisAdapter;
    } });
    var SpeechSynthesisAdapter_js_1 = requireSpeechSynthesisAdapter();
    Object.defineProperty(exports, "SpeechSynthesisAdapter", { enumerable: true, get: function() {
      return SpeechSynthesisAdapter_js_1.SpeechSynthesisAdapter;
    } });
    __exportStar(requireSynthesisRestAdapter(), exports);
    __exportStar(requireSynthesizerConfig(), exports);
    __exportStar(requireSynthesisContext(), exports);
    __exportStar(requireSpeakerRecognitionConfig(), exports);
    __exportStar(requireSpeakerServiceRecognizer(), exports);
    __exportStar(requireVoiceServiceRecognizer(), exports);
    __exportStar(SpeechServiceConfig, exports);
    exports.OutputFormatPropertyName = "OutputFormat";
    exports.CancellationErrorCodePropertyName = "CancellationErrorCode";
    exports.ServicePropertiesPropertyName = "ServiceProperties";
    exports.ForceDictationPropertyName = "ForceDictation";
    exports.AutoDetectSourceLanguagesOpenRangeOptionName = "OpenRange";
  })(Exports$6);
  return Exports$6;
}
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o, m2, k2, k22) {
    if (k22 === void 0) k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2) if (p2 !== "default" && !exports2.hasOwnProperty(p2)) __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  const Exports_js_12 = requireExports();
  void new Exports_js_12.AgentConfig();
  __exportStar(requireExports$3(), exports);
})(microsoft_cognitiveservices_speech_sdk);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "169";
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const AttachedBindMode = "attached";
const DetachedBindMode = "detached";
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const UnsignedInt5999Type = 35902;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const DisplayP3ColorSpace = "display-p3";
const LinearDisplayP3ColorSpace = "display-p3-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const Rec709Primaries = "rec709";
const P3Primaries = "p3";
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage = 35044;
const GLSL3 = "300 es";
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index2 = listenerArray.indexOf(listener);
      if (index2 !== -1) {
        listenerArray.splice(index2, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l2 = array.length; i < l2; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _seed = 1234567;
const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max2) {
  return Math.max(min, Math.min(max2, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y2, value) {
  if (x !== y2) {
    return (value - x) / (y2 - x);
  } else {
    return 0;
  }
}
function lerp(x, y2, t2) {
  return (1 - t2) * x + t2 * y2;
}
function damp(x, y2, lambda, dt) {
  return lerp(x, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max2) {
  if (x <= min) return 0;
  if (x >= max2) return 1;
  x = (x - min) / (max2 - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max2) {
  if (x <= min) return 0;
  if (x >= max2) return 1;
  x = (x - min) / (max2 - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t2 = _seed += 1831565813;
  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a, b, c, order2) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order2) {
    case "XYX":
      q2.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q2.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q2.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q2.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q2.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q2.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order2);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize$2(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize: normalize$2,
  denormalize
};
class Vector2 {
  constructor(x = 0, y2 = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y2) {
    this.x = x;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v2, s) {
    this.x += v2.x * s;
    this.y += v2.y * s;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x = this.x, y2 = this.y;
    const e = m2.elements;
    this.x = e[0] * x + e[3] * y2 + e[6];
    this.y = e[1] * x + e[4] * y2 + e[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min, max2) {
    this.x = Math.max(min.x, Math.min(max2.x, this.x));
    this.y = Math.max(min.y, Math.min(max2.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v12, v2, alpha) {
    this.x = v12.x + (v2.x - v12.x) * alpha;
    this.y = v12.y + (v2.y - v12.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x * c - y2 * s + center.x;
    this.y = x * s + y2 * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me2 = m2.elements;
    this.set(
      me2[0],
      me2[4],
      me2[8],
      me2[1],
      me2[5],
      me2[9],
      me2[2],
      me2[6],
      me2[10]
    );
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a, b) {
    const ae2 = a.elements;
    const be2 = b.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be2[0], b12 = be2[3], b13 = be2[6];
    const b21 = be2[1], b22 = be2[4], b23 = be2[7];
    const b31 = be2[2], b32 = be2[5], b33 = be2[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te2 = this.elements;
    te2[0] *= s;
    te2[3] *= s;
    te2[6] *= s;
    te2[1] *= s;
    te2[4] *= s;
    te2[7] *= s;
    te2[2] *= s;
    te2[5] *= s;
    te2[8] *= s;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const a = te2[0], b = te2[1], c = te2[2], d = te2[3], e = te2[4], f2 = te2[5], g = te2[6], h = te2[7], i = te2[8];
    return a * e * i - a * f2 * h - b * d * i + b * f2 * g + c * d * h - c * e * g;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp;
    const m2 = this.elements;
    tmp = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp;
    tmp = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp;
    tmp = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y2) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y2,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y2) {
    this.set(
      x,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te2[i] !== me2[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true;
  }
  return false;
}
function createElementNS(name2) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name2);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function probeAsync(gl2, sync, interval) {
  return new Promise(function(resolve, reject) {
    function probe() {
      switch (gl2.clientWaitSync(sync, gl2.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl2.WAIT_FAILED:
          reject();
          break;
        case gl2.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve();
      }
    }
    setTimeout(probe, interval);
  });
}
function toNormalizedProjectionMatrix(projectionMatrix) {
  const m2 = projectionMatrix.elements;
  m2[2] = 0.5 * m2[2] + 0.5 * m2[3];
  m2[6] = 0.5 * m2[6] + 0.5 * m2[7];
  m2[10] = 0.5 * m2[10] + 0.5 * m2[11];
  m2[14] = 0.5 * m2[14] + 0.5 * m2[15];
}
function toReversedProjectionMatrix(projectionMatrix) {
  const m2 = projectionMatrix.elements;
  const isPerspectiveMatrix = m2[11] === -1;
  if (isPerspectiveMatrix) {
    m2[10] = -m2[10] - 1;
    m2[14] = -m2[14];
  } else {
    m2[10] = -m2[10];
    m2[14] = -m2[14] + 1;
  }
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
);
const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
);
const COLOR_SPACES = {
  [LinearSRGBColorSpace]: {
    transfer: LinearTransfer,
    primaries: Rec709Primaries,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (color2) => color2,
    fromReference: (color2) => color2
  },
  [SRGBColorSpace]: {
    transfer: SRGBTransfer,
    primaries: Rec709Primaries,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (color2) => color2.convertSRGBToLinear(),
    fromReference: (color2) => color2.convertLinearToSRGB()
  },
  [LinearDisplayP3ColorSpace]: {
    transfer: LinearTransfer,
    primaries: P3Primaries,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (color2) => color2.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color2) => color2.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
  },
  [DisplayP3ColorSpace]: {
    transfer: SRGBTransfer,
    primaries: P3Primaries,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (color2) => color2.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color2) => color2.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
  }
};
const SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
const ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error(`Unsupported working color space, "${colorSpace}".`);
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function(color2, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color2;
    }
    const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color2));
  },
  fromWorkingColorSpace: function(color2, targetColorSpace) {
    return this.convert(color2, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color2, sourceColorSpace) {
    return this.convert(color2, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace) return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  },
  getLuminanceCoefficients: function(target, colorSpace = this._workingColorSpace) {
    return target.fromArray(COLOR_SPACES[colorSpace].luminanceCoefficients);
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(image2) {
    if (/^data:/i.test(image2.src)) {
      return image2.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image2.src;
    }
    let canvas;
    if (image2 instanceof HTMLCanvasElement) {
      canvas = image2;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image2.width;
      _canvas.height = image2.height;
      const context = _canvas.getContext("2d");
      if (image2 instanceof ImageData) {
        context.putImageData(image2, 0, 0);
      } else {
        context.drawImage(image2, 0, 0, image2.width, image2.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image2);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image2) {
    if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image2.width;
      canvas.height = image2.height;
      const context = canvas.getContext("2d");
      context.drawImage(image2, 0, 0, image2.width, image2.height);
      const imageData = context.getImageData(0, 0, image2.width, image2.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image2.data) {
      const data = image2.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image2.width,
        height: image2.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image2;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l2 = data.length; i < l2; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image2) {
  if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image2);
  } else {
    if (image2.data) {
      return {
        data: Array.from(image2.data),
        width: image2.width,
        height: image2.height,
        type: image2.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(image2 = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image2);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(x = 0, y2 = 0, z2 = 0, w2 = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y2, z2, w2) {
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v2, s) {
    this.x += v2.x * s;
    this.y += v2.y * s;
    this.z += v2.z * s;
    this.w += v2.w * s;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e = m2.elements;
    this.x = e[0] * x + e[4] * y2 + e[8] * z2 + e[12] * w2;
    this.y = e[1] * x + e[5] * y2 + e[9] * z2 + e[13] * w2;
    this.z = e[2] * x + e[6] * y2 + e[10] * z2 + e[14] * w2;
    this.w = e[3] * x + e[7] * y2 + e[11] * z2 + e[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s = Math.sqrt(1 - q2.w * q2.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s;
      this.y = q2.y / s;
      this.z = q2.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y2 = xy / x;
          z2 = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x, y2, z2, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e = m2.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    this.w = e[15];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min, max2) {
    this.x = Math.max(min.x, Math.min(max2.x, this.x));
    this.y = Math.max(min.y, Math.min(max2.y, this.y));
    this.z = Math.max(min.z, Math.min(max2.z, this.z));
    this.w = Math.max(min.w, Math.min(max2.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v12, v2, alpha) {
    this.x = v12.x + (v2.x - v12.x) * alpha;
    this.y = v12.y + (v2.y - v12.y) * alpha;
    this.z = v12.z + (v2.z - v12.z) * alpha;
    this.w = v12.w + (v2.w - v12.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    this.w = attribute.getW(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image2 = { width, height, depth: 1 };
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1
    }, options);
    const texture = new Texture(image2, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    texture.flipY = false;
    texture.generateMipmaps = options.generateMipmaps;
    texture.internalFormat = options.internalFormat;
    this.textures = [];
    const count = options.count;
    for (let i = 0; i < count; i++) {
      this.textures[i] = texture.clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il2 = this.textures.length; i < il2; i++) {
        this.textures[i].image.width = width;
        this.textures[i].image.height = height;
        this.textures[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i = 0, il2 = source.textures.length; i < il2; i++) {
      this.textures[i] = source.textures[i].clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    const image2 = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image2);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class Quaternion {
  constructor(x = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y2, z2, w2) {
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update = true) {
    const x = euler._x, y2 = euler._y, z2 = euler._z, order2 = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order2) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order2);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
  }
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0) return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q2) {
    return this.multiplyQuaternions(this, q2);
  }
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb2, t2) {
    if (t2 === 0) return this;
    if (t2 === 1) return this.copy(qb2);
    const x = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb2._w + x * qb2._x + y2 * qb2._y + z2 * qb2._z;
    if (cosHalfTheta < 0) {
      this._w = -qb2._w;
      this._x = -qb2._x;
      this._y = -qb2._y;
      this._z = -qb2._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb2);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x;
      this._y = y2;
      this._z = z2;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t2;
      this._w = s * w2 + t2 * this._w;
      this._x = s * x + t2 * this._x;
      this._y = s * y2 + t2 * this._y;
      this._z = s * z2 + t2 * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z2 * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa2, qb2, t2) {
    return this.copy(qa2).slerp(qb2, t2);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this._x = attribute.getX(index2);
    this._y = attribute.getY(index2);
    this._z = attribute.getZ(index2);
    this._w = attribute.getW(index2);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
}
class Vector3 {
  constructor(x = 0, y2 = 0, z2 = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y2;
    this.z = z2;
  }
  set(x, y2, z2) {
    if (z2 === void 0) z2 = this.z;
    this.x = x;
    this.y = y2;
    this.z = z2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z2) {
    this.z = z2;
    return this;
  }
  setComponent(index2, value) {
    switch (index2) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index2);
    }
    return this;
  }
  getComponent(index2) {
    switch (index2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v2, s) {
    this.x += v2.x * s;
    this.y += v2.y * s;
    this.z += v2.z * s;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const e = m2.elements;
    this.x = e[0] * x + e[3] * y2 + e[6] * z2;
    this.y = e[1] * x + e[4] * y2 + e[7] * z2;
    this.z = e[2] * x + e[5] * y2 + e[8] * z2;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const e = m2.elements;
    const w2 = 1 / (e[3] * x + e[7] * y2 + e[11] * z2 + e[15]);
    this.x = (e[0] * x + e[4] * y2 + e[8] * z2 + e[12]) * w2;
    this.y = (e[1] * x + e[5] * y2 + e[9] * z2 + e[13]) * w2;
    this.z = (e[2] * x + e[6] * y2 + e[10] * z2 + e[14]) * w2;
    return this;
  }
  applyQuaternion(q2) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x = this.x, y2 = this.y, z2 = this.z;
    const e = m2.elements;
    this.x = e[0] * x + e[4] * y2 + e[8] * z2;
    this.y = e[1] * x + e[5] * y2 + e[9] * z2;
    this.z = e[2] * x + e[6] * y2 + e[10] * z2;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min, max2) {
    this.x = Math.max(min.x, Math.min(max2.x, this.x));
    this.y = Math.max(min.y, Math.min(max2.y, this.y));
    this.z = Math.max(min.z, Math.min(max2.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max2) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v12, v2, alpha) {
    this.x = v12.x + (v2.x - v12.x) * alpha;
    this.y = v12.y + (v2.y - v12.y) * alpha;
    this.z = v12.z + (v2.z - v12.z) * alpha;
    return this;
  }
  cross(v2) {
    return this.crossVectors(this, v2);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e = m2.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index2) {
    return this.fromArray(m2.elements, index2 * 4);
  }
  setFromMatrix3Column(m2, index2) {
    return this.fromArray(m2.elements, index2 * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.x = attribute.getX(index2);
    this.y = attribute.getY(index2);
    this.z = attribute.getZ(index2);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u2 = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u2 * u2);
    this.x = c * Math.cos(theta);
    this.y = u2;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
}
const _vector$c = /* @__PURE__ */ new Vector3();
const _quaternion$4 = /* @__PURE__ */ new Quaternion();
class Box3 {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max2;
  }
  set(min, max2) {
    this.min.copy(min);
    this.max.copy(max2);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i = 0, il2 = array.length; i < il2; i += 3) {
      this.expandByPoint(_vector$b.fromArray(array, i));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i = 0, il2 = attribute.count; i < il2; i++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il2 = points.length; i < il2; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point2) {
    this.min.min(point2);
    this.max.max(point2);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i = 0, l2 = positionAttribute.count; i < l2; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  containsPoint(point2) {
    return point2.x >= this.min.x && point2.x <= this.max.x && point2.y >= this.min.y && point2.y <= this.max.y && point2.z >= this.min.z && point2.z <= this.max.z;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point2, target) {
    return target.set(
      (point2.x - this.min.x) / (this.max.x - this.min.x),
      (point2.y - this.min.y) / (this.max.y - this.min.y),
      (point2.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max2;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max2 = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max2 = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max2 += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max2 += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max2 += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max2 += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max2 >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$3.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$3);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$3, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);
  }
  clampPoint(point2, target) {
    return target.copy(point2).clamp(this.min, this.max);
  }
  distanceToPoint(point2) {
    return this.clampPoint(point2, _vector$b).distanceTo(point2);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
const _vector$b = /* @__PURE__ */ new Vector3();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$3 = /* @__PURE__ */ new Vector3();
const _v1$7 = /* @__PURE__ */ new Vector3();
const _v2$4 = /* @__PURE__ */ new Vector3();
const _f0 = /* @__PURE__ */ new Vector3();
const _f1 = /* @__PURE__ */ new Vector3();
const _f2 = /* @__PURE__ */ new Vector3();
const _center = /* @__PURE__ */ new Vector3();
const _extents = /* @__PURE__ */ new Vector3();
const _triangleNormal = /* @__PURE__ */ new Vector3();
const _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v12, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v12.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3();
const _v2$3 = /* @__PURE__ */ new Vector3();
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il2 = points.length; i < il2; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point2) {
    return point2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point2) {
    return point2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point2, target) {
    const deltaLengthSq = this.center.distanceToSquared(point2);
    target.copy(point2);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point2) {
    if (this.isEmpty()) {
      this.center.copy(point2);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point2, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3();
const _segCenter = /* @__PURE__ */ new Vector3();
const _segDir = /* @__PURE__ */ new Vector3();
const _diff = /* @__PURE__ */ new Vector3();
const _edge1 = /* @__PURE__ */ new Vector3();
const _edge2 = /* @__PURE__ */ new Vector3();
const _normal$1 = /* @__PURE__ */ new Vector3();
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t2);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  closestPointToPoint(point2, target) {
    target.subVectors(point2, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point2) {
    return Math.sqrt(this.distanceSqToPoint(point2));
  }
  distanceSqToPoint(point2) {
    const directionDistance = _vector$a.subVectors(point2, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point2);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point2);
  }
  distanceSqToSegment(v0, v12, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v12).multiplyScalar(0.5);
    _segDir.copy(v12).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v12) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  copyPosition(m2) {
    const te2 = this.elements, me2 = m2.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me2 = m2.elements;
    this.set(
      me2[0],
      me2[3],
      me2[6],
      0,
      me2[1],
      me2[4],
      me2[7],
      0,
      me2[2],
      me2[5],
      me2[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te2 = this.elements;
    const x = euler.x, y2 = euler.y, z2 = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y2), d = Math.sin(y2);
    const e = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae2 = a * e, af2 = a * f2, be2 = b * e, bf2 = b * f2;
      te2[0] = c * e;
      te2[4] = -c * f2;
      te2[8] = d;
      te2[1] = af2 + be2 * d;
      te2[5] = ae2 - bf2 * d;
      te2[9] = -b * c;
      te2[2] = bf2 - ae2 * d;
      te2[6] = be2 + af2 * d;
      te2[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce2 = c * e, cf2 = c * f2, de2 = d * e, df2 = d * f2;
      te2[0] = ce2 + df2 * b;
      te2[4] = de2 * b - cf2;
      te2[8] = a * d;
      te2[1] = a * f2;
      te2[5] = a * e;
      te2[9] = -b;
      te2[2] = cf2 * b - de2;
      te2[6] = df2 + ce2 * b;
      te2[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce2 = c * e, cf2 = c * f2, de2 = d * e, df2 = d * f2;
      te2[0] = ce2 - df2 * b;
      te2[4] = -a * f2;
      te2[8] = de2 + cf2 * b;
      te2[1] = cf2 + de2 * b;
      te2[5] = a * e;
      te2[9] = df2 - ce2 * b;
      te2[2] = -a * d;
      te2[6] = b;
      te2[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae2 = a * e, af2 = a * f2, be2 = b * e, bf2 = b * f2;
      te2[0] = c * e;
      te2[4] = be2 * d - af2;
      te2[8] = ae2 * d + bf2;
      te2[1] = c * f2;
      te2[5] = bf2 * d + ae2;
      te2[9] = af2 * d - be2;
      te2[2] = -d;
      te2[6] = b * c;
      te2[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac2 = a * c, ad2 = a * d, bc2 = b * c, bd2 = b * d;
      te2[0] = c * e;
      te2[4] = bd2 - ac2 * f2;
      te2[8] = bc2 * f2 + ad2;
      te2[1] = f2;
      te2[5] = a * e;
      te2[9] = -b * e;
      te2[2] = -d * e;
      te2[6] = ad2 * f2 + bc2;
      te2[10] = ac2 - bd2 * f2;
    } else if (euler.order === "XZY") {
      const ac2 = a * c, ad2 = a * d, bc2 = b * c, bd2 = b * d;
      te2[0] = c * e;
      te2[4] = -f2;
      te2[8] = d * e;
      te2[1] = ac2 * f2 + bd2;
      te2[5] = a * e;
      te2[9] = ad2 * f2 - bc2;
      te2[2] = bc2 * f2 - ad2;
      te2[6] = b * e;
      te2[10] = bd2 * f2 + ac2;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  lookAt(eye, target, up) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a, b) {
    const ae2 = a.elements;
    const be2 = b.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
    const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
    const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
    const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te2 = this.elements;
    te2[0] *= s;
    te2[4] *= s;
    te2[8] *= s;
    te2[12] *= s;
    te2[1] *= s;
    te2[5] *= s;
    te2[9] *= s;
    te2[13] *= s;
    te2[2] *= s;
    te2[6] *= s;
    te2[10] *= s;
    te2[14] *= s;
    te2[3] *= s;
    te2[7] *= s;
    te2[11] *= s;
    te2[15] *= s;
    return this;
  }
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te2 = this.elements;
    let tmp;
    tmp = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp;
    tmp = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp;
    tmp = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp;
    tmp = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp;
    tmp = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp;
    tmp = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp;
    return this;
  }
  setPosition(x, y2, z2) {
    const te2 = this.elements;
    if (x.isVector3) {
      te2[12] = x.x;
      te2[13] = x.y;
      te2[14] = x.z;
    } else {
      te2[12] = x;
      te2[13] = y2;
      te2[14] = z2;
    }
    return this;
  }
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te2 = this.elements;
    const x = v2.x, y2 = v2.y, z2 = v2.z;
    te2[0] *= x;
    te2[4] *= y2;
    te2[8] *= z2;
    te2[1] *= x;
    te2[5] *= y2;
    te2[9] *= z2;
    te2[2] *= x;
    te2[6] *= y2;
    te2[10] *= z2;
    te2[3] *= x;
    te2[7] *= y2;
    te2[11] *= z2;
    return this;
  }
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y2, z2) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y2,
        0,
        0,
        1,
        z2,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t2 = 1 - c;
    const x = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x, ty = t2 * y2;
    this.set(
      tx * x + c,
      tx * y2 - s * z2,
      tx * z2 + s * y2,
      0,
      tx * y2 + s * z2,
      ty * y2 + c,
      ty * z2 - s * x,
      0,
      tx * z2 - s * y2,
      ty * z2 + s * x,
      t2 * z2 * z2 + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y2, z2) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      0,
      z2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position2, quaternion, scale) {
    const te2 = this.elements;
    const x = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    const x2 = x + x, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x * x2, xy = x * y22, xz = x * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w2 * x2, wy = w2 * y22, wz = w2 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position2.x;
    te2[13] = position2.y;
    te2[14] = position2.z;
    te2[15] = 1;
    return this;
  }
  decompose(position2, quaternion, scale) {
    const te2 = this.elements;
    let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
    const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position2.x = te2[12];
    position2.y = te2[13];
    position2.z = te2[14];
    _m1$4.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$4.elements[0] *= invSX;
    _m1$4.elements[1] *= invSX;
    _m1$4.elements[2] *= invSX;
    _m1$4.elements[4] *= invSY;
    _m1$4.elements[5] *= invSY;
    _m1$4.elements[6] *= invSY;
    _m1$4.elements[8] *= invSZ;
    _m1$4.elements[9] *= invSZ;
    _m1$4.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$4);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te2 = this.elements;
    const x = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te2[0] = x;
    te2[4] = 0;
    te2[8] = a;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y2;
    te2[9] = b;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c;
    te2[14] = d;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te2 = this.elements;
    const w2 = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x = (right + left) * w2;
    const y2 = (top + bottom) * h;
    let z2, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z2 = (far + near) * p2;
      zInv = -2 * p2;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z2 = near * p2;
      zInv = -1 * p2;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te2[0] = 2 * w2;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = -x;
    te2[1] = 0;
    te2[5] = 2 * h;
    te2[9] = 0;
    te2[13] = -y2;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = zInv;
    te2[14] = -z2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te2[i] !== me2[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    array[offset + 9] = te2[9];
    array[offset + 10] = te2[10];
    array[offset + 11] = te2[11];
    array[offset + 12] = te2[12];
    array[offset + 13] = te2[13];
    array[offset + 14] = te2[14];
    array[offset + 15] = te2[15];
    return array;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3();
const _m1$4 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3();
const _y = /* @__PURE__ */ new Vector3();
const _z = /* @__PURE__ */ new Vector3();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion();
class Euler {
  constructor(x = 0, y2 = 0, z2 = 0, order2 = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._order = order2;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y2, z2, order2 = this._order) {
    this._x = x;
    this._y = y2;
    this._z = z2;
    this._order = order2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order2 = this._order, update = true) {
    const te2 = m2.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order2) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order2);
    }
    this._order = order2;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q2, order2, update) {
    _matrix$2.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$2, order2, update);
  }
  setFromVector3(v2, order2 = this._order) {
    return this.set(v2.x, v2.y, v2.z, order2);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3();
const _q1 = /* @__PURE__ */ new Quaternion();
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3();
const _position$3 = /* @__PURE__ */ new Vector3();
const _scale$2 = /* @__PURE__ */ new Vector3();
const _quaternion$2 = /* @__PURE__ */ new Quaternion();
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position2 = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position2
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
  }
  lookAt(x, y2, z2) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$3.lookAt(_position$3, _target, this.up);
    } else {
      _m1$3.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$3);
    if (parent) {
      _m1$3.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$3);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index2 = this.children.indexOf(object);
    if (index2 !== -1) {
      object.parent = null;
      this.children.splice(index2, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$3.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$3.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$3);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  getObjectById(id2) {
    return this.getObjectByProperty("id", id2);
  }
  getObjectByName(name2) {
    return this.getObjectByProperty("name", name2);
  }
  getObjectByProperty(name2, value) {
    if (this[name2] === value) return this;
    for (let i = 0, l2 = this.children.length; i < l2; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name2, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name2, value, result = []) {
    if (this[name2] === value) result.push(this);
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      children[i].getObjectsByProperty(name2, value, result);
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      const child = children[i];
      child.updateMatrixWorld(force);
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l2 = children.length; i < l2; i++) {
        const child = children[i];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray()
      }));
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray()
        };
      }
    }
    function serialize2(library, element2) {
      if (library[element2.uuid] === void 0) {
        library[element2.uuid] = element2.toJSON(meta);
      }
      return element2.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize2(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l2 = shapes.length; i < l2; i++) {
            const shape = shapes[i];
            serialize2(meta.shapes, shape);
          }
        } else {
          serialize2(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize2(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l2 = this.material.length; i < l2; i++) {
          uuids.push(serialize2(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize2(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize2(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$2 = /* @__PURE__ */ new Vector3();
const _v1$3 = /* @__PURE__ */ new Vector3();
const _v2$2 = /* @__PURE__ */ new Vector3();
const _v3$2 = /* @__PURE__ */ new Vector3();
const _vab = /* @__PURE__ */ new Vector3();
const _vac = /* @__PURE__ */ new Vector3();
const _vbc = /* @__PURE__ */ new Vector3();
const _vap = /* @__PURE__ */ new Vector3();
const _vbp = /* @__PURE__ */ new Vector3();
const _vcp = /* @__PURE__ */ new Vector3();
const _v40 = /* @__PURE__ */ new Vector4();
const _v41 = /* @__PURE__ */ new Vector4();
const _v42 = /* @__PURE__ */ new Vector4();
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$2.subVectors(a, b);
    target.cross(_v0$2);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point2, a, b, c, target) {
    _v0$2.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point2, a);
    const dot00 = _v0$2.dot(_v0$2);
    const dot01 = _v0$2.dot(_v1$3);
    const dot02 = _v0$2.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point2, a, b, c) {
    if (this.getBarycoord(point2, a, b, c, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(point2, p1, p2, p3, v12, v2, v32, target) {
    if (this.getBarycoord(point2, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v12, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v32, _v3$2.z);
    return target;
  }
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$2.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$2.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$2.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$2.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point2, target) {
    return Triangle.getBarycoord(point2, this.a, this.b, this.c, target);
  }
  getInterpolation(point2, v12, v2, v32, target) {
    return Triangle.getInterpolation(point2, this.a, this.b, this.c, v12, v2, v32, target);
  }
  containsPoint(point2) {
    return Triangle.containsPoint(point2, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    const a = this.a, b = this.b, c = this.c;
    let v2, w2;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p2, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p2, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc2 = d1 * d4 - d3 * d2;
    if (vc2 <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb2 = d5 * d2 - d1 * d6;
    if (vb2 <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w2);
    }
    const va2 = d3 * d6 - d5 * d4;
    if (va2 <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va2 + vb2 + vc2);
    v2 = vb2 * denom;
    w2 = vc2 * denom;
    return target.copy(a).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
}
const _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2) return q2;
  if (t2 < 2 / 3) return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
class Color {
  constructor(r2, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r2, g, b);
  }
  set(r2, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r2;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r2, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r2, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r2;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l2, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h + 1 / 3);
      this.g = hue2rgb(q2, p2, h);
      this.b = hue2rgb(q2, p2, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string2) {
      if (string2 === void 0) return;
      if (parseFloat(string2) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color2;
      const name2 = m2[1];
      const components = m2[2];
      switch (name2) {
        case "rgb":
        case "rgba":
          if (color2 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(255, parseInt(color2[1], 10)) / 255,
              Math.min(255, parseInt(color2[2], 10)) / 255,
              Math.min(255, parseInt(color2[3], 10)) / 255,
              colorSpace
            );
          }
          if (color2 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setRGB(
              Math.min(100, parseInt(color2[1], 10)) / 100,
              Math.min(100, parseInt(color2[2], 10)) / 100,
              Math.min(100, parseInt(color2[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color2 = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color2[4]);
            return this.setHSL(
              parseFloat(color2[1]) / 360,
              parseFloat(color2[2]) / 100,
              parseFloat(color2[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color2) {
    this.r = color2.r;
    this.g = color2.g;
    this.b = color2.b;
    return this;
  }
  copySRGBToLinear(color2) {
    this.r = SRGBToLinear(color2.r);
    this.g = SRGBToLinear(color2.g);
    this.b = SRGBToLinear(color2.b);
    return this;
  }
  copyLinearToSRGB(color2) {
    this.r = LinearToSRGB(color2.r);
    this.g = LinearToSRGB(color2.g);
    this.b = LinearToSRGB(color2.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g = _color.g, b = _color.b;
    const max2 = Math.max(r2, g, b);
    const min = Math.min(r2, g, b);
    let hue, saturation;
    const lightness = (min + max2) / 2;
    if (min === max2) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max2 - min;
      saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);
      switch (max2) {
        case r2:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r2) / delta + 2;
          break;
        case b:
          hue = (r2 - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r2.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r2 * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s, l2) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l2);
  }
  add(color2) {
    this.r += color2.r;
    this.g += color2.g;
    this.b += color2.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color2) {
    this.r = Math.max(0, this.r - color2.r);
    this.g = Math.max(0, this.g - color2.g);
    this.b = Math.max(0, this.b - color2.b);
    return this;
  }
  multiply(color2) {
    this.r *= color2.r;
    this.g *= color2.g;
    this.b *= color2.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color2, alpha) {
    this.r += (color2.r - this.r) * alpha;
    this.g += (color2.g - this.g) * alpha;
    this.b += (color2.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color2, alpha) {
    this.getHSL(_hslA);
    color2.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l2);
    return this;
  }
  setFromVector3(v2) {
    this.r = v2.x;
    this.g = v2.y;
    this.b = v2.z;
    return this;
  }
  applyMatrix3(m2) {
    const r2 = this.r, g = this.g, b = this.b;
    const e = m2.elements;
    this.r = e[0] * r2 + e[3] * g + e[6] * b;
    this.g = e[1] * r2 + e[4] * g + e[7] * b;
    this.b = e[2] * r2 + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index2) {
    this.r = attribute.getX(index2);
    this.g = attribute.getY(index2);
    this.b = attribute.getZ(index2);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.dispersion !== void 0) data.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i = 0; i !== n2; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vector$9 = /* @__PURE__ */ new Vector3();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l2 = this.itemSize; i < l2; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i = 0, l2 = this.count; i < l2; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l2 = this.count; i < l2; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m2) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m2);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index2, component) {
    let value = this.array[index2 * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index2, component, value) {
    if (this.normalized) value = normalize$2(value, this.array);
    this.array[index2 * this.itemSize + component] = value;
    return this;
  }
  getX(index2) {
    let x = this.array[index2 * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index2, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.array[index2 * this.itemSize] = x;
    return this;
  }
  getY(index2) {
    let y2 = this.array[index2 * this.itemSize + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  setY(index2, y2) {
    if (this.normalized) y2 = normalize$2(y2, this.array);
    this.array[index2 * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index2) {
    let z2 = this.array[index2 * this.itemSize + 2];
    if (this.normalized) z2 = denormalize(z2, this.array);
    return z2;
  }
  setZ(index2, z2) {
    if (this.normalized) z2 = normalize$2(z2, this.array);
    this.array[index2 * this.itemSize + 2] = z2;
    return this;
  }
  getW(index2) {
    let w2 = this.array[index2 * this.itemSize + 3];
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  setW(index2, w2) {
    if (this.normalized) w2 = normalize$2(w2, this.array);
    this.array[index2 * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index2, x, y2) {
    index2 *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y2 = normalize$2(y2, this.array);
    }
    this.array[index2 + 0] = x;
    this.array[index2 + 1] = y2;
    return this;
  }
  setXYZ(index2, x, y2, z2) {
    index2 *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y2 = normalize$2(y2, this.array);
      z2 = normalize$2(z2, this.array);
    }
    this.array[index2 + 0] = x;
    this.array[index2 + 1] = y2;
    this.array[index2 + 2] = z2;
    return this;
  }
  setXYZW(index2, x, y2, z2, w2) {
    index2 *= this.itemSize;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y2 = normalize$2(y2, this.array);
      z2 = normalize$2(z2, this.array);
      w2 = normalize$2(w2, this.array);
    }
    this.array[index2 + 0] = x;
    this.array[index2 + 1] = y2;
    this.array[index2 + 2] = z2;
    this.array[index2 + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$2 = 0;
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index2) {
    if (Array.isArray(index2)) {
      this.index = new (arrayNeedsUint32(index2) ? Uint32BufferAttribute : Uint16BufferAttribute)(index2, 1);
    } else {
      this.index = index2;
    }
    return this;
  }
  getAttribute(name2) {
    return this.attributes[name2];
  }
  setAttribute(name2, attribute) {
    this.attributes[name2] = attribute;
    return this;
  }
  deleteAttribute(name2) {
    delete this.attributes[name2];
    return this;
  }
  hasAttribute(name2) {
    return this.attributes[name2] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position2 = this.attributes.position;
    if (position2 !== void 0) {
      position2.applyMatrix4(matrix);
      position2.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q2) {
    _m1$2.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateX(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateY(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateZ(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  translate(x, y2, z2) {
    _m1$2.makeTranslation(x, y2, z2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  scale(x, y2, z2) {
    _m1$2.makeScale(x, y2, z2);
    this.applyMatrix4(_m1$2);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position2 = [];
    for (let i = 0, l2 = points.length; i < l2; i++) {
      const point2 = points[i];
      position2.push(point2.x, point2.y, point2.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position2, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position2 !== void 0) {
      this.boundingBox.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i = 0, il2 = morphAttributesPosition.length; i < il2; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position2 = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position2 && position2.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position2) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position2);
      if (morphAttributesPosition) {
        for (let i = 0, il2 = morphAttributesPosition.length; i < il2; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il2 = position2.count; i < il2; i++) {
        _vector$8.fromBufferAttribute(position2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il2 = morphAttributesPosition.length; i < il2; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl2 = morphAttribute.count; j < jl2; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position2, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index2 = this.index;
    const attributes = this.attributes;
    if (index2 === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      tan1[i] = new Vector3();
      tan2[i] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a, b, c) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      uvA.fromBufferAttribute(uvAttribute, a);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: index2.count
      }];
    }
    for (let i = 0, il2 = groups.length; i < il2; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl2 = start + count; j < jl2; j += 3) {
        handleTriangle(
          index2.getX(j + 0),
          index2.getX(j + 1),
          index2.getX(j + 2)
        );
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromBufferAttribute(normalAttribute, v2);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp.copy(t2);
      tmp.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp2.crossVectors(n22, t2);
      const test = tmp2.dot(tan2[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v2, tmp.x, tmp.y, tmp.z, w2);
    }
    for (let i = 0, il2 = groups.length; i < il2; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl2 = start + count; j < jl2; j += 3) {
        handleVertex(index2.getX(j + 0));
        handleVertex(index2.getX(j + 1));
        handleVertex(index2.getX(j + 2));
      }
    }
  }
  computeVertexNormals() {
    const index2 = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il2 = normalAttribute.count; i < il2; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb2 = new Vector3(), ab2 = new Vector3();
      if (index2) {
        for (let i = 0, il2 = index2.count; i < il2; i += 3) {
          const vA = index2.getX(i + 0);
          const vB = index2.getX(i + 1);
          const vC = index2.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb2.subVectors(pC, pB);
          ab2.subVectors(pA, pB);
          cb2.cross(ab2);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb2);
          nB.add(cb2);
          nC.add(cb2);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il2 = positionAttribute.count; i < il2; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb2.subVectors(pC, pB);
          ab2.subVectors(pA, pB);
          cb2.cross(ab2);
          normalAttribute.setXYZ(i + 0, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i + 1, cb2.x, cb2.y, cb2.z);
          normalAttribute.setXYZ(i + 2, cb2.x, cb2.y, cb2.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il2 = normals.count; i < il2; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index2 = 0, index22 = 0;
      for (let i = 0, l2 = indices2.length; i < l2; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index2 = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index2 = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index22++] = array[index2++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name2, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name2 in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name2];
      for (let i = 0, il2 = morphAttribute.length; i < il2; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name2] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l2 = groups.length; i < l2; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index2 = this.index;
    if (index2 !== null) {
      data.data.index = {
        type: index2.array.constructor.name,
        array: Array.prototype.slice.call(index2.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il2 = attributeArray.length; i < il2; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index2 = source.index;
    if (index2 !== null) {
      this.setIndex(index2.clone(data));
    }
    const attributes = source.attributes;
    for (const name2 in attributes) {
      const attribute = attributes[name2];
      this.setAttribute(name2, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name2];
      for (let i = 0, l2 = morphAttribute.length; i < l2; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name2] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l2 = groups.length; i < l2; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3();
const _vA$1 = /* @__PURE__ */ new Vector3();
const _vB$1 = /* @__PURE__ */ new Vector3();
const _vC$1 = /* @__PURE__ */ new Vector3();
const _tempA = /* @__PURE__ */ new Vector3();
const _morphA = /* @__PURE__ */ new Vector3();
const _intersectionPoint = /* @__PURE__ */ new Vector3();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3();
class Mesh extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys2 = Object.keys(morphAttributes);
    if (keys2.length > 0) {
      const morphAttribute = morphAttributes[keys2[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
          const name2 = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name2] = m2;
        }
      }
    }
  }
  getVertexPosition(index2, target) {
    const geometry = this.geometry;
    const position2 = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position2, index2);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il2 = morphPosition.length; i < il2; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index2);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index2 = geometry.index;
    const position2 = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index2 !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il2 = groups.length; i < il2; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl2 = end; j < jl2; j += 3) {
            const a = index2.getX(j);
            const b = index2.getX(j + 1);
            const c = index2.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index2.count, drawRange.start + drawRange.count);
        for (let i = start, il2 = end; i < il2; i += 3) {
          const a = index2.getX(i);
          const b = index2.getX(i + 1);
          const c = index2.getX(i + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position2 !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il2 = groups.length; i < il2; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position2.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl2 = end; j < jl2; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position2.count, drawRange.start + drawRange.count);
        for (let i = start, il2 = end; i < il2; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point2) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray.intersectTriangle(pC, pB, pA, true, point2);
  } else {
    intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point2);
  }
  if (intersect2 === null) return null;
  _intersectionPointWorld.copy(point2);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
    }
    if (normal) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u2] = x * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u2][p2] = null;
        } else {
          dst[u2][p2] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp) {
      merged[p2] = tmp[p2];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u2 = 0; u2 < src.length; u2++) {
    dst.push(src[u2].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  const currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    return renderer.outputColorSpace;
  }
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name2 in this.uniforms) {
      const uniform = this.uniforms[name2];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name2] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name2] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name2] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name2] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name2] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name2] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name2] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name2] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3();
const _minTarget = /* @__PURE__ */ new Vector2();
const _maxTarget = /* @__PURE__ */ new Vector2();
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(distance, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(distance, target) {
    this.getViewBounds(distance, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image2 = { width: size, height: size, depth: 1 };
    const images = [image2, image2, image2, image2, image2, image2];
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color2, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color2, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
const _vector1 = /* @__PURE__ */ new Vector3();
const _vector2 = /* @__PURE__ */ new Vector3();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y2, z2, w2) {
    this.normal.set(x, y2, z2);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point2) {
    this.normal.copy(normal);
    this.constant = -point2.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point2) {
    return this.normal.dot(point2) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point2, target) {
    return target.copy(point2).addScaledVector(this.normal, -this.distanceToPoint(point2));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t2);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$5 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3();
class Frustum {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m2, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me2 = m2.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me22, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSprite(sprite) {
    _sphere$5.center.set(0, 0, 0);
    _sphere$5.radius = 0.7071067811865476;
    _sphere$5.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point2) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point2) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl2) {
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl2.createBuffer();
    gl2.bindBuffer(bufferType, buffer);
    gl2.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl2.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl2.HALF_FLOAT;
      } else {
        type = gl2.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl2.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl2.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl2.INT;
    } else if (array instanceof Int8Array) {
      type = gl2.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl2.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl2.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRanges = attribute.updateRanges;
    gl2.bindBuffer(bufferType, buffer);
    if (updateRanges.length === 0) {
      gl2.bufferSubData(bufferType, 0, array);
    } else {
      updateRanges.sort((a, b) => a.start - b.start);
      let mergeIndex = 0;
      for (let i = 1; i < updateRanges.length; i++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i];
        if (range.start <= previousRange.start + previousRange.count + 1) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      for (let i = 0, l2 = updateRanges.length; i < l2; i++) {
        const range = updateRanges[i];
        gl2.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      attribute.clearUpdateRanges();
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl2.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  }
};
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /* @__PURE__ */ new Euler();
const _m1$1 = /* @__PURE__ */ new Matrix4();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function getBackground(scene) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    let forceClear = false;
    const background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    const background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color2, alpha2) {
    color2.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color2, alpha2 = 1) {
      clearColor.set(color2);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
    addToRenderList
  };
}
function WebGLBindingStates(gl2, attributes) {
  const maxVertexAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index2) {
    let updateBuffers = false;
    const state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index2);
    if (updateBuffers) saveCache(object, geometry, program, index2);
    if (index2 !== null) {
      attributes.update(index2, gl2.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index2 !== null) {
        gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, attributes.get(index2).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl2.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl2.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl2.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index2) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name2];
        let geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute === void 0) {
          if (name2 === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name2 === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index2) return true;
    return false;
  }
  function saveCache(object, geometry, program, index2) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name2];
        if (attribute === void 0) {
          if (name2 === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name2 === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name2] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index2;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il2 = newAttributes.length; i < il2; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl2.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl2.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il2 = enabledAttributes.length; i < il2; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl2.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index2, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl2.vertexAttribIPointer(index2, size, type, stride, offset);
    } else {
      gl2.vertexAttribPointer(index2, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name2 in programAttributes) {
      const programAttribute = programAttributes[name2];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name2];
        if (geometryAttribute === void 0) {
          if (name2 === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name2 === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = type === gl2.INT || type === gl2.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl2.bindBuffer(gl2.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name2];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl2.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl2.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl2.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl2.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl2, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl2.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl2.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension2 = extensions.get("WEBGL_multi_draw");
    extension2.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension2 = extensions.get("WEBGL_multi_draw");
    if (extension2 === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      extension2.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      for (let i = 0; i < primcount.length; i++) {
        info.update(elementCount, mode, primcount[i]);
      }
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl2, extensions, parameters, utils) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension2 = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl2.getParameter(extension2.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl2.getParameter(gl2.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl2.getParameter(gl2.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.HIGH_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl2.getShaderPrecisionFormat(gl2.VERTEX_SHADER, gl2.MEDIUM_FLOAT).precision > 0 && gl2.getShaderPrecisionFormat(gl2.FRAGMENT_SHADER, gl2.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has("EXT_clip_control");
  if (reverseDepthBuffer === true) {
    const ext = extensions.get("EXT_clip_control");
    ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
  }
  const maxTextures = gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl2.getParameter(gl2.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl2.getParameter(gl2.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl2.getParameter(gl2.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl2.getParameter(gl2.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl2.getParameter(gl2.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl2.getParameter(gl2.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const maxSamples = gl2.getParameter(gl2.MAX_SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility
    getMaxAnisotropy,
    getMaxPrecision,
    textureFormatReadable,
    textureTypeReadable,
    precision,
    logarithmicDepthBuffer,
    reverseDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image2 = texture.image;
          if (image2 && image2.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image2.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class OrthographicCamera extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
let _oldXrEnabled = false;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, 1)
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    this._renderer.xr.enabled = _oldXrEnabled;
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n2 = this._lodPlanes.length;
    for (let i = 1; i < n2; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n2 - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y2 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max2 = 1 + texelSize;
    const uv1 = [min, min, max2, min, max2, max2, min, min, max2, max2, min, max2];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position2 = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y2,
        0,
        x + 2 / 3,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2 + 1,
        0
      ];
      position2.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position2, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y2, width, height) {
  target.viewport.set(x, y2, width, height);
  target.scissor.set(x, y2, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        let renderTarget = cubeUVmaps.get(texture);
        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== void 0) {
            return renderTarget.texture;
          } else {
            const image2 = texture.image;
            if (isEquirectMap && image2 && image2.height > 0 || isCubeMap && image2 && isCubeTextureComplete(image2)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image2) {
    let count = 0;
    const length = 6;
    for (let i = 0; i < length; i++) {
      if (image2[i] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl2) {
  const extensions = {};
  function getExtension(name2) {
    if (extensions[name2] !== void 0) {
      return extensions[name2];
    }
    let extension2;
    switch (name2) {
      case "WEBGL_depth_texture":
        extension2 = gl2.getExtension("WEBGL_depth_texture") || gl2.getExtension("MOZ_WEBGL_depth_texture") || gl2.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension2 = gl2.getExtension("EXT_texture_filter_anisotropic") || gl2.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension2 = gl2.getExtension("WEBGL_compressed_texture_s3tc") || gl2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension2 = gl2.getExtension("WEBGL_compressed_texture_pvrtc") || gl2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension2 = gl2.getExtension(name2);
    }
    extensions[name2] = extension2;
    return extension2;
  }
  return {
    has: function(name2) {
      return getExtension(name2) !== null;
    },
    init: function() {
      getExtension("EXT_color_buffer_float");
      getExtension("WEBGL_clip_cull_distance");
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
      getExtension("WEBGL_render_shared_exponent");
    },
    get: function(name2) {
      const extension2 = getExtension(name2);
      if (extension2 === null) {
        warnOnce("THREE.WebGLRenderer: " + name2 + " extension not supported.");
      }
      return extension2;
    }
  };
}
function WebGLGeometries(gl2, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name2 in geometry.attributes) {
      attributes.remove(geometry.attributes[name2]);
    }
    for (const name2 in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name2];
      for (let i = 0, l2 = array.length; i < l2; i++) {
        attributes.remove(array[i]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name2 in geometryAttributes) {
      attributes.update(geometryAttributes[name2], gl2.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name2 in morphAttributes) {
      const array = morphAttributes[name2];
      for (let i = 0, l2 = array.length; i < l2; i++) {
        attributes.update(array[i], gl2.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version2 = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version2 = geometryIndex.version;
      for (let i = 0, l2 = array.length; i < l2; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version2 = geometryPosition.version;
      for (let i = 0, l2 = array.length / 3 - 1; i < l2; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version2;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl2, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl2.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl2.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension2 = extensions.get("WEBGL_multi_draw");
    extension2.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    let elementCount = 0;
    for (let i = 0; i < drawCount; i++) {
      elementCount += counts[i];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension2 = extensions.get("WEBGL_multi_draw");
    if (extension2 === null) {
      for (let i = 0; i < starts.length; i++) {
        renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);
      }
    } else {
      extension2.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      for (let i = 0; i < primcount.length; i++) {
        info.update(elementCount, mode, primcount[i]);
      }
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl2) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl2.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl2.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl2.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl2.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl2.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function WebGLMorphtargets(gl2, capabilities, textures) {
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let entry = morphTextures.get(geometry);
    if (entry === void 0 || entry.count !== morphTargetsCount) {
      let disposeTexture2 = function() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener("dispose", disposeTexture2);
      };
      var disposeTexture = disposeTexture2;
      if (entry !== void 0) entry.texture.dispose();
      const hasMorphPosition = geometry.morphAttributes.position !== void 0;
      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
      const hasMorphColors = geometry.morphAttributes.color !== void 0;
      const morphTargets = geometry.morphAttributes.position || [];
      const morphNormals = geometry.morphAttributes.normal || [];
      const morphColors = geometry.morphAttributes.color || [];
      let vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      let width = geometry.attributes.position.count * vertexDataCount;
      let height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType;
      texture.needsUpdate = true;
      const vertexDataStride = vertexDataCount * 4;
      for (let i = 0; i < morphTargetsCount; i++) {
        const morphTarget = morphTargets[i];
        const morphNormal = morphNormals[i];
        const morphColor = morphColors[i];
        const offset = width * height * 4 * i;
        for (let j = 0; j < morphTarget.count; j++) {
          const stride = j * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture,
        size: new Vector2(width, height)
      };
      morphTextures.set(geometry, entry);
      geometry.addEventListener("dispose", disposeTexture2);
    }
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl2, "morphTexture", object.morphTexture, textures);
    } else {
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl2, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl2, "morphTargetInfluences", objectInfluences);
    }
    program.getUniforms().setValue(gl2, "morphTargetsTexture", entry.texture, textures);
    program.getUniforms().setValue(gl2, "morphTargetsTextureSize", entry.size);
  }
  return {
    update
  };
}
function WebGLObjects(gl2, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl2.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl2.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
class DepthTexture extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
}
const emptyTexture = /* @__PURE__ */ new Texture();
const emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
const empty3dTexture = /* @__PURE__ */ new Data3DTexture();
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, l2 = a.length; i < l2; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l2 = b.length; i < l2; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i = 0; i !== n2; ++i) {
    r2[i] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl2, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl2.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl2.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl2.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl2.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl2.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl2, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl2.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl2.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl2, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl2.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl2.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl2, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl2.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl2.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl2, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl2.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl2.uniform2i(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform2iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3i(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl2.uniform3i(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform3iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4i(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl2.uniform4i(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform4iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV1ui(gl2, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl2.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl2.uniform2ui(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform2uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3ui(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl2.uniform3ui(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform3uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4ui(gl2, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl2.uniform4ui(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl2.uniform4uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueT1(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  let emptyTexture2D;
  if (this.type === gl2.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = LessEqualCompare;
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v2 || emptyTexture2D, unit);
}
function setValueT3D1(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || empty3dTexture, unit);
}
function setValueT6(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl2, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl2.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl2, v2) {
  gl2.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl2, v2) {
  const data = flatten(v2, this.size, 2);
  gl2.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl2, v2) {
  const data = flatten(v2, this.size, 3);
  gl2.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl2, v2) {
  const data = flatten(v2, this.size, 4);
  gl2.uniform4fv(this.addr, data);
}
function setValueM2Array(gl2, v2) {
  const data = flatten(v2, this.size, 4);
  gl2.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl2, v2) {
  const data = flatten(v2, this.size, 9);
  gl2.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl2, v2) {
  const data = flatten(v2, this.size, 16);
  gl2.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl2, v2) {
  gl2.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl2, v2) {
  gl2.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl2, v2) {
  gl2.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl2, v2) {
  gl2.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl2, v2) {
  gl2.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl2, v2) {
  gl2.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl2, v2) {
  gl2.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl2, v2) {
  gl2.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl2, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n2; ++i) {
    textures.setTexture2D(v2[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl2, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n2; ++i) {
    textures.setTexture3D(v2[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl2, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n2; ++i) {
    textures.setTextureCube(v2[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl2, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl2.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n2; ++i) {
    textures.setTexture2DArray(v2[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(id2, activeInfo, addr) {
    this.id = id2;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.setValue = getSingularSetter(activeInfo.type);
  }
}
class PureArrayUniform {
  constructor(id2, activeInfo, addr) {
    this.id = id2;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}
class StructuredUniform {
  constructor(id2) {
    this.id = id2;
    this.seq = [];
    this.map = {};
  }
  setValue(gl2, value, textures) {
    const seq = this.seq;
    for (let i = 0, n2 = seq.length; i !== n2; ++i) {
      const u2 = seq[i];
      u2.setValue(gl2, value[u2.id], textures);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id2 = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id2 = id2 | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id2];
      if (next === void 0) {
        next = new StructuredUniform(id2);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
class WebGLUniforms {
  constructor(gl2, program) {
    this.seq = [];
    this.map = {};
    const n2 = gl2.getProgramParameter(program, gl2.ACTIVE_UNIFORMS);
    for (let i = 0; i < n2; ++i) {
      const info = gl2.getActiveUniform(program, i), addr = gl2.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl2, name2, value, textures) {
    const u2 = this.map[name2];
    if (u2 !== void 0) u2.setValue(gl2, value, textures);
  }
  setOptional(gl2, object, name2) {
    const v2 = object[name2];
    if (v2 !== void 0) this.setValue(gl2, name2, v2);
  }
  static upload(gl2, seq, values, textures) {
    for (let i = 0, n2 = seq.length; i !== n2; ++i) {
      const u2 = seq[i], v2 = values[u2.id];
      if (v2.needsUpdate !== false) {
        u2.setValue(gl2, v2.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r2 = [];
    for (let i = 0, n2 = seq.length; i !== n2; ++i) {
      const u2 = seq[i];
      if (u2.id in values) r2.push(u2);
    }
    return r2;
  }
}
function WebGLShader(gl2, type, string2) {
  const shader = gl2.createShader(type);
  gl2.shaderSource(shader, string2);
  gl2.compileShader(shader);
  return shader;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(string2, errorLine) {
  const lines = string2.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    const line = i + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(colorSpace) {
  const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
  const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
  let gamutMapping;
  if (workingPrimaries === encodingPrimaries) {
    gamutMapping = "";
  } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
    gamutMapping = "LinearDisplayP3ToLinearSRGB";
  } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
    gamutMapping = "LinearSRGBToLinearDisplayP3";
  }
  switch (colorSpace) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [gamutMapping, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [gamutMapping, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return [gamutMapping, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl2, shader, type) {
  const status = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
  const errors = gl2.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl2.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "Cineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case AgXToneMapping:
      toneMappingName = "AgX";
      break;
    case NeutralToneMapping:
      toneMappingName = "Neutral";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
const _v0$1 = /* @__PURE__ */ new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0$1);
  const r2 = _v0$1.x.toFixed(4);
  const g = _v0$1.y.toFixed(4);
  const b = _v0$1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r2}, ${g}, ${b} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name2 in defines) {
    const value = defines[name2];
    if (value === false) continue;
    chunks.push("#define " + name2 + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl2, program) {
  const attributes = {};
  const n2 = gl2.getProgramParameter(program, gl2.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n2; i++) {
    const info = gl2.getActiveAttrib(program, i);
    const name2 = info.name;
    let locationSize = 1;
    if (info.type === gl2.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl2.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl2.FLOAT_MAT4) locationSize = 4;
    attributes[name2] = {
      type: info.type,
      location: gl2.getAttribLocation(program, name2),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string2) {
  return string2 !== "";
}
function replaceLightNums(string2, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string2.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string2, parameters) {
  return string2.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string2) {
  return string2.replace(includePattern, includeReplacer);
}
const shaderChunkMap = /* @__PURE__ */ new Map();
function includeReplacer(match, include) {
  let string2 = ShaderChunk[include];
  if (string2 === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string2 = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string2);
}
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string2) {
  return string2.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string2 = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string2 += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string2;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl2 = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl2.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.dispersion ? "#define USE_DISPERSION" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      getLuminanceFunction(),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      customVertexExtensions,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl2, gl2.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl2, gl2.FRAGMENT_SHADER, fragmentGlsl);
  gl2.attachShader(program, glVertexShader);
  gl2.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl2.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl2.bindAttribLocation(program, 0, "position");
  }
  gl2.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl2.getProgramInfoLog(program).trim();
      const vertexLog = gl2.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl2.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl2.getProgramParameter(program, gl2.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl2, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl2, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl2, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl2.getError() + " - VALIDATE_STATUS " + gl2.getProgramParameter(program, gl2.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl2.deleteShader(glVertexShader);
    gl2.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl2, program);
    cachedAttributes = fetchAttributeLocations(gl2, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl2.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl2.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code2) {
    const cache = this.shaderCache;
    let stage = cache.get(code2);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code2);
      cache.set(code2, stage);
    }
    return stage;
  }
}
class WebGLShaderStage {
  constructor(code2) {
    this.id = _id$1++;
    this.code = code2;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const reverseDepthBuffer = capabilities.reverseDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_DISPERSION = material.dispersion > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      reverseDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name2 in parameters.defines) {
        array.push(name2);
        array.push(parameters.defines[name2]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.supportsVertexTextures)
      _programLayers.enable(0);
    if (parameters.instancing)
      _programLayers.enable(1);
    if (parameters.instancingColor)
      _programLayers.enable(2);
    if (parameters.instancingMorph)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    if (parameters.batching)
      _programLayers.enable(19);
    if (parameters.dispersion)
      _programLayers.enable(20);
    if (parameters.batchingColor)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.reverseDepthBuffer)
      _programLayers.enable(4);
    if (parameters.skinning)
      _programLayers.enable(5);
    if (parameters.morphTargets)
      _programLayers.enable(6);
    if (parameters.morphNormals)
      _programLayers.enable(7);
    if (parameters.morphColors)
      _programLayers.enable(8);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(9);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    if (parameters.alphaToCoverage)
      _programLayers.enable(20);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl2 = programs.length; p2 < pl2; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function has(object) {
    return properties.has(object);
  }
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    has,
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push2(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il2 = renderItems.length; i < il2; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push: push2,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list2;
    if (listArray === void 0) {
      list2 = new WebGLRenderList();
      lists.set(scene, [list2]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list2 = new WebGLRenderList();
        listArray.push(list2);
      } else {
        list2 = listArray[renderCallDepth];
      }
    }
    return list2;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r2 = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (let i = 0, l2 = lights.length; i < l2; i++) {
      const light = lights[i];
      const color2 = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color2.r * intensity;
        g += color2.g * intensity;
        b += color2.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color2).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has("OES_texture_float_linear") === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l2 = lights.length; i < l2; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions) {
  const lights = new WebGLLights(extensions);
  const lightsArray = [];
  const shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    camera: null,
    lights,
    transmissionRenderTarget: {}
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(renderer, objects, capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = renderer.getRenderTarget();
    const activeCubeFace = renderer.getActiveCubeFace();
    const activeMipmapLevel = renderer.getActiveMipmapLevel();
    const _state = renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i = 0, il2 = lights.length; i < il2; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      renderer.setRenderTarget(shadow.map);
      renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k2 = 0, kl2 = groups.length; k2 < kl2; k2++) {
            const group = groups[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id2 in _materialCache) {
      const cache = _materialCache[id2];
      const uuid = event.target.uuid;
      if (uuid in cache) {
        const shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
const reversedFuncs = {
  [NeverDepth]: AlwaysDepth,
  [LessDepth]: GreaterDepth,
  [EqualDepth]: NotEqualDepth,
  [LessEqualDepth]: GreaterEqualDepth,
  [AlwaysDepth]: NeverDepth,
  [GreaterDepth]: LessDepth,
  [NotEqualDepth]: EqualDepth,
  [GreaterEqualDepth]: LessEqualDepth
};
function WebGLState(gl2) {
  function ColorBuffer() {
    let locked = false;
    const color2 = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl2.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a;
          g *= a;
          b *= a;
        }
        color2.set(r2, g, b, a);
        if (currentColorClear.equals(color2) === false) {
          gl2.clearColor(r2, g, b, a);
          currentColorClear.copy(color2);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let reversed = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setReversed: function(value) {
        reversed = value;
      },
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl2.DEPTH_TEST);
        } else {
          disable2(gl2.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl2.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (reversed) depthFunc = reversedFuncs[depthFunc];
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl2.depthFunc(gl2.NEVER);
              break;
            case AlwaysDepth:
              gl2.depthFunc(gl2.ALWAYS);
              break;
            case LessDepth:
              gl2.depthFunc(gl2.LESS);
              break;
            case LessEqualDepth:
              gl2.depthFunc(gl2.LEQUAL);
              break;
            case EqualDepth:
              gl2.depthFunc(gl2.EQUAL);
              break;
            case GreaterEqualDepth:
              gl2.depthFunc(gl2.GEQUAL);
              break;
            case GreaterDepth:
              gl2.depthFunc(gl2.GREATER);
              break;
            case NotEqualDepth:
              gl2.depthFunc(gl2.NOTEQUAL);
              break;
            default:
              gl2.depthFunc(gl2.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl2.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl2.STENCIL_TEST);
          } else {
            disable2(gl2.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl2.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl2.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl2.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl2.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl2.getParameter(gl2.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version2 = 0;
  const glVersion = gl2.getParameter(gl2.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version2 >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl2.getParameter(gl2.SCISSOR_BOX);
  const viewportParam = gl2.getParameter(gl2.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl2.createTexture();
    gl2.bindTexture(type, texture);
    gl2.texParameteri(type, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
    gl2.texParameteri(type, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
    for (let i = 0; i < count; i++) {
      if (type === gl2.TEXTURE_3D || type === gl2.TEXTURE_2D_ARRAY) {
        gl2.texImage3D(target, 0, gl2.RGBA, 1, 1, dimensions, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
      } else {
        gl2.texImage2D(target + i, 0, gl2.RGBA, 1, 1, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl2.TEXTURE_2D] = createTexture(gl2.TEXTURE_2D, gl2.TEXTURE_2D, 1);
  emptyTextures[gl2.TEXTURE_CUBE_MAP] = createTexture(gl2.TEXTURE_CUBE_MAP, gl2.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl2.TEXTURE_2D_ARRAY] = createTexture(gl2.TEXTURE_2D_ARRAY, gl2.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl2.TEXTURE_3D] = createTexture(gl2.TEXTURE_3D, gl2.TEXTURE_3D, 1, 1);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl2.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl2.CULL_FACE);
  setBlending(NoBlending);
  function enable(id2) {
    if (enabledCapabilities[id2] !== true) {
      gl2.enable(id2);
      enabledCapabilities[id2] = true;
    }
  }
  function disable2(id2) {
    if (enabledCapabilities[id2] !== false) {
      gl2.disable(id2);
      enabledCapabilities[id2] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl2.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl2.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl2.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl2.FRAMEBUFFER) {
        currentBoundFramebuffers[gl2.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl2.COLOR_ATTACHMENT0) {
        for (let i = 0, il2 = textures.length; i < il2; i++) {
          drawBuffers2[i] = gl2.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl2.BACK) {
        drawBuffers2[0] = gl2.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl2.drawBuffers(drawBuffers2);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl2.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl2.FUNC_ADD,
    [SubtractEquation]: gl2.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl2.FUNC_REVERSE_SUBTRACT
  };
  equationToGL[MinEquation] = gl2.MIN;
  equationToGL[MaxEquation] = gl2.MAX;
  const factorToGL = {
    [ZeroFactor]: gl2.ZERO,
    [OneFactor]: gl2.ONE,
    [SrcColorFactor]: gl2.SRC_COLOR,
    [SrcAlphaFactor]: gl2.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl2.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl2.DST_COLOR,
    [DstAlphaFactor]: gl2.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl2.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl2.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl2.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl2.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl2.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl2.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl2.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl2.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable2(gl2.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl2.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl2.blendEquation(gl2.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl2.blendFunc(gl2.ONE, gl2.ONE);
              break;
            case SubtractiveBlending:
              gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
              break;
            case MultiplyBlending:
              gl2.blendFuncSeparate(gl2.ZERO, gl2.SRC_COLOR, gl2.ZERO, gl2.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl2.blendFuncSeparate(gl2.SRC_ALPHA, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl2.blendFunc(gl2.SRC_ALPHA, gl2.ONE);
              break;
            case SubtractiveBlending:
              gl2.blendFuncSeparate(gl2.ZERO, gl2.ONE_MINUS_SRC_COLOR, gl2.ZERO, gl2.ONE);
              break;
            case MultiplyBlending:
              gl2.blendFunc(gl2.ZERO, gl2.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl2.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl2.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl2.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable2(gl2.CULL_FACE) : enable(gl2.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl2.SAMPLE_ALPHA_TO_COVERAGE) : disable2(gl2.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl2.frontFace(gl2.CW);
      } else {
        gl2.frontFace(gl2.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl2.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl2.cullFace(gl2.BACK);
        } else if (cullFace === CullFaceFront) {
          gl2.cullFace(gl2.FRONT);
        } else {
          gl2.cullFace(gl2.FRONT_AND_BACK);
        }
      }
    } else {
      disable2(gl2.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl2.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl2.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl2.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable2(gl2.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl2.SCISSOR_TEST);
    } else {
      disable2(gl2.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl2.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl2.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl2.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl2.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl2.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl2.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl2.compressedTexImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl2.compressedTexImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl2.texSubImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl2.texSubImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl2.compressedTexSubImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl2.compressedTexSubImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl2.texStorage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl2.texStorage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl2.texImage2D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl2.texImage3D.apply(gl2, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl2.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl2.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl2.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl2.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl2.disable(gl2.BLEND);
    gl2.disable(gl2.CULL_FACE);
    gl2.disable(gl2.DEPTH_TEST);
    gl2.disable(gl2.POLYGON_OFFSET_FILL);
    gl2.disable(gl2.SCISSOR_TEST);
    gl2.disable(gl2.STENCIL_TEST);
    gl2.disable(gl2.SAMPLE_ALPHA_TO_COVERAGE);
    gl2.blendEquation(gl2.FUNC_ADD);
    gl2.blendFunc(gl2.ONE, gl2.ZERO);
    gl2.blendFuncSeparate(gl2.ONE, gl2.ZERO, gl2.ONE, gl2.ZERO);
    gl2.blendColor(0, 0, 0, 0);
    gl2.colorMask(true, true, true, true);
    gl2.clearColor(0, 0, 0, 0);
    gl2.depthMask(true);
    gl2.depthFunc(gl2.LESS);
    gl2.clearDepth(1);
    gl2.stencilMask(4294967295);
    gl2.stencilFunc(gl2.ALWAYS, 0, 4294967295);
    gl2.stencilOp(gl2.KEEP, gl2.KEEP, gl2.KEEP);
    gl2.clearStencil(0);
    gl2.cullFace(gl2.BACK);
    gl2.frontFace(gl2.CCW);
    gl2.polygonOffset(0, 0);
    gl2.activeTexture(gl2.TEXTURE0);
    gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
    gl2.bindFramebuffer(gl2.DRAW_FRAMEBUFFER, null);
    gl2.bindFramebuffer(gl2.READ_FRAMEBUFFER, null);
    gl2.useProgram(null);
    gl2.lineWidth(1);
    gl2.scissor(0, 0, gl2.canvas.width, gl2.canvas.height);
    gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    currentViewport.set(0, 0, gl2.canvas.width, gl2.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable: disable2,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function getByteLength(width, height, format, type) {
  const typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    case AlphaFormat:
      return width * height;
    case LuminanceFormat:
      return width * height;
    case LuminanceAlphaFormat:
      return width * height * 2;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${format} format.`
  );
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${type}.`);
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err2) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image2, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image2);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1) {
      if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image2 instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image2 instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image2 instanceof VideoFrame) {
        const width = Math.floor(scale * dimensions.width);
        const height = Math.floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image2, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image2) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
        }
        return image2;
      }
    }
    return image2;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
      if (glType === _gl.INT) internalFormat = _gl.RGB32I;
    }
    if (glFormat === _gl.RGBA_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    let glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image2) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image2.width, image2.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image2.mipmaps.length;
    } else {
      return 1;
    }
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i = 0, il2 = textures.length; i < il2; i++) {
      const attachmentProperties = properties.get(textures[i]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image2 = texture.image;
      if (image2 === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image2.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        const extension2 = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(textureType, extension2.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      let image2 = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image2 = verifyColorSpace(texture, image2);
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image2);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image2.width, image2.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il2 = mipmaps.length; i < il2; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image2.width, image2.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image2.width, image2.height, glFormat, glType, image2.data);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image2.width, image2.height, 0, glFormat, glType, image2.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image2.depth);
          }
          for (let i = 0, il2 = mipmaps.length; i < il2; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      for (const layerIndex of texture.layerUpdates) {
                        const layerData = mipmap.data.subarray(
                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                        );
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData, 0, 0);
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image2.depth, glFormat, mipmap.data, 0, 0);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image2.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image2.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image2.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il2 = mipmaps.length; i < il2; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image2.width, image2.height, image2.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              const layerByteLength = getByteLength(image2.width, image2.height, texture.format, texture.type);
              for (const layerIndex of texture.layerUpdates) {
                const layerData = image2.data.subarray(
                  layerIndex * layerByteLength / image2.data.BYTES_PER_ELEMENT,
                  (layerIndex + 1) * layerByteLength / image2.data.BYTES_PER_ELEMENT
                );
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image2.width, image2.height, 1, glFormat, glType, layerData);
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image2.width, image2.height, image2.depth, glFormat, glType, image2.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image2.width, image2.height, image2.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image2.width, image2.height, image2.depth, glFormat, glType, image2.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image2.width, image2.height, image2.depth, 0, glFormat, glType, image2.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image2.width, image2.height);
          } else {
            let width = image2.width, height = image2.height;
            for (let i = 0; i < levels; i++) {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i = 0, il2 = mipmaps.length; i < il2; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image2);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image2);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image2);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      const image2 = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image2);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image2.width, image2.height);
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      const depthTexture = renderTarget.depthTexture;
      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const samples = getRenderTargetSamples(renderTarget);
      const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
      if (isUseMultisampledRTT) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (isMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
      const depthTexture = renderTarget.depthTexture;
      if (renderTargetProperties.__depthDisposeCallback) {
        renderTargetProperties.__depthDisposeCallback();
      }
      if (depthTexture) {
        const disposeEvent = () => {
          delete renderTargetProperties.__boundDepthTexture;
          delete renderTargetProperties.__depthDisposeCallback;
          depthTexture.removeEventListener("dispose", disposeEvent);
        };
        depthTexture.addEventListener("dispose", disposeEvent);
        renderTargetProperties.__depthDisposeCallback = disposeEvent;
      }
      renderTargetProperties.__boundDepthTexture = depthTexture;
    }
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer === void 0) {
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        } else {
          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderbuffer = renderTargetProperties.__webglDepthbuffer;
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
        }
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (let i = 0, il2 = textures.length; i < il2; i++) {
          const attachmentProperties = properties.get(textures[i]);
          if (attachmentProperties.__webglTexture === void 0) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (let i = 0; i < 6; i++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i = 0, il2 = textures.length; i < il2; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const textures = renderTarget.textures;
    for (let i = 0, il2 = textures.length; i < il2; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  const invalidationArrayRead = [];
  const invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.textures;
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = textures.length > 1;
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i = 0; i < textures.length; i++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
            const webglTexture = properties.get(textures[i]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image2) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image2;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (format !== RGBAFormat || type !== UnsignedByteType) {
          console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image2;
  }
  function getDimensions(image2) {
    if (typeof HTMLImageElement !== "undefined" && image2 instanceof HTMLImageElement) {
      _imageDimensions.width = image2.naturalWidth || image2.width;
      _imageDimensions.height = image2.naturalHeight || image2.height;
    } else if (typeof VideoFrame !== "undefined" && image2 instanceof VideoFrame) {
      _imageDimensions.width = image2.displayWidth;
      _imageDimensions.height = image2.displayHeight;
    } else {
      _imageDimensions.width = image2.width;
      _imageDimensions.height = image2.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl2, extensions) {
  function convert2(p2, colorSpace = NoColorSpace) {
    let extension2;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p2 === UnsignedByteType) return gl2.UNSIGNED_BYTE;
    if (p2 === UnsignedShort4444Type) return gl2.UNSIGNED_SHORT_4_4_4_4;
    if (p2 === UnsignedShort5551Type) return gl2.UNSIGNED_SHORT_5_5_5_1;
    if (p2 === UnsignedInt5999Type) return gl2.UNSIGNED_INT_5_9_9_9_REV;
    if (p2 === ByteType) return gl2.BYTE;
    if (p2 === ShortType) return gl2.SHORT;
    if (p2 === UnsignedShortType) return gl2.UNSIGNED_SHORT;
    if (p2 === IntType) return gl2.INT;
    if (p2 === UnsignedIntType) return gl2.UNSIGNED_INT;
    if (p2 === FloatType) return gl2.FLOAT;
    if (p2 === HalfFloatType) return gl2.HALF_FLOAT;
    if (p2 === AlphaFormat) return gl2.ALPHA;
    if (p2 === RGBFormat) return gl2.RGB;
    if (p2 === RGBAFormat) return gl2.RGBA;
    if (p2 === LuminanceFormat) return gl2.LUMINANCE;
    if (p2 === LuminanceAlphaFormat) return gl2.LUMINANCE_ALPHA;
    if (p2 === DepthFormat) return gl2.DEPTH_COMPONENT;
    if (p2 === DepthStencilFormat) return gl2.DEPTH_STENCIL;
    if (p2 === RedFormat) return gl2.RED;
    if (p2 === RedIntegerFormat) return gl2.RED_INTEGER;
    if (p2 === RGFormat) return gl2.RG;
    if (p2 === RGIntegerFormat) return gl2.RG_INTEGER;
    if (p2 === RGBAIntegerFormat) return gl2.RGBA_INTEGER;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension2 = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension2 !== null) {
          if (p2 === RGB_S3TC_DXT1_Format) return extension2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format) return extension2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format) return extension2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format) return extension2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension2 = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension2 !== null) {
          if (p2 === RGB_S3TC_DXT1_Format) return extension2.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format) return extension2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format) return extension2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format) return extension2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension2 = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension2 !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format) return extension2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format) return extension2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format) return extension2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format) return extension2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension2 = extensions.get("WEBGL_compressed_texture_etc");
      if (extension2 !== null) {
        if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ETC2 : extension2.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension2.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
      extension2 = extensions.get("WEBGL_compressed_texture_astc");
      if (extension2 !== null) {
        if (p2 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension2.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p2 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension2.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p2 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension2.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p2 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension2.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p2 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension2.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p2 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension2.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p2 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension2.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p2 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension2.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p2 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension2.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p2 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension2.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p2 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension2.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p2 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension2.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p2 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension2.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p2 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension2.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format || p2 === RGB_BPTC_SIGNED_Format || p2 === RGB_BPTC_UNSIGNED_Format) {
      extension2 = extensions.get("EXT_texture_compression_bptc");
      if (extension2 !== null) {
        if (p2 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p2 === RGB_BPTC_SIGNED_Format) return extension2.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p2 === RGB_BPTC_UNSIGNED_Format) return extension2.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RED_RGTC1_Format || p2 === SIGNED_RED_RGTC1_Format || p2 === RED_GREEN_RGTC2_Format || p2 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension2 = extensions.get("EXT_texture_compression_rgtc");
      if (extension2 !== null) {
        if (p2 === RGBA_BPTC_Format) return extension2.COMPRESSED_RED_RGTC1_EXT;
        if (p2 === SIGNED_RED_RGTC1_Format) return extension2.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p2 === RED_GREEN_RGTC2_Format) return extension2.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p2 === SIGNED_RED_GREEN_RGTC2_Format) return extension2.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) return gl2.UNSIGNED_INT_24_8;
    return gl2[p2] !== void 0 ? gl2[p2] : null;
  }
  return { convert: convert2 };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}
class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  init(renderer, depthData, renderState) {
    if (this.texture === null) {
      const texture = new Texture();
      const texProps = renderer.properties.get(texture);
      texProps.__webglTexture = depthData.texture;
      if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {
        this.depthNear = depthData.depthNear;
        this.depthFar = depthData.depthFar;
      }
      this.texture = texture;
    }
  }
  getMesh(cameraXR) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const viewport = cameraXR.cameras[0].viewport;
        const material = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: viewport.z },
            depthHeight: { value: viewport.w }
          }
        });
        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
      }
    }
    return this.mesh;
  }
  reset() {
    this.texture = null;
    this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl2) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const depthSensing = new WebXRDepthSensing();
    const attributes = gl2.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const currentSize = new Vector2();
    let currentPixelRatio = null;
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index2) {
      let controller = controllers[index2];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index2] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        if (inputSource === null) continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space2) {
      customReferenceSpace = space2;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl2.makeXRCompatible();
        }
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        if (session.renderState.layers === void 0) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl2, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          renderer.setPixelRatio(1);
          renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl2.DEPTH24_STENCIL8 : gl2.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl2.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl2);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          renderer.setPixelRatio(1);
          renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0,
              resolveDepthBuffer: glProjLayer.ignoreDepthValues === false
            }
          );
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    this.getDepthTexture = function() {
      return depthSensing.getDepthTexture();
    };
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const index2 = controllerInputSources.indexOf(inputSource);
        if (index2 >= 0) {
          controllerInputSources[index2] = null;
          controllers[index2].disconnect(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i2;
              break;
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource;
              controllerIndex = i2;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      if (projL[10] === -1) {
        camera.projectionMatrix.copy(cameraL2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
      } else {
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      }
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null) return;
      let depthNear = camera.near;
      let depthFar = camera.far;
      if (depthSensing.texture !== null) {
        if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
        if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = depthNear;
      cameraXR.far = cameraR.far = cameraL.far = depthFar;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    this.hasDepthSensing = function() {
      return depthSensing.texture !== null;
    };
    this.getDepthSensingMesh = function() {
      return depthSensing.getMesh(cameraXR);
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector4();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
        const enabledFeatures = session.enabledFeatures;
        if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
          const depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(renderer, depthData, session.renderState);
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        const controller = controllers[i];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
}
const _e1 = /* @__PURE__ */ new Euler();
const _m1 = /* @__PURE__ */ new Matrix4();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl2, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = gl2.getParameter(gl2.MAX_UNIFORM_BUFFER_BINDINGS);
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl2.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, buffer);
    gl2.bufferData(gl2.UNIFORM_BUFFER, size, usage);
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, null);
    gl2.bindBufferBase(gl2.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, buffer);
    for (let i = 0, il2 = uniforms.length; i < il2; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl2 = uniformArray.length; j < jl2; j++) {
        const uniform = uniformArray[j];
        if (hasUniformChanged(uniform, i, j, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let k2 = 0; k2 < values.length; k2++) {
            const value = values[k2];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform.__data[0] = value;
              gl2.bufferSubData(gl2.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl2.bufferSubData(gl2.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl2.bindBuffer(gl2.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index2, indexArray, cache) {
    const value = uniform.value;
    const indexString = index2 + "_" + indexArray;
    if (cache[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i = 0, l2 = uniforms.length; i < l2; i++) {
      const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
      for (let j = 0, jl2 = uniformArray.length; j < jl2; j++) {
        const uniform = uniformArray[j];
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let k2 = 0, kl2 = values.length; k2 < kl2; k2++) {
          const value = values[k2];
          const info2 = getUniformSize(value);
          const chunkOffset2 = offset % chunkSize;
          const chunkPadding = chunkOffset2 % info2.boundary;
          const chunkStart = chunkOffset2 + chunkPadding;
          offset += chunkPadding;
          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
            offset += chunkSize - chunkStart;
          }
          uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index2 = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index2, 1);
    gl2.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id2 in buffers) {
      gl2.deleteBuffer(buffers[id2]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = false,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      if (typeof WebGLRenderingContext !== "undefined" && context instanceof WebGLRenderingContext) {
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      }
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _currentProjectionMatrix = new Matrix4();
    const _projScreenMatrix2 = new Matrix4();
    const _vector32 = new Vector3();
    const _vector4 = new Vector4();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    let _renderBackground = false;
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext(contextName, contextAttributes) {
      return canvas.getContext(contextName, contextAttributes);
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextName = "webgl2";
        _gl = getContext(contextName, contextAttributes);
        if (_gl === null) {
          if (getContext(contextName)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      extensions.init();
      utils = new WebGLUtils(_gl, extensions);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
      state = new WebGLState(_gl);
      if (capabilities.reverseDepthBuffer) state.buffers.depth.setReversed(true);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl);
      bindingStates = new WebGLBindingStates(_gl, attributes);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension2 = extensions.get("WEBGL_lose_context");
      if (extension2) extension2.loseContext();
    };
    this.forceContextRestore = function() {
      const extension2 = extensions.get("WEBGL_lose_context");
      if (extension2) extension2.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y2, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y2, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y2, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y2, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean2) {
      state.setScissorTest(_scissorTest = boolean2);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color2 = true, depth2 = true, stencil2 = true) {
      let bits2 = 0;
      if (color2) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r2 = clearColor.r;
          const g = clearColor.g;
          const b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r2;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r2;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits2 |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) {
        bits2 |= _gl.DEPTH_BUFFER_BIT;
        _gl.clearDepth(this.capabilities.reverseDepthBuffer ? 0 : 1);
      }
      if (stencil2) {
        bits2 |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits2);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index2 = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index2 = geometries.getWireframeAttribute(geometry);
        if (index2 === void 0) return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position2 = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index2 !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index2.count);
      } else if (position2 !== void 0 && position2 !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position2.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index2);
      let attribute;
      let renderer = bufferRenderer;
      if (index2 !== null) {
        attribute = attributes.get(index2);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else {
          if (!extensions.get("WEBGL_multi_draw")) {
            const starts = object._multiDrawStarts;
            const counts = object._multiDrawCounts;
            const drawCount2 = object._multiDrawCount;
            const bytesPerElement = index2 ? attributes.get(index2).bytesPerElement : 1;
            const uniforms = properties.get(material).currentProgram.getUniforms();
            for (let i = 0; i < drawCount2; i++) {
              uniforms.setValue(_gl, "_gl_DrawID", i);
              renderer.render(starts[i] / bytesPerElement, counts[i]);
            }
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        }
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights();
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
          return;
        }
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true) return;
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      if (xr.enabled === true && xr.isPresenting === true) {
        const depthSensingMesh = _this.xr.getDepthSensingMesh();
        if (depthSensingMesh !== null) {
          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
        }
      }
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;
      if (_renderBackground) {
        background.addToRenderList(currentRenderList, scene);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      const opaqueObjects = currentRenderList.opaque;
      const transmissiveObjects = currentRenderList.transmissive;
      currentRenderState.setupLights();
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        if (transmissiveObjects.length > 0) {
          for (let i = 0, l2 = cameras.length; i < l2; i++) {
            const camera2 = cameras[i];
            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
          }
        }
        if (_renderBackground) background.render(scene);
        for (let i = 0, l2 = cameras.length; i < l2; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
        if (_renderBackground) background.render(scene);
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector4.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _vector4.copy(geometry.boundingSphere.center);
              }
              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l2 = groups.length; i < l2; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l2 = children.length; i < l2; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: 4,
          stencilBuffer: stencil,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ColorManagement.workingColorSpace
        });
      }
      const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
      const activeViewport = camera.viewport || _currentViewport;
      transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      if (_renderBackground) background.render(scene);
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      const currentCameraViewport = camera.viewport;
      if (camera.viewport !== void 0) camera.viewport = void 0;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(transmissionRenderTarget);
      textures.updateRenderTargetMipmap(transmissionRenderTarget);
      if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
        let renderTargetNeedsUpdate = false;
        for (let i = 0, l2 = transmissiveObjects.length; i < l2; i++) {
          const renderItem = transmissiveObjects[i];
          const object = renderItem.object;
          const geometry = renderItem.geometry;
          const material = renderItem.material;
          const group = renderItem.group;
          if (material.side === DoubleSide && object.layers.test(camera.layers)) {
            const currentSide = material.side;
            material.side = BackSide;
            material.needsUpdate = true;
            renderObject(object, scene, camera, geometry, material, group);
            material.side = currentSide;
            material.needsUpdate = true;
            renderTargetNeedsUpdate = true;
          }
        }
        if (renderTargetNeedsUpdate === true) {
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
        }
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l2 = renderList.length; i < l2; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.batching = parameters2.batching;
      materialProperties.batchingColor = parameters2.batchingColor;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.instancingMorph = parameters2.instancingMorph;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batching === false) {
          needsProgramChange = true;
        } else if (!object.isBatchedMesh && materialProperties.batching === true) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        if (capabilities.reverseDepthBuffer) {
          _currentProjectionMatrix.copy(camera.projectionMatrix);
          toNormalizedProjectionMatrix(_currentProjectionMatrix);
          toReversedProjectionMatrix(_currentProjectionMatrix);
          p_uniforms.setValue(_gl, "projectionMatrix", _currentProjectionMatrix);
        } else {
          p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        }
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, "batchingTexture");
        p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingIdTexture");
        p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingColorTexture");
        if (object._colorsTexture !== null) {
          p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
        m_uniforms.envMapIntensity.value = scene.environmentIntensity;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l2 = groups.length; i < l2; i++) {
          const group = groups[i];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        } else if (renderTarget.depthBuffer) {
          const depthTexture = renderTarget.depthTexture;
          if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
            if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            }
            textures.setupDepthRenderbuffer(renderTarget);
          }
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.readRenderTargetPixelsAsync = async function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (!capabilities.textureFormatReadable(textureFormat)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        }
        if (!capabilities.textureTypeReadable(textureType)) {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        }
        if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          const glBuffer = _gl.createBuffer();
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
          _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
          const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
          const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          _gl.flush();
          await probeAsync(_gl, sync, 4);
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
          _gl.deleteBuffer(glBuffer);
          _gl.deleteSync(sync);
          return buffer;
        } else {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
        }
      }
    };
    this.copyFramebufferToTexture = function(texture, position2 = null, level = 0) {
      if (texture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyFramebufferToTexture function signature has changed.");
        position2 = arguments[0] || null;
        texture = arguments[1];
      }
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const x = position2 !== null ? position2.x : 0;
      const y2 = position2 !== null ? position2.y : 0;
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y2, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed.");
        dstPosition = arguments[0] || null;
        srcTexture = arguments[1];
        dstTexture = arguments[2];
        level = arguments[3] || 0;
        srcRegion = null;
      }
      let width, height, minX, minY;
      let dstX, dstY;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
      } else {
        width = srcTexture.image.width;
        height = srcTexture.image.height;
        minX = 0;
        minY = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
      } else {
        dstX = 0;
        dstY = 0;
      }
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      const image2 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image2.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image2.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image2.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image2.width, image2.height, glFormat, image2.data);
        } else {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image2);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
      if (srcTexture.isTexture !== true) {
        warnOnce("WebGLRenderer: copyTextureToTexture3D function signature has changed.");
        srcRegion = arguments[0] || null;
        dstPosition = arguments[1] || null;
        srcTexture = arguments[2];
        dstTexture = arguments[3];
        level = arguments[4] || 0;
      }
      let width, height, depth2, minX, minY, minZ;
      let dstX, dstY, dstZ;
      const image2 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        depth2 = srcRegion.max.z - srcRegion.min.z;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
        minZ = srcRegion.min.z;
      } else {
        width = image2.width;
        height = image2.height;
        depth2 = image2.depth;
        minX = 0;
        minY = 0;
        minZ = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
        dstZ = dstPosition.z;
      } else {
        dstX = 0;
        dstY = 0;
        dstZ = 0;
      }
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image2.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image2.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image2.data);
      } else {
        if (dstTexture.isCompressedArrayTexture) {
          _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, image2.data);
        } else {
          _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image2);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initRenderTarget = function(target) {
      if (properties.get(target).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(target);
      }
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl2 = this.getContext();
    gl2.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
    gl2.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
}
class InterleavedBuffer {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l2 = this.stride; i < l2; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib2 = new this.constructor(array, this.stride);
    ib2.setUsage(this.usage);
    return ib2;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const _vector$6 = /* @__PURE__ */ new Vector3();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m2) {
    for (let i = 0, l2 = this.data.count; i < l2; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyMatrix4(m2);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyNormalMatrix(m2);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i = 0, l2 = this.count; i < l2; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.transformDirection(m2);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  getComponent(index2, component) {
    let value = this.array[index2 * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index2, component, value) {
    if (this.normalized) value = normalize$2(value, this.array);
    this.data.array[index2 * this.data.stride + this.offset + component] = value;
    return this;
  }
  setX(index2, x) {
    if (this.normalized) x = normalize$2(x, this.array);
    this.data.array[index2 * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index2, y2) {
    if (this.normalized) y2 = normalize$2(y2, this.array);
    this.data.array[index2 * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index2, z2) {
    if (this.normalized) z2 = normalize$2(z2, this.array);
    this.data.array[index2 * this.data.stride + this.offset + 2] = z2;
    return this;
  }
  setW(index2, w2) {
    if (this.normalized) w2 = normalize$2(w2, this.array);
    this.data.array[index2 * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  getX(index2) {
    let x = this.data.array[index2 * this.data.stride + this.offset];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  getY(index2) {
    let y2 = this.data.array[index2 * this.data.stride + this.offset + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  getZ(index2) {
    let z2 = this.data.array[index2 * this.data.stride + this.offset + 2];
    if (this.normalized) z2 = denormalize(z2, this.array);
    return z2;
  }
  getW(index2) {
    let w2 = this.data.array[index2 * this.data.stride + this.offset + 3];
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  setXY(index2, x, y2) {
    index2 = index2 * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y2 = normalize$2(y2, this.array);
    }
    this.data.array[index2 + 0] = x;
    this.data.array[index2 + 1] = y2;
    return this;
  }
  setXYZ(index2, x, y2, z2) {
    index2 = index2 * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y2 = normalize$2(y2, this.array);
      z2 = normalize$2(z2, this.array);
    }
    this.data.array[index2 + 0] = x;
    this.data.array[index2 + 1] = y2;
    this.data.array[index2 + 2] = z2;
    return this;
  }
  setXYZW(index2, x, y2, z2, w2) {
    index2 = index2 * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize$2(x, this.array);
      y2 = normalize$2(y2, this.array);
      z2 = normalize$2(z2, this.array);
      w2 = normalize$2(w2, this.array);
    }
    this.data.array[index2 + 0] = x;
    this.data.array[index2 + 1] = y2;
    this.data.array[index2 + 2] = z2;
    this.data.array[index2 + 3] = w2;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index2 = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index2 + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index2 = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index2 + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
}
const _basePosition = /* @__PURE__ */ new Vector3();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector3 = /* @__PURE__ */ new Vector3();
const _matrix4 = /* @__PURE__ */ new Matrix4();
const _vertex = /* @__PURE__ */ new Vector3();
const _sphere$4 = /* @__PURE__ */ new Sphere();
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects2) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$4.copy(this.boundingSphere);
    _sphere$4.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$2);
  }
  getVertexPosition(index2, target) {
    super.getVertexPosition(index2, target);
    this.applyBoneTransform(index2, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l2 = skinWeight.count; i < l2; i++) {
      vector.fromBufferAttribute(skinWeight, i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  applyBoneTransform(index2, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index2);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index2);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bone extends Object3D {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
}
class DataTexture extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix$1 = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i = 0, il2 = this.bones.length; i < il2; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il2 = this.bones.length; i < il2; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il2 = this.bones.length; i < il2; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il2 = this.bones.length; i < il2; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il2 = bones.length; i < il2; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    return this;
  }
  getBoneByName(name2) {
    for (let i = 0, il2 = this.bones.length; i < il2; i++) {
      const bone = this.bones[i];
      if (bone.name === name2) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l2 = json.bones.length; i < l2; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l2 = bones.length; i < l2; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _box3 = /* @__PURE__ */ new Box3();
const _identity = /* @__PURE__ */ new Matrix4();
const _mesh$1 = /* @__PURE__ */ new Mesh();
const _sphere$3 = /* @__PURE__ */ new Sphere();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.morphTexture = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i = 0; i < count; i++) {
      this.setMatrixAt(i, _identity);
    }
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$3);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  getColorAt(index2, color2) {
    color2.fromArray(this.instanceColor.array, index2 * 3);
  }
  getMatrixAt(index2, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index2 * 16);
  }
  getMorphAt(index2, object) {
    const objectInfluences = object.morphTargetInfluences;
    const array = this.morphTexture.source.data.data;
    const len = objectInfluences.length + 1;
    const dataIndex = index2 * len + 1;
    for (let i = 0; i < objectInfluences.length; i++) {
      objectInfluences[i] = array[dataIndex + i];
    }
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh$1.geometry = this.geometry;
    _mesh$1.material = this.material;
    if (_mesh$1.material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$3.copy(this.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh$1.matrixWorld = _instanceWorldMatrix;
      _mesh$1.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l2 = _instanceIntersects.length; i < l2; i++) {
        const intersect2 = _instanceIntersects[i];
        intersect2.instanceId = instanceId;
        intersect2.object = this;
        intersects2.push(intersect2);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index2, color2) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
    }
    color2.toArray(this.instanceColor.array, index2 * 3);
  }
  setMatrixAt(index2, matrix) {
    matrix.toArray(this.instanceMatrix.array, index2 * 16);
  }
  setMorphAt(index2, object) {
    const objectInfluences = object.morphTargetInfluences;
    const len = objectInfluences.length + 1;
    if (this.morphTexture === null) {
      this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
    }
    const array = this.morphTexture.source.data.data;
    let morphInfluencesSum = 0;
    for (let i = 0; i < objectInfluences.length; i++) {
      morphInfluencesSum += objectInfluences[i];
    }
    const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    const dataIndex = len * index2;
    array[dataIndex] = morphBaseInfluence;
    array.set(objectInfluences, dataIndex + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    if (this.morphTexture !== null) {
      this.morphTexture.dispose();
      this.morphTexture = null;
    }
    return this;
  }
}
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _vStart = /* @__PURE__ */ new Vector3();
const _vEnd = /* @__PURE__ */ new Vector3();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
const _intersectPointOnRay = /* @__PURE__ */ new Vector3();
const _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
class Line extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i = 1, l2 = positionAttribute.count; i < l2; i++) {
        _vStart.fromBufferAttribute(positionAttribute, i - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i);
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step = this.isLineSegments ? 2 : 1;
    const index2 = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index2 !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index2.count, drawRange.start + drawRange.count);
      for (let i = start, l2 = end - 1; i < l2; i += step) {
        const a = index2.getX(i);
        const b = index2.getX(i + 1);
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const a = index2.getX(end - 1);
        const b = index2.getX(start);
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l2 = end - 1; i < l2; i += step) {
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
      if (this.isLineLoop) {
        const intersect2 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
        if (intersect2) {
          intersects2.push(intersect2);
        }
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys2 = Object.keys(morphAttributes);
    if (keys2.length > 0) {
      const morphAttribute = morphAttributes[keys2[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
          const name2 = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name2] = m2;
        }
      }
    }
  }
}
function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a);
  _vEnd.fromBufferAttribute(positionAttribute, b);
  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance < raycaster.near || distance > raycaster.far) return;
  return {
    distance,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: a,
    face: null,
    faceIndex: null,
    barycoord: null,
    object
  };
}
const _start = /* @__PURE__ */ new Vector3();
const _end = /* @__PURE__ */ new Vector3();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i = 0, l2 = positionAttribute.count; i < l2; i += 2) {
        _start.fromBufferAttribute(positionAttribute, i);
        _end.fromBufferAttribute(positionAttribute, i + 1);
        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
}
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray$4 = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3();
class Points extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray$4.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index2 = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index2 !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index2.count, drawRange.start + drawRange.count);
      for (let i = start, il2 = end; i < il2; i++) {
        const a = index2.getX(i);
        _position$2.fromBufferAttribute(positionAttribute, a);
        testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i = start, l2 = end; i < l2; i++) {
        _position$2.fromBufferAttribute(positionAttribute, i);
        testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys2 = Object.keys(morphAttributes);
    if (keys2.length > 0) {
      const morphAttribute = morphAttributes[keys2[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml2 = morphAttribute.length; m2 < ml2; m2++) {
          const name2 = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name2] = m2;
        }
      }
    }
  }
}
function testPoint(point2, index2, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray$4.distanceSqToPoint(point2);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray$4.closestPointToPoint(point2, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index2,
      face: null,
      faceIndex: null,
      barycoord: null,
      object
    });
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u2, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il2 = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il2 - 1];
    }
    let low = 0, high = il2 - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il2 - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i + segmentFraction) / (il2 - 1);
    return t2;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0) t1 = 0;
    if (t22 > 1) t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u2 = i / segments;
      tangents[i] = this.getTangentAt(u2, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
const Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y2, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y2 = data[i + 1];
        if (x < minX) minX = x;
        if (y2 < minY) minY = y2;
        if (x > maxX) maxX = x;
        if (y2 > maxY) maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next) break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p2 = c.next;
  while (p2 !== a) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a && p2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a && n2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a && p2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a && n2 !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a = p2.prev, b = p2.next.next;
    if (!equals(a, b) && intersects(a, p2, p2.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list2;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list2 = linkedList(data, start, end, dim, false);
    if (list2 === list2.next) list2.steiner = true;
    queue.push(getLeftmost(list2));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode, qx = -Infinity, m2;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x <= hx && x > qx) {
        qx = x;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x === hx) return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2) return null;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list2) {
  let i, p2, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list2;
    list2 = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q2 = p2;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q2 = q2.nextZ;
        if (!q2) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q2) {
        if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
          e = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e = q2;
          q2 = q2.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list2 = e;
        e.prevZ = tail;
        tail = e;
      }
      p2 = q2;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list2;
}
function zOrder(x, y2, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p2, q2, r2) {
  return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p2, q2, r2) {
  return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p2 = a;
  do {
    if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a, b)) return true;
    p2 = p2.next;
  } while (p2 !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p2 = a, inside = false;
  const px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y2, last) {
  const p2 = new Node(i, x, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function Node(i, x, y2) {
  this.i = i;
  this.x = x;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n2 = contour.length;
    let a = 0;
    for (let p2 = n2 - 1, q2 = 0; q2 < n2; p2 = q2++) {
      a += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._dispersion = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(value) {
    if (this._dispersion > 0 !== value > 0) {
      this.version++;
    }
    this._dispersion = value;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.dispersion = source.dispersion;
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i, j) {
    return times[i] - times[j];
  }
  const n2 = times.length;
  const result = new Array(n2);
  for (let i = 0; i !== n2; ++i) result[i] = i;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order2) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
    const srcOffset = order2[i] * stride;
    for (let j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push.apply(values, value);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i++];
    } while (key !== void 0);
  }
}
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t2 < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t2 < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t2 < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index2) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name2, times, values, interpolation) {
    if (name2 === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name2);
    this.name = name2;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n2 = times.length; i !== n2; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n2 = times.length; i !== n2; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to);
      this.values = this.values.slice(from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid2 = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid2 = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid2 = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid2 = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid2 = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i = 0, n2 = values.length; i !== n2; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid2 = false;
            break;
          }
        }
      }
    }
    return valid2;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(name2, times, values) {
    super(name2, times, values);
  }
}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {
}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {
}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {
  // No interpolation parameter because only InterpolateDiscrete is valid.
  constructor(name2, times, values) {
    super(name2, times, values);
  }
}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {
}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(name2 = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
    this.name = name2;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i = 0, n2 = jsonTracks.length; i !== n2; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i = 0, n2 = clipTracks.length; i !== n2; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name2, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order2 = getKeyframeOrder(times);
      times = sortedArray(times, 1, order2);
      values = sortedArray(values, 1, order2);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name2, -1, tracks);
  }
  static findByName(objectOrClipArray, name2) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name2) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il2 = morphTargets.length; i < il2; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name2 = parts[1];
        let animationMorphTargets = animationToMorphTargets[name2];
        if (!animationMorphTargets) {
          animationToMorphTargets[name2] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name2 in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name2, animationToMorphTargets[name2], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n2 = tracks.length; i !== n2; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid2 = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid2 = valid2 && this.tracks[i].validate();
    }
    return valid2;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers2 = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex2, loader) {
      handlers2.push(regex2, loader);
      return this;
    };
    this.removeHandler = function(regex2) {
      const index2 = handlers2.indexOf(regex2);
      if (index2 !== -1) {
        handlers2.splice(index2, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l2 = handlers2.length; i < l2; i += 2) {
        const regex2 = handlers2[i];
        const loader = handlers2[i + 1];
        if (regex2.global) regex2.lastIndex = 0;
        if (regex2.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i = 0, il2 = callbacks.length; i < il2; i++) {
                    const callback = callbacks[i];
                    if (callback.onProgress) callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              }, (e) => {
                controller.error(e);
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text2) => {
            const parser = new DOMParser();
            return parser.parseFromString(text2, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re2 = /charset="?([^;"\s]*)"?/i;
            const exec = re2.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab2) => decoder.decode(ab2));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i = 0, il2 = callbacks.length; i < il2; i++) {
        const callback = callbacks[i];
        if (callback.onLoad) callback.onLoad(data);
      }
    }).catch((err2) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err2;
      }
      delete loading[url];
      for (let i = 0, il2 = callbacks.length; i < il2; i++) {
        const callback = callbacks[i];
        if (callback.onError) callback.onError(err2);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image2 = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image2.removeEventListener("load", onImageLoad, false);
      image2.removeEventListener("error", onImageError, false);
    }
    image2.addEventListener("load", onImageLoad, false);
    image2.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image2.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image2.src = url;
    return image2;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image2) {
      texture.image = image2;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
}
class Light extends Object3D {
  constructor(color2, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color2);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    if (this.target !== void 0) data.object.target = this.target.uuid;
    return data;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
const _lookTarget$1 = /* @__PURE__ */ new Vector3();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.intensity = source.intensity;
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.intensity !== 1) object.intensity = this.intensity;
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  constructor(color2, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color2, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3();
const _lookTarget = /* @__PURE__ */ new Vector3();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(color2, intensity, distance = 0, decay = 2) {
    super(color2, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  constructor(color2, intensity) {
    super(color2, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class LoaderUtils {
  static decodeText(array) {
    console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.");
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il2 = array.length; i < il2; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  }
  static extractUrlBase(url) {
    const index2 = url.lastIndexOf("/");
    if (index2 === -1) return "./";
    return url.slice(0, index2 + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
}
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.isImageBitmapLoader = true;
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      if (cached.then) {
        cached.then((imageBitmap) => {
          if (onLoad) onLoad(imageBitmap);
          scope.manager.itemEnd(url);
        }).catch((e) => {
          if (onError) onError(e);
        });
        return;
      }
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    const promise = fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
      return imageBitmap;
    }).catch(function(e) {
      if (onError) onError(e);
      Cache.remove(url);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    Cache.add(url, promise);
    scope.manager.itemStart(url);
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(
        buffer,
        offset,
        originalValueOffset,
        1 - weight,
        stride
      );
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  // mix functions
  _select(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
  }
  _lerp(buffer, dstOffset, srcOffset, t2, stride) {
    const s = 1 - t2;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t2;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t2;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
const _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
const _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
const _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
const _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
const _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n2 = bindings.length; i !== n2; ++i) {
      bindings[i].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n2 = bindings.length; i !== n2; ++i) {
      bindings[i].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n2 = bindings.length; i !== n2; ++i) {
      bindings[i].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root2, path, parsedPath) {
    if (!(root2 && root2.isAnimationObjectGroup)) {
      return new PropertyBinding(root2, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root2, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name2) {
    return name2.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root2, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root2.name || nodeName === root2.uuid) {
      return root2;
    }
    if (root2.skeleton) {
      const bone = root2.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root2.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root2.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i = 0, n2 = source.length; i !== n2; ++i) {
      buffer[offset++] = source[i];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  // Direct
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n2 = dest.length; i !== n2; ++i) {
      dest[i] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n2 = dest.length; i !== n2; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n2 = dest.length; i !== n2; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  // State & Scheduling
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        deltaTime = 0;
      } else {
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished) this.paused = true;
        else this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
  constructor(root2) {
    super();
    this._root = root2;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root2 = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root2.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        ++binding.referenceCount;
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root2, trackName, path),
          track.ValueTypeName,
          track.getValueSize()
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0]
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n2 = bindings.length; i !== n2; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n2 = bindings.length; i !== n2; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(action) {
    const index2 = action._cacheIndex;
    return index2 !== null && index2 < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n2 = bindings.length; i !== n2; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        _controlInterpolantsResultBuffer
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip, optionalRoot, blendMode) {
    const root2 = optionalRoot || this._root, rootUuid = root2.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root2, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null) return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  // get an existing action
  existingAction(clip, optionalRoot) {
    const root2 = optionalRoot || this._root, rootUuid = root2.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root2, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const actions = this._actions, nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  // advance the time and update apply the animation
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(clip) {
    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n2 = actionsToRemove.length; i !== n2; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(root2) {
    const rootUuid = root2.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  // remove a targeted clip from the cache
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
const _matrix = /* @__PURE__ */ new Matrix4();
class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction) {
    this.ray.set(origin, direction);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  setFromXRController(controller) {
    _matrix.identity().extractRotation(controller.matrixWorld);
    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
    return this;
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersect(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l2 = objects.length; i < l2; i++) {
      intersect(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects2, recursive) {
  let propagate = true;
  if (object.layers.test(raycaster.layers)) {
    const result = object.raycast(raycaster, intersects2);
    if (result === false) propagate = false;
  }
  if (propagate === true && recursive === true) {
    const children = object.children;
    for (let i = 0, l2 = children.length; i < l2; i++) {
      intersect(children[i], raycaster, intersects2, true);
    }
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  }
  setFromCartesianCoords(x, y2, z2) {
    this.radius = Math.sqrt(x * x + y2 * y2 + z2 * z2);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z2);
      this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Controls extends EventDispatcher {
  constructor(object, domElement = null) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.enabled = true;
    this.state = -1;
    this.keys = {};
    this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };
    this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
const _ray = new Ray();
const _plane = new Plane();
const _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
const _v = new Vector3();
const _twoPI = 2 * Math.PI;
const _STATE = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
};
const _EPS = 1e-6;
class OrbitControls extends Controls {
  constructor(object, domElement = null) {
    super(object, domElement);
    this.state = _STATE.NONE;
    this.enabled = true;
    this.target = new Vector3();
    this.cursor = new Vector3();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this._lastPosition = new Vector3();
    this._lastQuaternion = new Quaternion();
    this._lastTargetPosition = new Vector3();
    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
    this._quatInverse = this._quat.clone().invert();
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._scale = 1;
    this._panOffset = new Vector3();
    this._rotateStart = new Vector2();
    this._rotateEnd = new Vector2();
    this._rotateDelta = new Vector2();
    this._panStart = new Vector2();
    this._panEnd = new Vector2();
    this._panDelta = new Vector2();
    this._dollyStart = new Vector2();
    this._dollyEnd = new Vector2();
    this._dollyDelta = new Vector2();
    this._dollyDirection = new Vector3();
    this._mouse = new Vector2();
    this._performCursorZoom = false;
    this._pointers = [];
    this._pointerPositions = {};
    this._controlActive = false;
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this._onContextMenu = onContextMenu.bind(this);
    this._onMouseWheel = onMouseWheel.bind(this);
    this._onKeyDown = onKeyDown.bind(this);
    this._onTouchStart = onTouchStart.bind(this);
    this._onTouchMove = onTouchMove.bind(this);
    this._onMouseDown = onMouseDown.bind(this);
    this._onMouseMove = onMouseMove.bind(this);
    this._interceptControlDown = interceptControlDown.bind(this);
    this._interceptControlUp = interceptControlUp.bind(this);
    if (this.domElement !== null) {
      this.connect();
    }
    this.update();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointercancel", this._onPointerUp);
    this.domElement.addEventListener("contextmenu", this._onContextMenu);
    this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: false });
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keydown", this._interceptControlDown, { passive: true, capture: true });
    this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.domElement.removeEventListener("pointercancel", this._onPointerUp);
    this.domElement.removeEventListener("wheel", this._onMouseWheel);
    this.domElement.removeEventListener("contextmenu", this._onContextMenu);
    this.stopListenToKeyEvents();
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keydown", this._interceptControlDown, { capture: true });
    this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  getPolarAngle() {
    return this._spherical.phi;
  }
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  listenToKeyEvents(domElement) {
    domElement.addEventListener("keydown", this._onKeyDown);
    this._domElementKeyEvents = domElement;
  }
  stopListenToKeyEvents() {
    if (this._domElementKeyEvents !== null) {
      this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown);
      this._domElementKeyEvents = null;
    }
  }
  saveState() {
    this.target0.copy(this.target);
    this.position0.copy(this.object.position);
    this.zoom0 = this.object.zoom;
  }
  reset() {
    this.target.copy(this.target0);
    this.object.position.copy(this.position0);
    this.object.zoom = this.zoom0;
    this.object.updateProjectionMatrix();
    this.dispatchEvent(_changeEvent);
    this.update();
    this.state = _STATE.NONE;
  }
  update(deltaTime = null) {
    const position2 = this.object.position;
    _v.copy(position2).sub(this.target);
    _v.applyQuaternion(this._quat);
    this._spherical.setFromVector3(_v);
    if (this.autoRotate && this.state === _STATE.NONE) {
      this._rotateLeft(this._getAutoRotationAngle(deltaTime));
    }
    if (this.enableDamping) {
      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;
      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;
    } else {
      this._spherical.theta += this._sphericalDelta.theta;
      this._spherical.phi += this._sphericalDelta.phi;
    }
    let min = this.minAzimuthAngle;
    let max2 = this.maxAzimuthAngle;
    if (isFinite(min) && isFinite(max2)) {
      if (min < -Math.PI) min += _twoPI;
      else if (min > Math.PI) min -= _twoPI;
      if (max2 < -Math.PI) max2 += _twoPI;
      else if (max2 > Math.PI) max2 -= _twoPI;
      if (min <= max2) {
        this._spherical.theta = Math.max(min, Math.min(max2, this._spherical.theta));
      } else {
        this._spherical.theta = this._spherical.theta > (min + max2) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max2, this._spherical.theta);
      }
    }
    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));
    this._spherical.makeSafe();
    if (this.enableDamping === true) {
      this.target.addScaledVector(this._panOffset, this.dampingFactor);
    } else {
      this.target.add(this._panOffset);
    }
    this.target.sub(this.cursor);
    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);
    this.target.add(this.cursor);
    let zoomChanged = false;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    } else {
      const prevRadius = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);
      zoomChanged = prevRadius != this._spherical.radius;
    }
    _v.setFromSpherical(this._spherical);
    _v.applyQuaternion(this._quatInverse);
    position2.copy(this.target).add(_v);
    this.object.lookAt(this.target);
    if (this.enableDamping === true) {
      this._sphericalDelta.theta *= 1 - this.dampingFactor;
      this._sphericalDelta.phi *= 1 - this.dampingFactor;
      this._panOffset.multiplyScalar(1 - this.dampingFactor);
    } else {
      this._sphericalDelta.set(0, 0, 0);
      this._panOffset.set(0, 0, 0);
    }
    if (this.zoomToCursor && this._performCursorZoom) {
      let newRadius = null;
      if (this.object.isPerspectiveCamera) {
        const prevRadius = _v.length();
        newRadius = this._clampDistance(prevRadius * this._scale);
        const radiusDelta = prevRadius - newRadius;
        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);
        this.object.updateMatrixWorld();
        zoomChanged = !!radiusDelta;
      } else if (this.object.isOrthographicCamera) {
        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseBefore.unproject(this.object);
        const prevZoom = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
        this.object.updateProjectionMatrix();
        zoomChanged = prevZoom !== this.object.zoom;
        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);
        mouseAfter.unproject(this.object);
        this.object.position.sub(mouseAfter).add(mouseBefore);
        this.object.updateMatrixWorld();
        newRadius = _v.length();
      } else {
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.");
        this.zoomToCursor = false;
      }
      if (newRadius !== null) {
        if (this.screenSpacePanning) {
          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);
        } else {
          _ray.origin.copy(this.object.position);
          _ray.direction.set(0, 0, -1).transformDirection(this.object.matrix);
          if (Math.abs(this.object.up.dot(_ray.direction)) < _TILT_LIMIT) {
            this.object.lookAt(this.target);
          } else {
            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);
            _ray.intersectPlane(_plane, this.target);
          }
        }
      }
    } else if (this.object.isOrthographicCamera) {
      const prevZoom = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));
      if (prevZoom !== this.object.zoom) {
        this.object.updateProjectionMatrix();
        zoomChanged = true;
      }
    }
    this._scale = 1;
    this._performCursorZoom = false;
    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {
      this.dispatchEvent(_changeEvent);
      this._lastPosition.copy(this.object.position);
      this._lastQuaternion.copy(this.object.quaternion);
      this._lastTargetPosition.copy(this.target);
      return true;
    }
    return false;
  }
  _getAutoRotationAngle(deltaTime) {
    if (deltaTime !== null) {
      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;
    } else {
      return _twoPI / 60 / 60 * this.autoRotateSpeed;
    }
  }
  _getZoomScale(delta) {
    const normalizedDelta = Math.abs(delta * 0.01);
    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);
  }
  _rotateLeft(angle) {
    this._sphericalDelta.theta -= angle;
  }
  _rotateUp(angle) {
    this._sphericalDelta.phi -= angle;
  }
  _panLeft(distance, objectMatrix) {
    _v.setFromMatrixColumn(objectMatrix, 0);
    _v.multiplyScalar(-distance);
    this._panOffset.add(_v);
  }
  _panUp(distance, objectMatrix) {
    if (this.screenSpacePanning === true) {
      _v.setFromMatrixColumn(objectMatrix, 1);
    } else {
      _v.setFromMatrixColumn(objectMatrix, 0);
      _v.crossVectors(this.object.up, _v);
    }
    _v.multiplyScalar(distance);
    this._panOffset.add(_v);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(deltaX, deltaY) {
    const element2 = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const position2 = this.object.position;
      _v.copy(position2).sub(this.target);
      let targetDistance = _v.length();
      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
      this._panLeft(2 * deltaX * targetDistance / element2.clientHeight, this.object.matrix);
      this._panUp(2 * deltaY * targetDistance / element2.clientHeight, this.object.matrix);
    } else if (this.object.isOrthographicCamera) {
      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element2.clientWidth, this.object.matrix);
      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element2.clientHeight, this.object.matrix);
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
      this.enablePan = false;
    }
  }
  _dollyOut(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale /= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _dollyIn(dollyScale) {
    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {
      this._scale *= dollyScale;
    } else {
      console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
      this.enableZoom = false;
    }
  }
  _updateZoomParameters(x, y2) {
    if (!this.zoomToCursor) {
      return;
    }
    this._performCursorZoom = true;
    const rect = this.domElement.getBoundingClientRect();
    const dx = x - rect.left;
    const dy = y2 - rect.top;
    const w2 = rect.width;
    const h = rect.height;
    this._mouse.x = dx / w2 * 2 - 1;
    this._mouse.y = -(dy / h) * 2 + 1;
    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(dist) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(event) {
    this._rotateStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownDolly(event) {
    this._updateZoomParameters(event.clientX, event.clientX);
    this._dollyStart.set(event.clientX, event.clientY);
  }
  _handleMouseDownPan(event) {
    this._panStart.set(event.clientX, event.clientY);
  }
  _handleMouseMoveRotate(event) {
    this._rotateEnd.set(event.clientX, event.clientY);
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
    this.update();
  }
  _handleMouseMoveDolly(event) {
    this._dollyEnd.set(event.clientX, event.clientY);
    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);
    if (this._dollyDelta.y > 0) {
      this._dollyOut(this._getZoomScale(this._dollyDelta.y));
    } else if (this._dollyDelta.y < 0) {
      this._dollyIn(this._getZoomScale(this._dollyDelta.y));
    }
    this._dollyStart.copy(this._dollyEnd);
    this.update();
  }
  _handleMouseMovePan(event) {
    this._panEnd.set(event.clientX, event.clientY);
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
    this.update();
  }
  _handleMouseWheel(event) {
    this._updateZoomParameters(event.clientX, event.clientY);
    if (event.deltaY < 0) {
      this._dollyIn(this._getZoomScale(event.deltaY));
    } else if (event.deltaY > 0) {
      this._dollyOut(this._getZoomScale(event.deltaY));
    }
    this.update();
  }
  _handleKeyDown(event) {
    let needsUpdate = false;
    switch (event.code) {
      case this.keys.UP:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(0, this.keyPanSpeed);
        }
        needsUpdate = true;
        break;
      case this.keys.BOTTOM:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(0, -this.keyPanSpeed);
        }
        needsUpdate = true;
        break;
      case this.keys.LEFT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(this.keyPanSpeed, 0);
        }
        needsUpdate = true;
        break;
      case this.keys.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          this._rotateLeft(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);
        } else {
          this._pan(-this.keyPanSpeed, 0);
        }
        needsUpdate = true;
        break;
    }
    if (needsUpdate) {
      event.preventDefault();
      this.update();
    }
  }
  _handleTouchStartRotate(event) {
    if (this._pointers.length === 1) {
      this._rotateStart.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._rotateStart.set(x, y2);
    }
  }
  _handleTouchStartPan(event) {
    if (this._pointers.length === 1) {
      this._panStart.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._panStart.set(x, y2);
    }
  }
  _handleTouchStartDolly(event) {
    const position2 = this._getSecondPointerPosition(event);
    const dx = event.pageX - position2.x;
    const dy = event.pageY - position2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyStart.set(0, distance);
  }
  _handleTouchStartDollyPan(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enablePan) this._handleTouchStartPan(event);
  }
  _handleTouchStartDollyRotate(event) {
    if (this.enableZoom) this._handleTouchStartDolly(event);
    if (this.enableRotate) this._handleTouchStartRotate(event);
  }
  _handleTouchMoveRotate(event) {
    if (this._pointers.length == 1) {
      this._rotateEnd.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._rotateEnd.set(x, y2);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const element2 = this.domElement;
    this._rotateLeft(_twoPI * this._rotateDelta.x / element2.clientHeight);
    this._rotateUp(_twoPI * this._rotateDelta.y / element2.clientHeight);
    this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(event) {
    if (this._pointers.length === 1) {
      this._panEnd.set(event.pageX, event.pageY);
    } else {
      const position2 = this._getSecondPointerPosition(event);
      const x = 0.5 * (event.pageX + position2.x);
      const y2 = 0.5 * (event.pageY + position2.y);
      this._panEnd.set(x, y2);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);
    this._pan(this._panDelta.x, this._panDelta.y);
    this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(event) {
    const position2 = this._getSecondPointerPosition(event);
    const dx = event.pageX - position2.x;
    const dy = event.pageY - position2.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    this._dollyEnd.set(0, distance);
    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));
    this._dollyOut(this._dollyDelta.y);
    this._dollyStart.copy(this._dollyEnd);
    const centerX = (event.pageX + position2.x) * 0.5;
    const centerY = (event.pageY + position2.y) * 0.5;
    this._updateZoomParameters(centerX, centerY);
  }
  _handleTouchMoveDollyPan(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enablePan) this._handleTouchMovePan(event);
  }
  _handleTouchMoveDollyRotate(event) {
    if (this.enableZoom) this._handleTouchMoveDolly(event);
    if (this.enableRotate) this._handleTouchMoveRotate(event);
  }
  // pointers
  _addPointer(event) {
    this._pointers.push(event.pointerId);
  }
  _removePointer(event) {
    delete this._pointerPositions[event.pointerId];
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) {
        this._pointers.splice(i, 1);
        return;
      }
    }
  }
  _isTrackingPointer(event) {
    for (let i = 0; i < this._pointers.length; i++) {
      if (this._pointers[i] == event.pointerId) return true;
    }
    return false;
  }
  _trackPointer(event) {
    let position2 = this._pointerPositions[event.pointerId];
    if (position2 === void 0) {
      position2 = new Vector2();
      this._pointerPositions[event.pointerId] = position2;
    }
    position2.set(event.pageX, event.pageY);
  }
  _getSecondPointerPosition(event) {
    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[pointerId];
  }
  //
  _customWheelEvent(event) {
    const mode = event.deltaMode;
    const newEvent = {
      clientX: event.clientX,
      clientY: event.clientY,
      deltaY: event.deltaY
    };
    switch (mode) {
      case 1:
        newEvent.deltaY *= 16;
        break;
      case 2:
        newEvent.deltaY *= 100;
        break;
    }
    if (event.ctrlKey && !this._controlActive) {
      newEvent.deltaY *= 10;
    }
    return newEvent;
  }
}
function onPointerDown(event) {
  if (this.enabled === false) return;
  if (this._pointers.length === 0) {
    this.domElement.setPointerCapture(event.pointerId);
    this.domElement.addEventListener("pointermove", this._onPointerMove);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  if (this._isTrackingPointer(event)) return;
  this._addPointer(event);
  if (event.pointerType === "touch") {
    this._onTouchStart(event);
  } else {
    this._onMouseDown(event);
  }
}
function onPointerMove(event) {
  if (this.enabled === false) return;
  if (event.pointerType === "touch") {
    this._onTouchMove(event);
  } else {
    this._onMouseMove(event);
  }
}
function onPointerUp(event) {
  this._removePointer(event);
  switch (this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(event.pointerId);
      this.domElement.removeEventListener("pointermove", this._onPointerMove);
      this.domElement.removeEventListener("pointerup", this._onPointerUp);
      this.dispatchEvent(_endEvent);
      this.state = _STATE.NONE;
      break;
    case 1:
      const pointerId = this._pointers[0];
      const position2 = this._pointerPositions[pointerId];
      this._onTouchStart({ pointerId, pageX: position2.x, pageY: position2.y });
      break;
  }
}
function onMouseDown(event) {
  let mouseAction;
  switch (event.button) {
    case 0:
      mouseAction = this.mouseButtons.LEFT;
      break;
    case 1:
      mouseAction = this.mouseButtons.MIDDLE;
      break;
    case 2:
      mouseAction = this.mouseButtons.RIGHT;
      break;
    default:
      mouseAction = -1;
  }
  switch (mouseAction) {
    case MOUSE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseDownDolly(event);
      this.state = _STATE.DOLLY;
      break;
    case MOUSE.ROTATE:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      } else {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      }
      break;
    case MOUSE.PAN:
      if (event.ctrlKey || event.metaKey || event.shiftKey) {
        if (this.enableRotate === false) return;
        this._handleMouseDownRotate(event);
        this.state = _STATE.ROTATE;
      } else {
        if (this.enablePan === false) return;
        this._handleMouseDownPan(event);
        this.state = _STATE.PAN;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onMouseMove(event) {
  switch (this.state) {
    case _STATE.ROTATE:
      if (this.enableRotate === false) return;
      this._handleMouseMoveRotate(event);
      break;
    case _STATE.DOLLY:
      if (this.enableZoom === false) return;
      this._handleMouseMoveDolly(event);
      break;
    case _STATE.PAN:
      if (this.enablePan === false) return;
      this._handleMouseMovePan(event);
      break;
  }
}
function onMouseWheel(event) {
  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;
  event.preventDefault();
  this.dispatchEvent(_startEvent);
  this._handleMouseWheel(this._customWheelEvent(event));
  this.dispatchEvent(_endEvent);
}
function onKeyDown(event) {
  if (this.enabled === false || this.enablePan === false) return;
  this._handleKeyDown(event);
}
function onTouchStart(event) {
  this._trackPointer(event);
  switch (this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case TOUCH.ROTATE:
          if (this.enableRotate === false) return;
          this._handleTouchStartRotate(event);
          this.state = _STATE.TOUCH_ROTATE;
          break;
        case TOUCH.PAN:
          if (this.enablePan === false) return;
          this._handleTouchStartPan(event);
          this.state = _STATE.TOUCH_PAN;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case TOUCH.DOLLY_PAN:
          if (this.enableZoom === false && this.enablePan === false) return;
          this._handleTouchStartDollyPan(event);
          this.state = _STATE.TOUCH_DOLLY_PAN;
          break;
        case TOUCH.DOLLY_ROTATE:
          if (this.enableZoom === false && this.enableRotate === false) return;
          this._handleTouchStartDollyRotate(event);
          this.state = _STATE.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = _STATE.NONE;
      }
      break;
    default:
      this.state = _STATE.NONE;
  }
  if (this.state !== _STATE.NONE) {
    this.dispatchEvent(_startEvent);
  }
}
function onTouchMove(event) {
  this._trackPointer(event);
  switch (this.state) {
    case _STATE.TOUCH_ROTATE:
      if (this.enableRotate === false) return;
      this._handleTouchMoveRotate(event);
      this.update();
      break;
    case _STATE.TOUCH_PAN:
      if (this.enablePan === false) return;
      this._handleTouchMovePan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_PAN:
      if (this.enableZoom === false && this.enablePan === false) return;
      this._handleTouchMoveDollyPan(event);
      this.update();
      break;
    case _STATE.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === false && this.enableRotate === false) return;
      this._handleTouchMoveDollyRotate(event);
      this.update();
      break;
    default:
      this.state = _STATE.NONE;
  }
}
function onContextMenu(event) {
  if (this.enabled === false) return;
  event.preventDefault();
}
function interceptControlDown(event) {
  if (event.key === "Control") {
    this._controlActive = true;
    const document2 = this.domElement.getRootNode();
    document2.addEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function interceptControlUp(event) {
  if (event.key === "Control") {
    this._controlActive = false;
    const document2 = this.domElement.getRootNode();
    document2.removeEventListener("keyup", this._interceptControlUp, { passive: true, capture: true });
  }
}
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index2 = geometry.getIndex();
    if (index2 === null) {
      const indices = [];
      const position2 = geometry.getAttribute("position");
      if (position2 !== void 0) {
        for (let i = 0; i < position2.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index2 = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index2.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index2.getX(0));
        newIndices.push(index2.getX(i));
        newIndices.push(index2.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index2.getX(i));
          newIndices.push(index2.getX(i + 1));
          newIndices.push(index2.getX(i + 2));
        } else {
          newIndices.push(index2.getX(i + 2));
          newIndices.push(index2.getX(i + 1));
          newIndices.push(index2.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
class GLTFLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError) onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
}
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color2 = new Color(16777215);
    if (lightDef.color !== void 0) color2.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color2);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color2);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color2);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index2) {
    if (type !== "light") return;
    return this._loadLight(index2);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0) return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    if (extension2.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension2.clearcoatFactor;
    }
    if (extension2.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension2.clearcoatTexture));
    }
    if (extension2.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension2.clearcoatRoughnessFactor;
    }
    if (extension2.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension2.clearcoatRoughnessTexture));
    }
    if (extension2.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension2.clearcoatNormalTexture));
      if (extension2.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension2.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsDispersionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension2 = materialDef.extensions[this.name];
    materialParams.dispersion = extension2.dispersion !== void 0 ? extension2.dispersion : 0;
    return Promise.resolve();
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    if (extension2.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension2.iridescenceFactor;
    }
    if (extension2.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension2.iridescenceTexture));
    }
    if (extension2.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension2.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension2.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension2.iridescenceThicknessMinimum;
    }
    if (extension2.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension2.iridescenceThicknessMaximum;
    }
    if (extension2.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension2.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsSheenExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension2 = materialDef.extensions[this.name];
    if (extension2.sheenColorFactor !== void 0) {
      const colorFactor = extension2.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension2.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension2.sheenRoughnessFactor;
    }
    if (extension2.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension2.sheenColorTexture, SRGBColorSpace));
    }
    if (extension2.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension2.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    if (extension2.transmissionFactor !== void 0) {
      materialParams.transmission = extension2.transmissionFactor;
    }
    if (extension2.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension2.transmissionTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    materialParams.thickness = extension2.thicknessFactor !== void 0 ? extension2.thicknessFactor : 0;
    if (extension2.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension2.thicknessTexture));
    }
    materialParams.attenuationDistance = extension2.attenuationDistance || Infinity;
    const colorArray = extension2.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
}
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension2 = materialDef.extensions[this.name];
    materialParams.ior = extension2.ior !== void 0 ? extension2.ior : 1.5;
    return Promise.resolve();
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension2.specularFactor !== void 0 ? extension2.specularFactor : 1;
    if (extension2.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension2.specularTexture));
    }
    const colorArray = extension2.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension2.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension2.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsBumpExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    materialParams.bumpScale = extension2.bumpFactor !== void 0 ? extension2.bumpFactor : 1;
    if (extension2.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension2.bumpTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension2 = materialDef.extensions[this.name];
    if (extension2.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension2.anisotropyStrength;
    }
    if (extension2.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension2.anisotropyRotation;
    }
    if (extension2.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension2.anisotropyTexture));
    }
    return Promise.all(pending);
  }
}
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension2 = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension2.source, loader);
  }
}
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name2 = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name2]) {
      return null;
    }
    const extension2 = textureDef.extensions[name2];
    const source = json.images[extension2.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension2.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name2) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image2 = new Image();
        image2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image2.onload = image2.onerror = function() {
          resolve(image2.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFTextureAVIFExtension {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name2 = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name2]) {
      return null;
    }
    const extension2 = textureDef.extensions[name2];
    const source = json.images[extension2.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported) return parser.loadTextureImage(textureIndex, extension2.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name2) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image2 = new Image();
        image2.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image2.onload = image2.onerror = function() {
          resolve(image2.height === 1);
        };
      });
    }
    return this.isSupported;
  }
}
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index2) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index2];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
}
class GLTFMeshGpuInstancing {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m2 = new Matrix4();
        const p2 = new Vector3();
        const q2 = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p2.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q2.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m2.compose(p2, q2, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF";
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index2) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index2 * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td2 = t1 - t0;
    const p2 = (t2 - t0) / td2;
    const pp = p2 * p2;
    const ppp = pp * p2;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p2;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td2;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td2;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
}
const _q = new Quaternion();
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
}
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
const WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
const ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
const PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
const INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
const ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name2 in objectDef.extensions) {
    if (knownExtensions[name2] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name2] = objectDef.extensions[name2];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il2 = targets.length; i < il2; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0) hasMorphPosition = true;
    if (target.NORMAL !== void 0) hasMorphNormal = true;
    if (target.COLOR_0 !== void 0) hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il2 = targets.length; i < il2; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il2 = meshDef.weights.length; i < il2; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il2 = targetNames.length; i < il2; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il2 = primitiveDef.targets.length; i < il2; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys2 = Object.keys(attributes).sort();
  for (let i = 0, il2 = keys2.length; i < il2; i++) {
    attributesKey += keys2[i] + ":" + attributes[keys2[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
  return "image/png";
}
const _identityMatrix = new Matrix4();
class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il2 = joints.length; i < il2; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index2) {
    if (index2 === void 0) return;
    if (cache.refs[index2] === void 0) {
      cache.refs[index2] = cache.uses[index2] = 0;
    }
    cache.refs[index2]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index2, object) {
    if (cache.refs[index2] <= 1) return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index2]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result) pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index2) {
    const cacheKey = type + ":" + index2;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index2);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index2);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index2);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index2);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index2);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index2);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index2);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index2);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index2);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index2);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index2);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index2);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index2) {
        return parser.getDependency(type, index2);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib2 = parser.cache.get(ibCacheKey);
        if (!ib2) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib2 = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib2);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib2, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i = 0, il2 = sparseIndices.length; i < il2; i++) {
          const index2 = sparseIndices[i];
          bufferAttribute.setX(index2, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index2, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index2, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index2, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture) return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents) cacheKey += "derivative-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name) material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il2 = primitives.length; i < il2; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il2 = primitives.length; i < il2; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il2 = geometries.length; i < il2; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il2 = meshes.length; i < il2; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il2 = meshes.length; i < il2; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il2 = skinDef.joints.length; i < il2; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il2 = jointNodes.length; i < il2; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il2 = animationDef.channels.length; i < il2; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name2 = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0) continue;
      pendingNodes.push(this.getDependency("node", name2));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il2 = nodes.length; i < il2; i++) {
        const node2 = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node2 === void 0) continue;
        if (node2.updateMatrix) {
          node2.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node2, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k2 = 0; k2 < createdTracks.length; k2++) {
            tracks.push(createdTracks[k2]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0) return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node2 = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node2.traverse(function(o) {
          if (!o.isMesh) return;
          for (let i = 0, il2 = nodeDef.weights.length; i < il2; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node2;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il2 = childrenDef.length; i < il2; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node2 = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node2.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh) return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il2 = children.length; i < il2; i++) {
        node2.add(children[i]);
      }
      return node2;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node2;
      if (nodeDef.isBone === true) {
        node2 = new Bone();
      } else if (objects.length > 1) {
        node2 = new Group();
      } else if (objects.length === 1) {
        node2 = objects[0];
      } else {
        node2 = new Object3D();
      }
      if (node2 !== objects[0]) {
        for (let i = 0, il2 = objects.length; i < il2; i++) {
          node2.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node2.userData.name = nodeDef.name;
        node2.name = nodeName;
      }
      assignExtrasToUserData(node2, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node2, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node2.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node2.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node2.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node2.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node2)) {
        parser.associations.set(node2, {});
      }
      parser.associations.get(node2).nodes = nodeIndex;
      return node2;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il2 = nodeIds.length; i < il2; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il2 = nodes.length; i < il2; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node2) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node2.traverse((node3) => {
          const mappings = parser.associations.get(node3);
          if (mappings != null) {
            reducedAssociations.set(node3, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node2, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node2.name ? node2.name : node2.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node2.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl2 = targetNames.length; j < jl2; j++) {
      const track = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl2 = outputArray.length; j < jl2; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max2 = accessor.max;
    if (min !== void 0 && max2 !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max2[0], max2[1], max2[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il2 = targets.length; i < il2; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max2 = accessor.max;
        if (min !== void 0 && max2 !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max2[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max2[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max2[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb2, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb2[i - 1];
  }
  var r2 = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r2[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r: r2 };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), fd = _b.b;
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
  var x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var hMap = function(cd2, mb2, r2) {
  var s = cd2.length;
  var i = 0;
  var l2 = new u16(mb2);
  for (; i < s; ++i) {
    if (cd2[i])
      ++l2[cd2[i] - 1];
  }
  var le2 = new u16(mb2);
  for (i = 1; i < mb2; ++i) {
    le2[i] = le2[i - 1] + l2[i - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb2);
    var rvb = 15 - mb2;
    for (i = 0; i < s; ++i) {
      if (cd2[i]) {
        var sv = i << 4 | cd2[i];
        var r_1 = mb2 - cd2[i];
        var v2 = le2[cd2[i] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd2[i]) {
        co[i] = rev[le2[cd2[i] - 1]++] >> 15 - cd2[i];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
  flt[i] = 8;
for (var i = 144; i < 256; ++i)
  flt[i] = 9;
for (var i = 256; i < 280; ++i)
  flt[i] = 7;
for (var i = 280; i < 288; ++i)
  flt[i] = 8;
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
  fdt[i] = 5;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a) {
  var m2 = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m2)
      m2 = a[i];
  }
  return m2;
};
var bits = function(d, p2, m2) {
  var o = p2 / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p2 & 7) & m2;
};
var bits16 = function(d, p2) {
  var o = p2 / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p2 & 7);
};
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v2, s, e) {
  if (e == null || e > v2.length)
    e = v2.length;
  return new u8(v2.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl2 = dat.length, dl2 = 0;
  if (!sl2 || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl2 * 3);
  var cbuf = function(l3) {
    var bl2 = buf.length;
    if (l3 > bl2) {
      var nbuf = new u8(Math.max(bl2 * 2, l3));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl2 * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l2 = dat[s - 4] | dat[s - 3] << 8, t2 = s + l2;
        if (t2 > sl2) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l2);
        buf.set(dat.subarray(s, t2), bt);
        st.b = bt += l2, st.p = pos = t2 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl2 = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl2);
        var clt = new u8(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl2; ) {
          var r2 = clm[bits(dat, pos, clbmsk)];
          pos += r2 & 15;
          var s = r2 >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n2 = 0;
            if (s == 16)
              n2 = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n2 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n2 = 11 + bits(dat, pos, 127), pos += 7;
            while (n2--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl2 - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts), -4), { i: 2 }, opts, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
function findSpan(p2, u2, U2) {
  const n2 = U2.length - p2 - 1;
  if (u2 >= U2[n2]) {
    return n2 - 1;
  }
  if (u2 <= U2[p2]) {
    return p2;
  }
  let low = p2;
  let high = n2;
  let mid = Math.floor((low + high) / 2);
  while (u2 < U2[mid] || u2 >= U2[mid + 1]) {
    if (u2 < U2[mid]) {
      high = mid;
    } else {
      low = mid;
    }
    mid = Math.floor((low + high) / 2);
  }
  return mid;
}
function calcBasisFunctions(span, u2, p2, U2) {
  const N2 = [];
  const left = [];
  const right = [];
  N2[0] = 1;
  for (let j = 1; j <= p2; ++j) {
    left[j] = u2 - U2[span + 1 - j];
    right[j] = U2[span + j] - u2;
    let saved = 0;
    for (let r2 = 0; r2 < j; ++r2) {
      const rv = right[r2 + 1];
      const lv = left[j - r2];
      const temp = N2[r2] / (rv + lv);
      N2[r2] = saved + rv * temp;
      saved = lv * temp;
    }
    N2[j] = saved;
  }
  return N2;
}
function calcBSplinePoint(p2, U2, P2, u2) {
  const span = findSpan(p2, u2, U2);
  const N2 = calcBasisFunctions(span, u2, p2, U2);
  const C2 = new Vector4(0, 0, 0, 0);
  for (let j = 0; j <= p2; ++j) {
    const point2 = P2[span - p2 + j];
    const Nj2 = N2[j];
    const wNj = point2.w * Nj2;
    C2.x += point2.x * wNj;
    C2.y += point2.y * wNj;
    C2.z += point2.z * wNj;
    C2.w += point2.w * Nj2;
  }
  return C2;
}
function calcBasisFunctionDerivatives(span, u2, p2, n2, U2) {
  const zeroArr = [];
  for (let i = 0; i <= p2; ++i)
    zeroArr[i] = 0;
  const ders = [];
  for (let i = 0; i <= n2; ++i)
    ders[i] = zeroArr.slice(0);
  const ndu = [];
  for (let i = 0; i <= p2; ++i)
    ndu[i] = zeroArr.slice(0);
  ndu[0][0] = 1;
  const left = zeroArr.slice(0);
  const right = zeroArr.slice(0);
  for (let j = 1; j <= p2; ++j) {
    left[j] = u2 - U2[span + 1 - j];
    right[j] = U2[span + j] - u2;
    let saved = 0;
    for (let r3 = 0; r3 < j; ++r3) {
      const rv = right[r3 + 1];
      const lv = left[j - r3];
      ndu[j][r3] = rv + lv;
      const temp = ndu[r3][j - 1] / ndu[j][r3];
      ndu[r3][j] = saved + rv * temp;
      saved = lv * temp;
    }
    ndu[j][j] = saved;
  }
  for (let j = 0; j <= p2; ++j) {
    ders[0][j] = ndu[j][p2];
  }
  for (let r3 = 0; r3 <= p2; ++r3) {
    let s1 = 0;
    let s2 = 1;
    const a = [];
    for (let i = 0; i <= p2; ++i) {
      a[i] = zeroArr.slice(0);
    }
    a[0][0] = 1;
    for (let k2 = 1; k2 <= n2; ++k2) {
      let d = 0;
      const rk2 = r3 - k2;
      const pk2 = p2 - k2;
      if (r3 >= k2) {
        a[s2][0] = a[s1][0] / ndu[pk2 + 1][rk2];
        d = a[s2][0] * ndu[rk2][pk2];
      }
      const j1 = rk2 >= -1 ? 1 : -rk2;
      const j2 = r3 - 1 <= pk2 ? k2 - 1 : p2 - r3;
      for (let j3 = j1; j3 <= j2; ++j3) {
        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk2 + 1][rk2 + j3];
        d += a[s2][j3] * ndu[rk2 + j3][pk2];
      }
      if (r3 <= pk2) {
        a[s2][k2] = -a[s1][k2 - 1] / ndu[pk2 + 1][r3];
        d += a[s2][k2] * ndu[r3][pk2];
      }
      ders[k2][r3] = d;
      const j = s1;
      s1 = s2;
      s2 = j;
    }
  }
  let r2 = p2;
  for (let k2 = 1; k2 <= n2; ++k2) {
    for (let j = 0; j <= p2; ++j) {
      ders[k2][j] *= r2;
    }
    r2 *= p2 - k2;
  }
  return ders;
}
function calcBSplineDerivatives(p2, U2, P2, u2, nd2) {
  const du = nd2 < p2 ? nd2 : p2;
  const CK = [];
  const span = findSpan(p2, u2, U2);
  const nders = calcBasisFunctionDerivatives(span, u2, p2, du, U2);
  const Pw = [];
  for (let i = 0; i < P2.length; ++i) {
    const point2 = P2[i].clone();
    const w2 = point2.w;
    point2.x *= w2;
    point2.y *= w2;
    point2.z *= w2;
    Pw[i] = point2;
  }
  for (let k2 = 0; k2 <= du; ++k2) {
    const point2 = Pw[span - p2].clone().multiplyScalar(nders[k2][0]);
    for (let j = 1; j <= p2; ++j) {
      point2.add(Pw[span - p2 + j].clone().multiplyScalar(nders[k2][j]));
    }
    CK[k2] = point2;
  }
  for (let k2 = du + 1; k2 <= nd2 + 1; ++k2) {
    CK[k2] = new Vector4(0, 0, 0);
  }
  return CK;
}
function calcKoverI(k2, i) {
  let nom = 1;
  for (let j = 2; j <= k2; ++j) {
    nom *= j;
  }
  let denom = 1;
  for (let j = 2; j <= i; ++j) {
    denom *= j;
  }
  for (let j = 2; j <= k2 - i; ++j) {
    denom *= j;
  }
  return nom / denom;
}
function calcRationalCurveDerivatives(Pders) {
  const nd2 = Pders.length;
  const Aders = [];
  const wders = [];
  for (let i = 0; i < nd2; ++i) {
    const point2 = Pders[i];
    Aders[i] = new Vector3(point2.x, point2.y, point2.z);
    wders[i] = point2.w;
  }
  const CK = [];
  for (let k2 = 0; k2 < nd2; ++k2) {
    const v2 = Aders[k2].clone();
    for (let i = 1; i <= k2; ++i) {
      v2.sub(CK[k2 - i].clone().multiplyScalar(calcKoverI(k2, i) * wders[i]));
    }
    CK[k2] = v2.divideScalar(wders[0]);
  }
  return CK;
}
function calcNURBSDerivatives(p2, U2, P2, u2, nd2) {
  const Pders = calcBSplineDerivatives(p2, U2, P2, u2, nd2);
  return calcRationalCurveDerivatives(Pders);
}
class NURBSCurve extends Curve {
  constructor(degree, knots, controlPoints, startKnot, endKnot) {
    super();
    this.degree = degree;
    this.knots = knots;
    this.controlPoints = [];
    this.startKnot = startKnot || 0;
    this.endKnot = endKnot || this.knots.length - 1;
    for (let i = 0; i < controlPoints.length; ++i) {
      const point2 = controlPoints[i];
      this.controlPoints[i] = new Vector4(point2.x, point2.y, point2.z, point2.w);
    }
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point2 = optionalTarget;
    const u2 = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);
    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u2);
    if (hpoint.w !== 1) {
      hpoint.divideScalar(hpoint.w);
    }
    return point2.set(hpoint.x, hpoint.y, hpoint.z);
  }
  getTangent(t2, optionalTarget = new Vector3()) {
    const tangent = optionalTarget;
    const u2 = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);
    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u2, 1);
    tangent.copy(ders[1]).normalize();
    return tangent;
  }
}
let fbxTree;
let connections;
let sceneGraph;
class FBXLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = scope.path === "" ? LoaderUtils.extractUrlBase(url) : scope.path;
    const loader = new FileLoader(this.manager);
    loader.setPath(scope.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      try {
        onLoad(scope.parse(buffer, path));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(FBXBuffer, path) {
    if (isFbxFormatBinary(FBXBuffer)) {
      fbxTree = new BinaryParser().parse(FBXBuffer);
    } else {
      const FBXText = convertArrayBufferToString(FBXBuffer);
      if (!isFbxFormatASCII(FBXText)) {
        throw new Error("THREE.FBXLoader: Unknown format.");
      }
      if (getFbxVersion(FBXText) < 7e3) {
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(FBXText));
      }
      fbxTree = new TextParser().parse(FBXText);
    }
    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
  }
}
class FBXTreeParser {
  constructor(textureLoader, manager) {
    this.textureLoader = textureLoader;
    this.manager = manager;
  }
  parse() {
    connections = this.parseConnections();
    const images = this.parseImages();
    const textures = this.parseTextures(images);
    const materials = this.parseMaterials(textures);
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse(deformers);
    this.parseScene(deformers, geometryMap, materials);
    return sceneGraph;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const connectionMap = /* @__PURE__ */ new Map();
    if ("Connections" in fbxTree) {
      const rawConnections = fbxTree.Connections.connections;
      rawConnections.forEach(function(rawConnection) {
        const fromID = rawConnection[0];
        const toID = rawConnection[1];
        const relationship = rawConnection[2];
        if (!connectionMap.has(fromID)) {
          connectionMap.set(fromID, {
            parents: [],
            children: []
          });
        }
        const parentRelationship = { ID: toID, relationship };
        connectionMap.get(fromID).parents.push(parentRelationship);
        if (!connectionMap.has(toID)) {
          connectionMap.set(toID, {
            parents: [],
            children: []
          });
        }
        const childRelationship = { ID: fromID, relationship };
        connectionMap.get(toID).children.push(childRelationship);
      });
    }
    return connectionMap;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const images = {};
    const blobs = {};
    if ("Video" in fbxTree.Objects) {
      const videoNodes = fbxTree.Objects.Video;
      for (const nodeID in videoNodes) {
        const videoNode = videoNodes[nodeID];
        const id2 = parseInt(nodeID);
        images[id2] = videoNode.RelativeFilename || videoNode.Filename;
        if ("Content" in videoNode) {
          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
          const base64Content = typeof videoNode.Content === "string" && videoNode.Content !== "";
          if (arrayBufferContent || base64Content) {
            const image2 = this.parseImage(videoNodes[nodeID]);
            blobs[videoNode.RelativeFilename || videoNode.Filename] = image2;
          }
        }
      }
    }
    for (const id2 in images) {
      const filename = images[id2];
      if (blobs[filename] !== void 0) images[id2] = blobs[filename];
      else images[id2] = images[id2].split("\\").pop();
    }
    return images;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(videoNode) {
    const content2 = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension2 = fileName.slice(fileName.lastIndexOf(".") + 1).toLowerCase();
    let type;
    switch (extension2) {
      case "bmp":
        type = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        type = "image/jpeg";
        break;
      case "png":
        type = "image/png";
        break;
      case "tif":
        type = "image/tiff";
        break;
      case "tga":
        if (this.manager.getHandler(".tga") === null) {
          console.warn("FBXLoader: TGA loader not found, skipping ", fileName);
        }
        type = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + extension2 + '" is not supported.');
        return;
    }
    if (typeof content2 === "string") {
      return "data:" + type + ";base64," + content2;
    } else {
      const array = new Uint8Array(content2);
      return window.URL.createObjectURL(new Blob([array], { type }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(images) {
    const textureMap = /* @__PURE__ */ new Map();
    if ("Texture" in fbxTree.Objects) {
      const textureNodes = fbxTree.Objects.Texture;
      for (const nodeID in textureNodes) {
        const texture = this.parseTexture(textureNodes[nodeID], images);
        textureMap.set(parseInt(nodeID), texture);
      }
    }
    return textureMap;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(textureNode, images) {
    const texture = this.loadTexture(textureNode, images);
    texture.ID = textureNode.id;
    texture.name = textureNode.attrName;
    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;
    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;
    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;
    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    if ("Scaling" in textureNode) {
      const values = textureNode.Scaling.value;
      texture.repeat.x = values[0];
      texture.repeat.y = values[1];
    }
    if ("Translation" in textureNode) {
      const values = textureNode.Translation.value;
      texture.offset.x = values[0];
      texture.offset.y = values[1];
    }
    return texture;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(textureNode, images) {
    const nonNativeExtensions = /* @__PURE__ */ new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"]);
    const extension2 = textureNode.FileName.split(".").pop().toLowerCase();
    const loader = nonNativeExtensions.has(extension2) ? this.manager.getHandler(`.${extension2}`) : this.textureLoader;
    if (!loader) {
      console.warn(
        `FBXLoader: ${extension2.toUpperCase()} loader not found, creating placeholder texture for`,
        textureNode.RelativeFilename
      );
      return new Texture();
    }
    const loaderPath = loader.path;
    if (!loaderPath) {
      loader.setPath(this.textureLoader.path);
    }
    const children = connections.get(textureNode.id).children;
    let fileName;
    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {
      fileName = images[children[0].ID];
      if (fileName.indexOf("blob:") === 0 || fileName.indexOf("data:") === 0) {
        loader.setPath(void 0);
      }
    }
    const texture = loader.load(fileName);
    loader.setPath(loaderPath);
    return texture;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(textureMap) {
    const materialMap = /* @__PURE__ */ new Map();
    if ("Material" in fbxTree.Objects) {
      const materialNodes = fbxTree.Objects.Material;
      for (const nodeID in materialNodes) {
        const material = this.parseMaterial(materialNodes[nodeID], textureMap);
        if (material !== null) materialMap.set(parseInt(nodeID), material);
      }
    }
    return materialMap;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(materialNode, textureMap) {
    const ID = materialNode.id;
    const name2 = materialNode.attrName;
    let type = materialNode.ShadingModel;
    if (typeof type === "object") {
      type = type.value;
    }
    if (!connections.has(ID)) return null;
    const parameters = this.parseParameters(materialNode, textureMap, ID);
    let material;
    switch (type.toLowerCase()) {
      case "phong":
        material = new MeshPhongMaterial();
        break;
      case "lambert":
        material = new MeshLambertMaterial();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
        material = new MeshPhongMaterial();
        break;
    }
    material.setValues(parameters);
    material.name = name2;
    return material;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(materialNode, textureMap, ID) {
    const parameters = {};
    if (materialNode.BumpFactor) {
      parameters.bumpScale = materialNode.BumpFactor.value;
    }
    if (materialNode.Diffuse) {
      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Diffuse.value), SRGBColorSpace);
    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === "Color" || materialNode.DiffuseColor.type === "ColorRGB")) {
      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.DiffuseColor.value), SRGBColorSpace);
    }
    if (materialNode.DisplacementFactor) {
      parameters.displacementScale = materialNode.DisplacementFactor.value;
    }
    if (materialNode.Emissive) {
      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Emissive.value), SRGBColorSpace);
    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === "Color" || materialNode.EmissiveColor.type === "ColorRGB")) {
      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.EmissiveColor.value), SRGBColorSpace);
    }
    if (materialNode.EmissiveFactor) {
      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
    }
    if (materialNode.Opacity) {
      parameters.opacity = parseFloat(materialNode.Opacity.value);
    }
    if (parameters.opacity < 1) {
      parameters.transparent = true;
    }
    if (materialNode.ReflectionFactor) {
      parameters.reflectivity = materialNode.ReflectionFactor.value;
    }
    if (materialNode.Shininess) {
      parameters.shininess = materialNode.Shininess.value;
    }
    if (materialNode.Specular) {
      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Specular.value), SRGBColorSpace);
    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === "Color") {
      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.SpecularColor.value), SRGBColorSpace);
    }
    const scope = this;
    connections.get(ID).children.forEach(function(child) {
      const type = child.relationship;
      switch (type) {
        case "Bump":
          parameters.bumpMap = scope.getTexture(textureMap, child.ID);
          break;
        case "Maya|TEX_ao_map":
          parameters.aoMap = scope.getTexture(textureMap, child.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          parameters.map = scope.getTexture(textureMap, child.ID);
          if (parameters.map !== void 0) {
            parameters.map.colorSpace = SRGBColorSpace;
          }
          break;
        case "DisplacementColor":
          parameters.displacementMap = scope.getTexture(textureMap, child.ID);
          break;
        case "EmissiveColor":
          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);
          if (parameters.emissiveMap !== void 0) {
            parameters.emissiveMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          parameters.normalMap = scope.getTexture(textureMap, child.ID);
          break;
        case "ReflectionColor":
          parameters.envMap = scope.getTexture(textureMap, child.ID);
          if (parameters.envMap !== void 0) {
            parameters.envMap.mapping = EquirectangularReflectionMapping;
            parameters.envMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "SpecularColor":
          parameters.specularMap = scope.getTexture(textureMap, child.ID);
          if (parameters.specularMap !== void 0) {
            parameters.specularMap.colorSpace = SRGBColorSpace;
          }
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          parameters.alphaMap = scope.getTexture(textureMap, child.ID);
          parameters.transparent = true;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", type);
          break;
      }
    });
    return parameters;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(textureMap, id2) {
    if ("LayeredTexture" in fbxTree.Objects && id2 in fbxTree.Objects.LayeredTexture) {
      console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.");
      id2 = connections.get(id2).children[0].ID;
    }
    return textureMap.get(id2);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const skeletons = {};
    const morphTargets = {};
    if ("Deformer" in fbxTree.Objects) {
      const DeformerNodes = fbxTree.Objects.Deformer;
      for (const nodeID in DeformerNodes) {
        const deformerNode = DeformerNodes[nodeID];
        const relationships = connections.get(parseInt(nodeID));
        if (deformerNode.attrType === "Skin") {
          const skeleton = this.parseSkeleton(relationships, DeformerNodes);
          skeleton.ID = nodeID;
          if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported.");
          skeleton.geometryID = relationships.parents[0].ID;
          skeletons[nodeID] = skeleton;
        } else if (deformerNode.attrType === "BlendShape") {
          const morphTarget = {
            id: nodeID
          };
          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
          morphTarget.id = nodeID;
          if (relationships.parents.length > 1) console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported.");
          morphTargets[nodeID] = morphTarget;
        }
      }
    }
    return {
      skeletons,
      morphTargets
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(relationships, deformerNodes) {
    const rawBones = [];
    relationships.children.forEach(function(child) {
      const boneNode = deformerNodes[child.ID];
      if (boneNode.attrType !== "Cluster") return;
      const rawBone = {
        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      if ("Indexes" in boneNode) {
        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;
      }
      rawBones.push(rawBone);
    });
    return {
      rawBones,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(relationships, deformerNodes) {
    const rawMorphTargets = [];
    for (let i = 0; i < relationships.children.length; i++) {
      const child = relationships.children[i];
      const morphTargetNode = deformerNodes[child.ID];
      const rawMorphTarget = {
        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a
      };
      if (morphTargetNode.attrType !== "BlendShapeChannel") return;
      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {
        return child2.relationship === void 0;
      })[0].ID;
      rawMorphTargets.push(rawMorphTarget);
    }
    return rawMorphTargets;
  }
  // create the main Group() to be returned by the loader
  parseScene(deformers, geometryMap, materialMap) {
    sceneGraph = new Group();
    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
    const modelNodes = fbxTree.Objects.Model;
    const scope = this;
    modelMap.forEach(function(model) {
      const modelNode = modelNodes[model.ID];
      scope.setLookAtProperties(model, modelNode);
      const parentConnections = connections.get(model.ID).parents;
      parentConnections.forEach(function(connection) {
        const parent = modelMap.get(connection.ID);
        if (parent !== void 0) parent.add(model);
      });
      if (model.parent === null) {
        sceneGraph.add(model);
      }
    });
    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
    this.addGlobalSceneSettings();
    sceneGraph.traverse(function(node2) {
      if (node2.userData.transformData) {
        if (node2.parent) {
          node2.userData.transformData.parentMatrix = node2.parent.matrix;
          node2.userData.transformData.parentMatrixWorld = node2.parent.matrixWorld;
        }
        const transform = generateTransform(node2.userData.transformData);
        node2.applyMatrix4(transform);
        node2.updateWorldMatrix();
      }
    });
    const animations = new AnimationParser().parse();
    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
      sceneGraph.children[0].animations = animations;
      sceneGraph = sceneGraph.children[0];
    }
    sceneGraph.animations = animations;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(skeletons, geometryMap, materialMap) {
    const modelMap = /* @__PURE__ */ new Map();
    const modelNodes = fbxTree.Objects.Model;
    for (const nodeID in modelNodes) {
      const id2 = parseInt(nodeID);
      const node2 = modelNodes[nodeID];
      const relationships = connections.get(id2);
      let model = this.buildSkeleton(relationships, skeletons, id2, node2.attrName);
      if (!model) {
        switch (node2.attrType) {
          case "Camera":
            model = this.createCamera(relationships);
            break;
          case "Light":
            model = this.createLight(relationships);
            break;
          case "Mesh":
            model = this.createMesh(relationships, geometryMap, materialMap);
            break;
          case "NurbsCurve":
            model = this.createCurve(relationships, geometryMap);
            break;
          case "LimbNode":
          case "Root":
            model = new Bone();
            break;
          case "Null":
          default:
            model = new Group();
            break;
        }
        model.name = node2.attrName ? PropertyBinding.sanitizeNodeName(node2.attrName) : "";
        model.userData.originalName = node2.attrName;
        model.ID = id2;
      }
      this.getTransformData(model, node2);
      modelMap.set(id2, model);
    }
    return modelMap;
  }
  buildSkeleton(relationships, skeletons, id2, name2) {
    let bone = null;
    relationships.parents.forEach(function(parent) {
      for (const ID in skeletons) {
        const skeleton = skeletons[ID];
        skeleton.rawBones.forEach(function(rawBone, i) {
          if (rawBone.ID === parent.ID) {
            const subBone = bone;
            bone = new Bone();
            bone.matrixWorld.copy(rawBone.transformLink);
            bone.name = name2 ? PropertyBinding.sanitizeNodeName(name2) : "";
            bone.userData.originalName = name2;
            bone.ID = id2;
            skeleton.bones[i] = bone;
            if (subBone !== null) {
              bone.add(subBone);
            }
          }
        });
      }
    });
    return bone;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(relationships) {
    let model;
    let cameraAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        cameraAttribute = attr;
      }
    });
    if (cameraAttribute === void 0) {
      model = new Object3D();
    } else {
      let type = 0;
      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {
        type = 1;
      }
      let nearClippingPlane = 1;
      if (cameraAttribute.NearPlane !== void 0) {
        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;
      }
      let farClippingPlane = 1e3;
      if (cameraAttribute.FarPlane !== void 0) {
        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;
      }
      let width = window.innerWidth;
      let height = window.innerHeight;
      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {
        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;
      }
      const aspect2 = width / height;
      let fov2 = 45;
      if (cameraAttribute.FieldOfView !== void 0) {
        fov2 = cameraAttribute.FieldOfView.value;
      }
      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;
      switch (type) {
        case 0:
          model = new PerspectiveCamera(fov2, aspect2, nearClippingPlane, farClippingPlane);
          if (focalLength !== null) model.setFocalLength(focalLength);
          break;
        case 1:
          console.warn("THREE.FBXLoader: Orthographic cameras not supported yet.");
          model = new Object3D();
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + type + ".");
          model = new Object3D();
          break;
      }
    }
    return model;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(relationships) {
    let model;
    let lightAttribute;
    relationships.children.forEach(function(child) {
      const attr = fbxTree.Objects.NodeAttribute[child.ID];
      if (attr !== void 0) {
        lightAttribute = attr;
      }
    });
    if (lightAttribute === void 0) {
      model = new Object3D();
    } else {
      let type;
      if (lightAttribute.LightType === void 0) {
        type = 0;
      } else {
        type = lightAttribute.LightType.value;
      }
      let color2 = 16777215;
      if (lightAttribute.Color !== void 0) {
        color2 = ColorManagement.toWorkingColorSpace(new Color().fromArray(lightAttribute.Color.value), SRGBColorSpace);
      }
      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;
      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {
        intensity = 0;
      }
      let distance = 0;
      if (lightAttribute.FarAttenuationEnd !== void 0) {
        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {
          distance = 0;
        } else {
          distance = lightAttribute.FarAttenuationEnd.value;
        }
      }
      const decay = 1;
      switch (type) {
        case 0:
          model = new PointLight(color2, intensity, distance, decay);
          break;
        case 1:
          model = new DirectionalLight(color2, intensity);
          break;
        case 2:
          let angle = Math.PI / 3;
          if (lightAttribute.InnerAngle !== void 0) {
            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
          }
          let penumbra = 0;
          if (lightAttribute.OuterAngle !== void 0) {
            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
            penumbra = Math.max(penumbra, 1);
          }
          model = new SpotLight(color2, intensity, distance, angle, penumbra, decay);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + lightAttribute.LightType.value + ", defaulting to a PointLight.");
          model = new PointLight(color2, intensity);
          break;
      }
      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {
        model.castShadow = true;
      }
    }
    return model;
  }
  createMesh(relationships, geometryMap, materialMap) {
    let model;
    let geometry = null;
    let material = null;
    const materials = [];
    relationships.children.forEach(function(child) {
      if (geometryMap.has(child.ID)) {
        geometry = geometryMap.get(child.ID);
      }
      if (materialMap.has(child.ID)) {
        materials.push(materialMap.get(child.ID));
      }
    });
    if (materials.length > 1) {
      material = materials;
    } else if (materials.length > 0) {
      material = materials[0];
    } else {
      material = new MeshPhongMaterial({
        name: Loader.DEFAULT_MATERIAL_NAME,
        color: 13421772
      });
      materials.push(material);
    }
    if ("color" in geometry.attributes) {
      materials.forEach(function(material2) {
        material2.vertexColors = true;
      });
    }
    if (geometry.FBX_Deformer) {
      model = new SkinnedMesh(geometry, material);
      model.normalizeSkinWeights();
    } else {
      model = new Mesh(geometry, material);
    }
    return model;
  }
  createCurve(relationships, geometryMap) {
    const geometry = relationships.children.reduce(function(geo, child) {
      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);
      return geo;
    }, null);
    const material = new LineBasicMaterial({
      name: Loader.DEFAULT_MATERIAL_NAME,
      color: 3342591,
      linewidth: 1
    });
    return new Line(geometry, material);
  }
  // parse the model node for transform data
  getTransformData(model, modelNode) {
    const transformData = {};
    if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    else transformData.eulerOrder = getEulerOrder(0);
    if ("Lcl_Translation" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
    if ("PreRotation" in modelNode) transformData.preRotation = modelNode.PreRotation.value;
    if ("Lcl_Rotation" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
    if ("PostRotation" in modelNode) transformData.postRotation = modelNode.PostRotation.value;
    if ("Lcl_Scaling" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
    if ("ScalingOffset" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ("ScalingPivot" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
    if ("RotationOffset" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
    if ("RotationPivot" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
    model.userData.transformData = transformData;
  }
  setLookAtProperties(model, modelNode) {
    if ("LookAtProperty" in modelNode) {
      const children = connections.get(model.ID).children;
      children.forEach(function(child) {
        if (child.relationship === "LookAtProperty") {
          const lookAtTarget = fbxTree.Objects.Model[child.ID];
          if ("Lcl_Translation" in lookAtTarget) {
            const pos = lookAtTarget.Lcl_Translation.value;
            if (model.target !== void 0) {
              model.target.position.fromArray(pos);
              sceneGraph.add(model.target);
            } else {
              model.lookAt(new Vector3().fromArray(pos));
            }
          }
        }
      });
    }
  }
  bindSkeleton(skeletons, geometryMap, modelMap) {
    const bindMatrices = this.parsePoseNodes();
    for (const ID in skeletons) {
      const skeleton = skeletons[ID];
      const parents = connections.get(parseInt(skeleton.ID)).parents;
      parents.forEach(function(parent) {
        if (geometryMap.has(parent.ID)) {
          const geoID = parent.ID;
          const geoRelationships = connections.get(geoID);
          geoRelationships.parents.forEach(function(geoConnParent) {
            if (modelMap.has(geoConnParent.ID)) {
              const model = modelMap.get(geoConnParent.ID);
              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
            }
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const bindMatrices = {};
    if ("Pose" in fbxTree.Objects) {
      const BindPoseNode = fbxTree.Objects.Pose;
      for (const nodeID in BindPoseNode) {
        if (BindPoseNode[nodeID].attrType === "BindPose" && BindPoseNode[nodeID].NbPoseNodes > 0) {
          const poseNodes = BindPoseNode[nodeID].PoseNode;
          if (Array.isArray(poseNodes)) {
            poseNodes.forEach(function(poseNode) {
              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
            });
          } else {
            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
          }
        }
      }
    }
    return bindMatrices;
  }
  addGlobalSceneSettings() {
    if ("GlobalSettings" in fbxTree) {
      if ("AmbientColor" in fbxTree.GlobalSettings) {
        const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
        const r2 = ambientColor[0];
        const g = ambientColor[1];
        const b = ambientColor[2];
        if (r2 !== 0 || g !== 0 || b !== 0) {
          const color2 = new Color().setRGB(r2, g, b, SRGBColorSpace);
          sceneGraph.add(new AmbientLight(color2, 1));
        }
      }
      if ("UnitScaleFactor" in fbxTree.GlobalSettings) {
        sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;
      }
    }
  }
}
class GeometryParser {
  constructor() {
    this.negativeMaterialIndices = false;
  }
  // Parse nodes in FBXTree.Objects.Geometry
  parse(deformers) {
    const geometryMap = /* @__PURE__ */ new Map();
    if ("Geometry" in fbxTree.Objects) {
      const geoNodes = fbxTree.Objects.Geometry;
      for (const nodeID in geoNodes) {
        const relationships = connections.get(parseInt(nodeID));
        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
        geometryMap.set(parseInt(nodeID), geo);
      }
    }
    if (this.negativeMaterialIndices === true) {
      console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.");
    }
    return geometryMap;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(relationships, geoNode, deformers) {
    switch (geoNode.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(relationships, geoNode, deformers);
      case "NurbsCurve":
        return this.parseNurbsGeometry(geoNode);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(relationships, geoNode, deformers) {
    const skeletons = deformers.skeletons;
    const morphTargets = [];
    const modelNodes = relationships.parents.map(function(parent) {
      return fbxTree.Objects.Model[parent.ID];
    });
    if (modelNodes.length === 0) return;
    const skeleton = relationships.children.reduce(function(skeleton2, child) {
      if (skeletons[child.ID] !== void 0) skeleton2 = skeletons[child.ID];
      return skeleton2;
    }, null);
    relationships.children.forEach(function(child) {
      if (deformers.morphTargets[child.ID] !== void 0) {
        morphTargets.push(deformers.morphTargets[child.ID]);
      }
    });
    const modelNode = modelNodes[0];
    const transformData = {};
    if ("RotationOrder" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
    if ("InheritType" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
    if ("GeometricTranslation" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
    if ("GeometricRotation" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
    if ("GeometricScaling" in modelNode) transformData.scale = modelNode.GeometricScaling.value;
    const transform = generateTransform(transformData);
    return this.genGeometry(geoNode, skeleton, morphTargets, transform);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(geoNode, skeleton, morphTargets, preTransform) {
    const geo = new BufferGeometry();
    if (geoNode.attrName) geo.name = geoNode.attrName;
    const geoInfo = this.parseGeoNode(geoNode, skeleton);
    const buffers = this.genBuffers(geoInfo);
    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
    positionAttribute.applyMatrix4(preTransform);
    geo.setAttribute("position", positionAttribute);
    if (buffers.colors.length > 0) {
      geo.setAttribute("color", new Float32BufferAttribute(buffers.colors, 3));
    }
    if (skeleton) {
      geo.setAttribute("skinIndex", new Uint16BufferAttribute(buffers.weightsIndices, 4));
      geo.setAttribute("skinWeight", new Float32BufferAttribute(buffers.vertexWeights, 4));
      geo.FBX_Deformer = skeleton;
    }
    if (buffers.normal.length > 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);
      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
      normalAttribute.applyNormalMatrix(normalMatrix);
      geo.setAttribute("normal", normalAttribute);
    }
    buffers.uvs.forEach(function(uvBuffer, i) {
      const name2 = i === 0 ? "uv" : `uv${i}`;
      geo.setAttribute(name2, new Float32BufferAttribute(buffers.uvs[i], 2));
    });
    if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
      let prevMaterialIndex = buffers.materialIndex[0];
      let startIndex = 0;
      buffers.materialIndex.forEach(function(currentIndex, i) {
        if (currentIndex !== prevMaterialIndex) {
          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
          prevMaterialIndex = currentIndex;
          startIndex = i;
        }
      });
      if (geo.groups.length > 0) {
        const lastGroup = geo.groups[geo.groups.length - 1];
        const lastIndex = lastGroup.start + lastGroup.count;
        if (lastIndex !== buffers.materialIndex.length) {
          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
        }
      }
      if (geo.groups.length === 0) {
        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
      }
    }
    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
    return geo;
  }
  parseGeoNode(geoNode, skeleton) {
    const geoInfo = {};
    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];
    if (geoNode.LayerElementColor) {
      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
    }
    if (geoNode.LayerElementMaterial) {
      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
    }
    if (geoNode.LayerElementNormal) {
      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
    }
    if (geoNode.LayerElementUV) {
      geoInfo.uv = [];
      let i = 0;
      while (geoNode.LayerElementUV[i]) {
        if (geoNode.LayerElementUV[i].UV) {
          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
        }
        i++;
      }
    }
    geoInfo.weightTable = {};
    if (skeleton !== null) {
      geoInfo.skeleton = skeleton;
      skeleton.rawBones.forEach(function(rawBone, i) {
        rawBone.indices.forEach(function(index2, j) {
          if (geoInfo.weightTable[index2] === void 0) geoInfo.weightTable[index2] = [];
          geoInfo.weightTable[index2].push({
            id: i,
            weight: rawBone.weights[j]
          });
        });
      });
    }
    return geoInfo;
  }
  genBuffers(geoInfo) {
    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];
    const scope = this;
    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {
      let materialIndex;
      let endOfFace = false;
      if (vertexIndex < 0) {
        vertexIndex = vertexIndex ^ -1;
        endOfFace = true;
      }
      let weightIndices = [];
      let weights = [];
      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);
      if (geoInfo.color) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
        faceColors.push(data[0], data[1], data[2]);
      }
      if (geoInfo.skeleton) {
        if (geoInfo.weightTable[vertexIndex] !== void 0) {
          geoInfo.weightTable[vertexIndex].forEach(function(wt) {
            weights.push(wt.weight);
            weightIndices.push(wt.id);
          });
        }
        if (weights.length > 4) {
          if (!displayedWeightsWarning) {
            console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.");
            displayedWeightsWarning = true;
          }
          const wIndex = [0, 0, 0, 0];
          const Weight = [0, 0, 0, 0];
          weights.forEach(function(weight, weightIndex) {
            let currentWeight = weight;
            let currentIndex = weightIndices[weightIndex];
            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {
              if (currentWeight > comparedWeight) {
                comparedWeightArray[comparedWeightIndex] = currentWeight;
                currentWeight = comparedWeight;
                const tmp = wIndex[comparedWeightIndex];
                wIndex[comparedWeightIndex] = currentIndex;
                currentIndex = tmp;
              }
            });
          });
          weightIndices = wIndex;
          weights = Weight;
        }
        while (weights.length < 4) {
          weights.push(0);
          weightIndices.push(0);
        }
        for (let i = 0; i < 4; ++i) {
          faceWeights.push(weights[i]);
          faceWeightIndices.push(weightIndices[i]);
        }
      }
      if (geoInfo.normal) {
        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);
        faceNormals.push(data[0], data[1], data[2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
        if (materialIndex < 0) {
          scope.negativeMaterialIndices = true;
          materialIndex = 0;
        }
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, i) {
          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);
          if (faceUVs[i] === void 0) {
            faceUVs[i] = [];
          }
          faceUVs[i].push(data[0]);
          faceUVs[i].push(data[1]);
        });
      }
      faceLength++;
      if (endOfFace) {
        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
        polygonIndex++;
        faceLength = 0;
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];
      }
    });
    return buffers;
  }
  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal
  getNormalNewell(vertices) {
    const normal = new Vector3(0, 0, 0);
    for (let i = 0; i < vertices.length; i++) {
      const current = vertices[i];
      const next = vertices[(i + 1) % vertices.length];
      normal.x += (current.y - next.y) * (current.z + next.z);
      normal.y += (current.z - next.z) * (current.x + next.x);
      normal.z += (current.x - next.x) * (current.y + next.y);
    }
    normal.normalize();
    return normal;
  }
  getNormalTangentAndBitangent(vertices) {
    const normalVector = this.getNormalNewell(vertices);
    const up = Math.abs(normalVector.z) > 0.5 ? new Vector3(0, 1, 0) : new Vector3(0, 0, 1);
    const tangent = up.cross(normalVector).normalize();
    const bitangent = normalVector.clone().cross(tangent).normalize();
    return {
      normal: normalVector,
      tangent,
      bitangent
    };
  }
  flattenVertex(vertex2, normalTangent, normalBitangent) {
    return new Vector2(
      vertex2.dot(normalTangent),
      vertex2.dot(normalBitangent)
    );
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
    let triangles;
    if (faceLength > 3) {
      const vertices = [];
      const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;
      for (let i = 0; i < facePositionIndexes.length; i += 3) {
        vertices.push(
          new Vector3(
            positions[facePositionIndexes[i]],
            positions[facePositionIndexes[i + 1]],
            positions[facePositionIndexes[i + 2]]
          )
        );
      }
      const { tangent, bitangent } = this.getNormalTangentAndBitangent(vertices);
      const triangulationInput = [];
      for (const vertex2 of vertices) {
        triangulationInput.push(this.flattenVertex(vertex2, tangent, bitangent));
      }
      triangles = ShapeUtils.triangulateShape(triangulationInput, []);
    } else {
      triangles = [[0, 1, 2]];
    }
    for (const [i0, i1, i2] of triangles) {
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 2]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);
      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);
      if (geoInfo.skeleton) {
        buffers.vertexWeights.push(faceWeights[i0 * 4]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i0 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i1 * 4]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i1 * 4 + 3]);
        buffers.vertexWeights.push(faceWeights[i2 * 4]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);
        buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 3]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);
        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);
      }
      if (geoInfo.color) {
        buffers.colors.push(faceColors[i0 * 3]);
        buffers.colors.push(faceColors[i0 * 3 + 1]);
        buffers.colors.push(faceColors[i0 * 3 + 2]);
        buffers.colors.push(faceColors[i1 * 3]);
        buffers.colors.push(faceColors[i1 * 3 + 1]);
        buffers.colors.push(faceColors[i1 * 3 + 2]);
        buffers.colors.push(faceColors[i2 * 3]);
        buffers.colors.push(faceColors[i2 * 3 + 1]);
        buffers.colors.push(faceColors[i2 * 3 + 2]);
      }
      if (geoInfo.material && geoInfo.material.mappingType !== "AllSame") {
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
        buffers.materialIndex.push(materialIndex);
      }
      if (geoInfo.normal) {
        buffers.normal.push(faceNormals[i0 * 3]);
        buffers.normal.push(faceNormals[i0 * 3 + 1]);
        buffers.normal.push(faceNormals[i0 * 3 + 2]);
        buffers.normal.push(faceNormals[i1 * 3]);
        buffers.normal.push(faceNormals[i1 * 3 + 1]);
        buffers.normal.push(faceNormals[i1 * 3 + 2]);
        buffers.normal.push(faceNormals[i2 * 3]);
        buffers.normal.push(faceNormals[i2 * 3 + 1]);
        buffers.normal.push(faceNormals[i2 * 3 + 2]);
      }
      if (geoInfo.uv) {
        geoInfo.uv.forEach(function(uv, j) {
          if (buffers.uvs[j] === void 0) buffers.uvs[j] = [];
          buffers.uvs[j].push(faceUVs[j][i0 * 2]);
          buffers.uvs[j].push(faceUVs[j][i0 * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i1 * 2]);
          buffers.uvs[j].push(faceUVs[j][i1 * 2 + 1]);
          buffers.uvs[j].push(faceUVs[j][i2 * 2]);
          buffers.uvs[j].push(faceUVs[j][i2 * 2 + 1]);
        });
      }
    }
  }
  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
    if (morphTargets.length === 0) return;
    parentGeo.morphTargetsRelative = true;
    parentGeo.morphAttributes.position = [];
    const scope = this;
    morphTargets.forEach(function(morphTarget) {
      morphTarget.rawTargets.forEach(function(rawTarget) {
        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];
        if (morphGeoNode !== void 0) {
          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
        }
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name2) {
    const basePositions = parentGeoNode.Vertices !== void 0 ? parentGeoNode.Vertices.a : [];
    const baseIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];
    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];
    const morphIndices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];
    const length = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array(length);
    for (let i = 0; i < morphIndices.length; i++) {
      const morphIndex = morphIndices[i] * 3;
      morphPositions[morphIndex] = morphPositionsSparse[i * 3];
      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
    }
    const morphGeoInfo = {
      vertexIndices: baseIndices,
      vertexPositions: morphPositions,
      baseVertexPositions: basePositions
    };
    const morphBuffers = this.genBuffers(morphGeoInfo);
    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
    positionAttribute.name = name2 || morphGeoNode.attrName;
    positionAttribute.applyMatrix4(preTransform);
    parentGeo.morphAttributes.position.push(positionAttribute);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(NormalNode) {
    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer = NormalNode.Normals.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      if ("NormalIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalIndex.a;
      } else if ("NormalsIndex" in NormalNode) {
        indexBuffer = NormalNode.NormalsIndex.a;
      }
    }
    return {
      dataSize: 3,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(UVNode) {
    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer = UVNode.UV.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = UVNode.UVIndex.a;
    }
    return {
      dataSize: 2,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(ColorNode) {
    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer = ColorNode.Colors.a;
    let indexBuffer = [];
    if (referenceType === "IndexToDirect") {
      indexBuffer = ColorNode.ColorIndex.a;
    }
    for (let i = 0, c = new Color(); i < buffer.length; i += 4) {
      c.fromArray(buffer, i);
      ColorManagement.toWorkingColorSpace(c, SRGBColorSpace);
      c.toArray(buffer, i);
    }
    return {
      dataSize: 4,
      buffer,
      indices: indexBuffer,
      mappingType,
      referenceType
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(MaterialNode) {
    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;
    if (mappingType === "NoMappingInformation") {
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType
      };
    }
    const materialIndexBuffer = MaterialNode.Materials.a;
    const materialIndices = [];
    for (let i = 0; i < materialIndexBuffer.length; ++i) {
      materialIndices.push(i);
    }
    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType,
      referenceType
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(geoNode) {
    const order2 = parseInt(geoNode.Order);
    if (isNaN(order2)) {
      console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", geoNode.Order, geoNode.id);
      return new BufferGeometry();
    }
    const degree = order2 - 1;
    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;
    for (let i = 0, l2 = pointsValues.length; i < l2; i += 4) {
      controlPoints.push(new Vector4().fromArray(pointsValues, i));
    }
    let startKnot, endKnot;
    if (geoNode.Form === "Closed") {
      controlPoints.push(controlPoints[0]);
    } else if (geoNode.Form === "Periodic") {
      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;
      for (let i = 0; i < degree; ++i) {
        controlPoints.push(controlPoints[i]);
      }
    }
    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
    const points = curve.getPoints(controlPoints.length * 12);
    return new BufferGeometry().setFromPoints(points);
  }
}
class AnimationParser {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const animationClips = [];
    const rawClips = this.parseClips();
    if (rawClips !== void 0) {
      for (const key in rawClips) {
        const rawClip = rawClips[key];
        const clip = this.addClip(rawClip);
        animationClips.push(clip);
      }
    }
    return animationClips;
  }
  parseClips() {
    if (fbxTree.Objects.AnimationCurve === void 0) return void 0;
    const curveNodesMap = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(curveNodesMap);
    const layersMap = this.parseAnimationLayers(curveNodesMap);
    const rawClips = this.parseAnimStacks(layersMap);
    return rawClips;
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
    const curveNodesMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawCurveNodes) {
      const rawCurveNode = rawCurveNodes[nodeID];
      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const curveNode = {
          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {}
        };
        curveNodesMap.set(curveNode.id, curveNode);
      }
    }
    return curveNodesMap;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(curveNodesMap) {
    const rawCurves = fbxTree.Objects.AnimationCurve;
    for (const nodeID in rawCurves) {
      const animationCurve = {
        id: rawCurves[nodeID].id,
        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
        values: rawCurves[nodeID].KeyValueFloat.a
      };
      const relationships = connections.get(animationCurve.id);
      if (relationships !== void 0) {
        const animationCurveID = relationships.parents[0].ID;
        const animationCurveRelationship = relationships.parents[0].relationship;
        if (animationCurveRelationship.match(/X/)) {
          curveNodesMap.get(animationCurveID).curves["x"] = animationCurve;
        } else if (animationCurveRelationship.match(/Y/)) {
          curveNodesMap.get(animationCurveID).curves["y"] = animationCurve;
        } else if (animationCurveRelationship.match(/Z/)) {
          curveNodesMap.get(animationCurveID).curves["z"] = animationCurve;
        } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {
          curveNodesMap.get(animationCurveID).curves["morph"] = animationCurve;
        }
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(curveNodesMap) {
    const rawLayers = fbxTree.Objects.AnimationLayer;
    const layersMap = /* @__PURE__ */ new Map();
    for (const nodeID in rawLayers) {
      const layerCurveNodes = [];
      const connection = connections.get(parseInt(nodeID));
      if (connection !== void 0) {
        const children = connection.children;
        children.forEach(function(child, i) {
          if (curveNodesMap.has(child.ID)) {
            const curveNode = curveNodesMap.get(child.ID);
            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {
              if (layerCurveNodes[i] === void 0) {
                const modelID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                if (modelID !== void 0) {
                  const rawModel = fbxTree.Objects.Model[modelID.toString()];
                  if (rawModel === void 0) {
                    console.warn("THREE.FBXLoader: Encountered a unused curve.", child);
                    return;
                  }
                  const node2 = {
                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                    ID: rawModel.id,
                    initialPosition: [0, 0, 0],
                    initialRotation: [0, 0, 0],
                    initialScale: [1, 1, 1]
                  };
                  sceneGraph.traverse(function(child2) {
                    if (child2.ID === rawModel.id) {
                      node2.transform = child2.matrix;
                      if (child2.userData.transformData) node2.eulerOrder = child2.userData.transformData.eulerOrder;
                    }
                  });
                  if (!node2.transform) node2.transform = new Matrix4();
                  if ("PreRotation" in rawModel) node2.preRotation = rawModel.PreRotation.value;
                  if ("PostRotation" in rawModel) node2.postRotation = rawModel.PostRotation.value;
                  layerCurveNodes[i] = node2;
                }
              }
              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;
            } else if (curveNode.curves.morph !== void 0) {
              if (layerCurveNodes[i] === void 0) {
                const deformerID = connections.get(child.ID).parents.filter(function(parent) {
                  return parent.relationship !== void 0;
                })[0].ID;
                const morpherID = connections.get(deformerID).parents[0].ID;
                const geoID = connections.get(morpherID).parents[0].ID;
                const modelID = connections.get(geoID).parents[0].ID;
                const rawModel = fbxTree.Objects.Model[modelID];
                const node2 = {
                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : "",
                  morphName: fbxTree.Objects.Deformer[deformerID].attrName
                };
                layerCurveNodes[i] = node2;
              }
              layerCurveNodes[i][curveNode.attr] = curveNode;
            }
          }
        });
        layersMap.set(parseInt(nodeID), layerCurveNodes);
      }
    }
    return layersMap;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(layersMap) {
    const rawStacks = fbxTree.Objects.AnimationStack;
    const rawClips = {};
    for (const nodeID in rawStacks) {
      const children = connections.get(parseInt(nodeID)).children;
      if (children.length > 1) {
        console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      }
      const layer = layersMap.get(children[0].ID);
      rawClips[nodeID] = {
        name: rawStacks[nodeID].attrName,
        layer
      };
    }
    return rawClips;
  }
  addClip(rawClip) {
    let tracks = [];
    const scope = this;
    rawClip.layer.forEach(function(rawTracks) {
      tracks = tracks.concat(scope.generateTracks(rawTracks));
    });
    return new AnimationClip(rawClip.name, -1, tracks);
  }
  generateTracks(rawTracks) {
    const tracks = [];
    let initialPosition = new Vector3();
    let initialScale = new Vector3();
    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, new Quaternion(), initialScale);
    initialPosition = initialPosition.toArray();
    initialScale = initialScale.toArray();
    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {
      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, "position");
      if (positionTrack !== void 0) tracks.push(positionTrack);
    }
    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {
      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
      if (rotationTrack !== void 0) tracks.push(rotationTrack);
    }
    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {
      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, "scale");
      if (scaleTrack !== void 0) tracks.push(scaleTrack);
    }
    if (rawTracks.DeformPercent !== void 0) {
      const morphTrack = this.generateMorphTrack(rawTracks);
      if (morphTrack !== void 0) tracks.push(morphTrack);
    }
    return tracks;
  }
  generateVectorTrack(modelName, curves, initialValue, type) {
    const times = this.getTimesForAllAxes(curves);
    const values = this.getKeyframeTrackValues(times, curves, initialValue);
    return new VectorKeyframeTrack(modelName + "." + type, times, values);
  }
  generateRotationTrack(modelName, curves, preRotation, postRotation, eulerOrder) {
    let times;
    let values;
    if (curves.x !== void 0 && curves.y !== void 0 && curves.z !== void 0) {
      const result = this.interpolateRotations(curves.x, curves.y, curves.z, eulerOrder);
      times = result[0];
      values = result[1];
    }
    const defaultEulerOrder = getEulerOrder(0);
    if (preRotation !== void 0) {
      preRotation = preRotation.map(MathUtils.degToRad);
      preRotation.push(defaultEulerOrder);
      preRotation = new Euler().fromArray(preRotation);
      preRotation = new Quaternion().setFromEuler(preRotation);
    }
    if (postRotation !== void 0) {
      postRotation = postRotation.map(MathUtils.degToRad);
      postRotation.push(defaultEulerOrder);
      postRotation = new Euler().fromArray(postRotation);
      postRotation = new Quaternion().setFromEuler(postRotation).invert();
    }
    const quaternion = new Quaternion();
    const euler = new Euler();
    const quaternionValues = [];
    if (!values || !times) return new QuaternionKeyframeTrack(modelName + ".quaternion", [0], [0]);
    for (let i = 0; i < values.length; i += 3) {
      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
      quaternion.setFromEuler(euler);
      if (preRotation !== void 0) quaternion.premultiply(preRotation);
      if (postRotation !== void 0) quaternion.multiply(postRotation);
      if (i > 2) {
        const prevQuat = new Quaternion().fromArray(
          quaternionValues,
          (i - 3) / 3 * 4
        );
        if (prevQuat.dot(quaternion) < 0) {
          quaternion.set(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);
        }
      }
      quaternion.toArray(quaternionValues, i / 3 * 4);
    }
    return new QuaternionKeyframeTrack(modelName + ".quaternion", times, quaternionValues);
  }
  generateMorphTrack(rawTracks) {
    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map(function(val) {
      return val / 100;
    });
    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
    return new NumberKeyframeTrack(rawTracks.modelName + ".morphTargetInfluences[" + morphNum + "]", curves.times, values);
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(curves) {
    let times = [];
    if (curves.x !== void 0) times = times.concat(curves.x.times);
    if (curves.y !== void 0) times = times.concat(curves.y.times);
    if (curves.z !== void 0) times = times.concat(curves.z.times);
    times = times.sort(function(a, b) {
      return a - b;
    });
    if (times.length > 1) {
      let targetIndex = 1;
      let lastValue = times[0];
      for (let i = 1; i < times.length; i++) {
        const currentValue = times[i];
        if (currentValue !== lastValue) {
          times[targetIndex] = currentValue;
          lastValue = currentValue;
          targetIndex++;
        }
      }
      times = times.slice(0, targetIndex);
    }
    return times;
  }
  getKeyframeTrackValues(times, curves, initialValue) {
    const prevValue = initialValue;
    const values = [];
    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;
    times.forEach(function(time) {
      if (curves.x) xIndex = curves.x.times.indexOf(time);
      if (curves.y) yIndex = curves.y.times.indexOf(time);
      if (curves.z) zIndex = curves.z.times.indexOf(time);
      if (xIndex !== -1) {
        const xValue = curves.x.values[xIndex];
        values.push(xValue);
        prevValue[0] = xValue;
      } else {
        values.push(prevValue[0]);
      }
      if (yIndex !== -1) {
        const yValue = curves.y.values[yIndex];
        values.push(yValue);
        prevValue[1] = yValue;
      } else {
        values.push(prevValue[1]);
      }
      if (zIndex !== -1) {
        const zValue = curves.z.values[zIndex];
        values.push(zValue);
        prevValue[2] = zValue;
      } else {
        values.push(prevValue[2]);
      }
    });
    return values;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(curvex, curvey, curvez, eulerOrder) {
    const times = [];
    const values = [];
    times.push(curvex.times[0]);
    values.push(MathUtils.degToRad(curvex.values[0]));
    values.push(MathUtils.degToRad(curvey.values[0]));
    values.push(MathUtils.degToRad(curvez.values[0]));
    for (let i = 1; i < curvex.values.length; i++) {
      const initialValue = [
        curvex.values[i - 1],
        curvey.values[i - 1],
        curvez.values[i - 1]
      ];
      if (isNaN(initialValue[0]) || isNaN(initialValue[1]) || isNaN(initialValue[2])) {
        continue;
      }
      const initialValueRad = initialValue.map(MathUtils.degToRad);
      const currentValue = [
        curvex.values[i],
        curvey.values[i],
        curvez.values[i]
      ];
      if (isNaN(currentValue[0]) || isNaN(currentValue[1]) || isNaN(currentValue[2])) {
        continue;
      }
      const currentValueRad = currentValue.map(MathUtils.degToRad);
      const valuesSpan = [
        currentValue[0] - initialValue[0],
        currentValue[1] - initialValue[1],
        currentValue[2] - initialValue[2]
      ];
      const absoluteSpan = [
        Math.abs(valuesSpan[0]),
        Math.abs(valuesSpan[1]),
        Math.abs(valuesSpan[2])
      ];
      if (absoluteSpan[0] >= 180 || absoluteSpan[1] >= 180 || absoluteSpan[2] >= 180) {
        const maxAbsSpan = Math.max(...absoluteSpan);
        const numSubIntervals = maxAbsSpan / 180;
        const E1 = new Euler(...initialValueRad, eulerOrder);
        const E2 = new Euler(...currentValueRad, eulerOrder);
        const Q1 = new Quaternion().setFromEuler(E1);
        const Q2 = new Quaternion().setFromEuler(E2);
        if (Q1.dot(Q2)) {
          Q2.set(-Q2.x, -Q2.y, -Q2.z, -Q2.w);
        }
        const initialTime = curvex.times[i - 1];
        const timeSpan = curvex.times[i] - initialTime;
        const Q3 = new Quaternion();
        const E3 = new Euler();
        for (let t2 = 0; t2 < 1; t2 += 1 / numSubIntervals) {
          Q3.copy(Q1.clone().slerp(Q2.clone(), t2));
          times.push(initialTime + t2 * timeSpan);
          E3.setFromQuaternion(Q3, eulerOrder);
          values.push(E3.x);
          values.push(E3.y);
          values.push(E3.z);
        }
      } else {
        times.push(curvex.times[i]);
        values.push(MathUtils.degToRad(curvex.values[i]));
        values.push(MathUtils.degToRad(curvey.values[i]));
        values.push(MathUtils.degToRad(curvez.values[i]));
      }
    }
    return [times, values];
  }
}
class TextParser {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(node2) {
    this.nodeStack.push(node2);
    this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop();
    this.currentIndent -= 1;
  }
  setCurrentProp(val, name2) {
    this.currentProp = val;
    this.currentPropName = name2;
  }
  parse(text2) {
    this.currentIndent = 0;
    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = "";
    const scope = this;
    const split = text2.split(/[\r\n]+/);
    split.forEach(function(line, i) {
      const matchComment = line.match(/^[\s\t]*;/);
      const matchEmpty = line.match(/^[\s\t]*$/);
      if (matchComment || matchEmpty) return;
      const matchBeginning = line.match("^\\t{" + scope.currentIndent + "}(\\w+):(.*){", "");
      const matchProperty = line.match("^\\t{" + scope.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)");
      const matchEnd = line.match("^\\t{" + (scope.currentIndent - 1) + "}}");
      if (matchBeginning) {
        scope.parseNodeBegin(line, matchBeginning);
      } else if (matchProperty) {
        scope.parseNodeProperty(line, matchProperty, split[++i]);
      } else if (matchEnd) {
        scope.popStack();
      } else if (line.match(/^[^\s\t}]/)) {
        scope.parseNodePropertyContinued(line);
      }
    });
    return this.allNodes;
  }
  parseNodeBegin(line, property) {
    const nodeName = property[1].trim().replace(/^"/, "").replace(/"$/, "");
    const nodeAttrs = property[2].split(",").map(function(attr) {
      return attr.trim().replace(/^"/, "").replace(/"$/, "");
    });
    const node2 = { name: nodeName };
    const attrs = this.parseNodeAttr(nodeAttrs);
    const currentNode = this.getCurrentNode();
    if (this.currentIndent === 0) {
      this.allNodes.add(nodeName, node2);
    } else {
      if (nodeName in currentNode) {
        if (nodeName === "PoseNode") {
          currentNode.PoseNode.push(node2);
        } else if (currentNode[nodeName].id !== void 0) {
          currentNode[nodeName] = {};
          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
        }
        if (attrs.id !== "") currentNode[nodeName][attrs.id] = node2;
      } else if (typeof attrs.id === "number") {
        currentNode[nodeName] = {};
        currentNode[nodeName][attrs.id] = node2;
      } else if (nodeName !== "Properties70") {
        if (nodeName === "PoseNode") currentNode[nodeName] = [node2];
        else currentNode[nodeName] = node2;
      }
    }
    if (typeof attrs.id === "number") node2.id = attrs.id;
    if (attrs.name !== "") node2.attrName = attrs.name;
    if (attrs.type !== "") node2.attrType = attrs.type;
    this.pushStack(node2);
  }
  parseNodeAttr(attrs) {
    let id2 = attrs[0];
    if (attrs[0] !== "") {
      id2 = parseInt(attrs[0]);
      if (isNaN(id2)) {
        id2 = attrs[0];
      }
    }
    let name2 = "", type = "";
    if (attrs.length > 1) {
      name2 = attrs[1].replace(/^(\w+)::/, "");
      type = attrs[2];
    }
    return { id: id2, name: name2, type };
  }
  parseNodeProperty(line, property, contentLine) {
    let propName = property[1].replace(/^"/, "").replace(/"$/, "").trim();
    let propValue = property[2].replace(/^"/, "").replace(/"$/, "").trim();
    if (propName === "Content" && propValue === ",") {
      propValue = contentLine.replace(/"/g, "").replace(/,$/, "").trim();
    }
    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;
    if (parentName === "Properties70") {
      this.parseNodeSpecialProperty(line, propName, propValue);
      return;
    }
    if (propName === "C") {
      const connProps = propValue.split(",").slice(1);
      const from = parseInt(connProps[0]);
      const to = parseInt(connProps[1]);
      let rest = propValue.split(",").slice(3);
      rest = rest.map(function(elem) {
        return elem.trim().replace(/^"/, "");
      });
      propName = "connections";
      propValue = [from, to];
      append(propValue, rest);
      if (currentNode[propName] === void 0) {
        currentNode[propName] = [];
      }
    }
    if (propName === "Node") currentNode.id = propValue;
    if (propName in currentNode && Array.isArray(currentNode[propName])) {
      currentNode[propName].push(propValue);
    } else {
      if (propName !== "a") currentNode[propName] = propValue;
      else currentNode.a = propValue;
    }
    this.setCurrentProp(currentNode, propName);
    if (propName === "a" && propValue.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(propValue);
    }
  }
  parseNodePropertyContinued(line) {
    const currentNode = this.getCurrentNode();
    currentNode.a += line;
    if (line.slice(-1) !== ",") {
      currentNode.a = parseNumberArray(currentNode.a);
    }
  }
  // parse "Property70"
  parseNodeSpecialProperty(line, propName, propValue) {
    const props = propValue.split('",').map(function(prop) {
      return prop.trim().replace(/^\"/, "").replace(/\s/, "_");
    });
    const innerPropName = props[0];
    const innerPropType1 = props[1];
    const innerPropType2 = props[2];
    const innerPropFlag = props[3];
    let innerPropValue = props[4];
    switch (innerPropType1) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        innerPropValue = parseFloat(innerPropValue);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        innerPropValue = parseNumberArray(innerPropValue);
        break;
    }
    this.getPrevNode()[innerPropName] = {
      "type": innerPropType1,
      "type2": innerPropType2,
      "flag": innerPropFlag,
      "value": innerPropValue
    };
    this.setCurrentProp(this.getPrevNode(), innerPropName);
  }
}
class BinaryParser {
  parse(buffer) {
    const reader = new BinaryReader(buffer);
    reader.skip(23);
    const version2 = reader.getUint32();
    if (version2 < 6400) {
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + version2);
    }
    const allNodes = new FBXTree();
    while (!this.endOfContent(reader)) {
      const node2 = this.parseNode(reader, version2);
      if (node2 !== null) allNodes.add(node2.name, node2);
    }
    return allNodes;
  }
  // Check if reader has reached the end of content.
  endOfContent(reader) {
    if (reader.size() % 16 === 0) {
      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();
    } else {
      return reader.getOffset() + 160 + 16 >= reader.size();
    }
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(reader, version2) {
    const node2 = {};
    const endOffset = version2 >= 7500 ? reader.getUint64() : reader.getUint32();
    const numProperties = version2 >= 7500 ? reader.getUint64() : reader.getUint32();
    version2 >= 7500 ? reader.getUint64() : reader.getUint32();
    const nameLen = reader.getUint8();
    const name2 = reader.getString(nameLen);
    if (endOffset === 0) return null;
    const propertyList = [];
    for (let i = 0; i < numProperties; i++) {
      propertyList.push(this.parseProperty(reader));
    }
    const id2 = propertyList.length > 0 ? propertyList[0] : "";
    const attrName = propertyList.length > 1 ? propertyList[1] : "";
    const attrType = propertyList.length > 2 ? propertyList[2] : "";
    node2.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;
    while (endOffset > reader.getOffset()) {
      const subNode = this.parseNode(reader, version2);
      if (subNode !== null) this.parseSubNode(name2, node2, subNode);
    }
    node2.propertyList = propertyList;
    if (typeof id2 === "number") node2.id = id2;
    if (attrName !== "") node2.attrName = attrName;
    if (attrType !== "") node2.attrType = attrType;
    if (name2 !== "") node2.name = name2;
    return node2;
  }
  parseSubNode(name2, node2, subNode) {
    if (subNode.singleProperty === true) {
      const value = subNode.propertyList[0];
      if (Array.isArray(value)) {
        node2[subNode.name] = subNode;
        subNode.a = value;
      } else {
        node2[subNode.name] = value;
      }
    } else if (name2 === "Connections" && subNode.name === "C") {
      const array = [];
      subNode.propertyList.forEach(function(property, i) {
        if (i !== 0) array.push(property);
      });
      if (node2.connections === void 0) {
        node2.connections = [];
      }
      node2.connections.push(array);
    } else if (subNode.name === "Properties70") {
      const keys2 = Object.keys(subNode);
      keys2.forEach(function(key) {
        node2[key] = subNode[key];
      });
    } else if (name2 === "Properties70" && subNode.name === "P") {
      let innerPropName = subNode.propertyList[0];
      let innerPropType1 = subNode.propertyList[1];
      const innerPropType2 = subNode.propertyList[2];
      const innerPropFlag = subNode.propertyList[3];
      let innerPropValue;
      if (innerPropName.indexOf("Lcl ") === 0) innerPropName = innerPropName.replace("Lcl ", "Lcl_");
      if (innerPropType1.indexOf("Lcl ") === 0) innerPropType1 = innerPropType1.replace("Lcl ", "Lcl_");
      if (innerPropType1 === "Color" || innerPropType1 === "ColorRGB" || innerPropType1 === "Vector" || innerPropType1 === "Vector3D" || innerPropType1.indexOf("Lcl_") === 0) {
        innerPropValue = [
          subNode.propertyList[4],
          subNode.propertyList[5],
          subNode.propertyList[6]
        ];
      } else {
        innerPropValue = subNode.propertyList[4];
      }
      node2[innerPropName] = {
        "type": innerPropType1,
        "type2": innerPropType2,
        "flag": innerPropFlag,
        "value": innerPropValue
      };
    } else if (node2[subNode.name] === void 0) {
      if (typeof subNode.id === "number") {
        node2[subNode.name] = {};
        node2[subNode.name][subNode.id] = subNode;
      } else {
        node2[subNode.name] = subNode;
      }
    } else {
      if (subNode.name === "PoseNode") {
        if (!Array.isArray(node2[subNode.name])) {
          node2[subNode.name] = [node2[subNode.name]];
        }
        node2[subNode.name].push(subNode);
      } else if (node2[subNode.name][subNode.id] === void 0) {
        node2[subNode.name][subNode.id] = subNode;
      }
    }
  }
  parseProperty(reader) {
    const type = reader.getString(1);
    let length;
    switch (type) {
      case "C":
        return reader.getBoolean();
      case "D":
        return reader.getFloat64();
      case "F":
        return reader.getFloat32();
      case "I":
        return reader.getInt32();
      case "L":
        return reader.getInt64();
      case "R":
        length = reader.getUint32();
        return reader.getArrayBuffer(length);
      case "S":
        length = reader.getUint32();
        return reader.getString(length);
      case "Y":
        return reader.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const arrayLength = reader.getUint32();
        const encoding = reader.getUint32();
        const compressedLength = reader.getUint32();
        if (encoding === 0) {
          switch (type) {
            case "b":
            case "c":
              return reader.getBooleanArray(arrayLength);
            case "d":
              return reader.getFloat64Array(arrayLength);
            case "f":
              return reader.getFloat32Array(arrayLength);
            case "i":
              return reader.getInt32Array(arrayLength);
            case "l":
              return reader.getInt64Array(arrayLength);
          }
        }
        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));
        const reader2 = new BinaryReader(data.buffer);
        switch (type) {
          case "b":
          case "c":
            return reader2.getBooleanArray(arrayLength);
          case "d":
            return reader2.getFloat64Array(arrayLength);
          case "f":
            return reader2.getFloat32Array(arrayLength);
          case "i":
            return reader2.getInt32Array(arrayLength);
          case "l":
            return reader2.getInt64Array(arrayLength);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + type);
    }
  }
}
class BinaryReader {
  constructor(buffer, littleEndian) {
    this.dv = new DataView(buffer);
    this.offset = 0;
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    this._textDecoder = new TextDecoder();
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(length) {
    this.offset += length;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getBoolean());
    }
    return a;
  }
  getUint8() {
    const value = this.dv.getUint8(this.offset);
    this.offset += 1;
    return value;
  }
  getInt16() {
    const value = this.dv.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  getInt32() {
    const value = this.dv.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getInt32Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getInt32());
    }
    return a;
  }
  getUint32() {
    const value = this.dv.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    if (high & 2147483648) {
      high = ~high & 4294967295;
      low = ~low & 4294967295;
      if (low === 4294967295) high = high + 1 & 4294967295;
      low = low + 1 & 4294967295;
      return -(high * 4294967296 + low);
    }
    return high * 4294967296 + low;
  }
  getInt64Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getInt64());
    }
    return a;
  }
  // Note: see getInt64() comment
  getUint64() {
    let low, high;
    if (this.littleEndian) {
      low = this.getUint32();
      high = this.getUint32();
    } else {
      high = this.getUint32();
      low = this.getUint32();
    }
    return high * 4294967296 + low;
  }
  getFloat32() {
    const value = this.dv.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  getFloat32Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getFloat32());
    }
    return a;
  }
  getFloat64() {
    const value = this.dv.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  getFloat64Array(size) {
    const a = [];
    for (let i = 0; i < size; i++) {
      a.push(this.getFloat64());
    }
    return a;
  }
  getArrayBuffer(size) {
    const value = this.dv.buffer.slice(this.offset, this.offset + size);
    this.offset += size;
    return value;
  }
  getString(size) {
    const start = this.offset;
    let a = new Uint8Array(this.dv.buffer, start, size);
    this.skip(size);
    const nullByte = a.indexOf(0);
    if (nullByte >= 0) a = new Uint8Array(this.dv.buffer, start, nullByte);
    return this._textDecoder.decode(a);
  }
}
class FBXTree {
  add(key, val) {
    this[key] = val;
  }
}
function isFbxFormatBinary(buffer) {
  const CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}
function isFbxFormatASCII(text2) {
  const CORRECT = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
  let cursor = 0;
  function read(offset) {
    const result = text2[offset - 1];
    text2 = text2.slice(cursor + offset);
    cursor++;
    return result;
  }
  for (let i = 0; i < CORRECT.length; ++i) {
    const num = read(1);
    if (num === CORRECT[i]) {
      return false;
    }
  }
  return true;
}
function getFbxVersion(text2) {
  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text2.match(versionRegExp);
  if (match) {
    const version2 = parseInt(match[1]);
    return version2;
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function convertFBXTimeToSeconds(time) {
  return time / 46186158e3;
}
const dataArray = [];
function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  let index2;
  switch (infoObject.mappingType) {
    case "ByPolygonVertex":
      index2 = polygonVertexIndex;
      break;
    case "ByPolygon":
      index2 = polygonIndex;
      break;
    case "ByVertice":
      index2 = vertexIndex;
      break;
    case "AllSame":
      index2 = infoObject.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + infoObject.mappingType);
  }
  if (infoObject.referenceType === "IndexToDirect") index2 = infoObject.indices[index2];
  const from = index2 * infoObject.dataSize;
  const to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}
const tempEuler = new Euler();
const tempVec = new Vector3();
function generateTransform(transformData) {
  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();
  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();
  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();
  const inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));
  const defaultEulerOrder = getEulerOrder(0);
  if (transformData.preRotation) {
    const array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(defaultEulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.rotation) {
    const array = transformData.rotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder || defaultEulerOrder);
    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }
  if (transformData.postRotation) {
    const array = transformData.postRotation.map(MathUtils.degToRad);
    array.push(defaultEulerOrder);
    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
    lPostRotationM.invert();
  }
  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));
  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));
  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }
  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);
  const lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX);
  const lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  const lLSM = lScalingM;
  const lGlobalRS = new Matrix4();
  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }
  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS);
  lTransform.premultiply(lParentGX.invert());
  return lTransform;
}
function getEulerOrder(order2) {
  order2 = order2 || 0;
  const enums = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  if (order2 === 6) {
    console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.");
    return enums[0];
  }
  return enums[order2];
}
function parseNumberArray(value) {
  const array = value.split(",").map(function(val) {
    return parseFloat(val);
  });
  return array;
}
function convertArrayBufferToString(buffer, from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = buffer.byteLength;
  return new TextDecoder().decode(new Uint8Array(buffer, from, to));
}
function append(a, b) {
  for (let i = 0, j = a.length, l2 = b.length; i < l2; i++, j++) {
    a[j] = b[i];
  }
}
function slice(a, b, from, to) {
  for (let i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }
  return a;
}
class RoomEnvironment extends Scene {
  constructor() {
    super();
    const geometry = new BoxGeometry();
    geometry.deleteAttribute("uv");
    const roomMaterial = new MeshStandardMaterial({ side: BackSide });
    const boxMaterial = new MeshStandardMaterial();
    const mainLight = new PointLight(16777215, 900, 28, 2);
    mainLight.position.set(0.418, 16.199, 0.3);
    this.add(mainLight);
    const room = new Mesh(geometry, roomMaterial);
    room.position.set(-0.757, 13.219, 0.717);
    room.scale.set(31.713, 28.305, 28.591);
    this.add(room);
    const box1 = new Mesh(geometry, boxMaterial);
    box1.position.set(-10.906, 2.009, 1.846);
    box1.rotation.set(0, -0.195, 0);
    box1.scale.set(2.328, 7.905, 4.651);
    this.add(box1);
    const box2 = new Mesh(geometry, boxMaterial);
    box2.position.set(-5.607, -0.754, -0.758);
    box2.rotation.set(0, 0.994, 0);
    box2.scale.set(1.97, 1.534, 3.955);
    this.add(box2);
    const box3 = new Mesh(geometry, boxMaterial);
    box3.position.set(6.167, 0.857, 7.803);
    box3.rotation.set(0, 0.561, 0);
    box3.scale.set(3.927, 6.285, 3.687);
    this.add(box3);
    const box4 = new Mesh(geometry, boxMaterial);
    box4.position.set(-2.017, 0.018, 6.124);
    box4.rotation.set(0, 0.333, 0);
    box4.scale.set(2.002, 4.566, 2.064);
    this.add(box4);
    const box5 = new Mesh(geometry, boxMaterial);
    box5.position.set(2.291, -0.756, -2.621);
    box5.rotation.set(0, -0.286, 0);
    box5.scale.set(1.546, 1.552, 1.496);
    this.add(box5);
    const box6 = new Mesh(geometry, boxMaterial);
    box6.position.set(-2.193, -0.369, -5.547);
    box6.rotation.set(0, 0.516, 0);
    box6.scale.set(3.875, 3.487, 2.986);
    this.add(box6);
    const light1 = new Mesh(geometry, createAreaLightMaterial(50));
    light1.position.set(-16.116, 14.37, 8.208);
    light1.scale.set(0.1, 2.428, 2.739);
    this.add(light1);
    const light2 = new Mesh(geometry, createAreaLightMaterial(50));
    light2.position.set(-16.109, 18.021, -8.207);
    light2.scale.set(0.1, 2.425, 2.751);
    this.add(light2);
    const light3 = new Mesh(geometry, createAreaLightMaterial(17));
    light3.position.set(14.904, 12.198, -1.832);
    light3.scale.set(0.15, 4.265, 6.331);
    this.add(light3);
    const light4 = new Mesh(geometry, createAreaLightMaterial(43));
    light4.position.set(-0.462, 8.89, 14.52);
    light4.scale.set(4.38, 5.441, 0.088);
    this.add(light4);
    const light5 = new Mesh(geometry, createAreaLightMaterial(20));
    light5.position.set(3.235, 11.486, -12.541);
    light5.scale.set(2.5, 2, 0.1);
    this.add(light5);
    const light6 = new Mesh(geometry, createAreaLightMaterial(100));
    light6.position.set(0, 20, 0);
    light6.scale.set(1, 0.1, 1);
    this.add(light6);
  }
  dispose() {
    const resources = /* @__PURE__ */ new Set();
    this.traverse((object) => {
      if (object.isMesh) {
        resources.add(object.geometry);
        resources.add(object.material);
      }
    });
    for (const resource of resources) {
      resource.dispose();
    }
  }
}
function createAreaLightMaterial(intensity) {
  const material = new MeshBasicMaterial();
  material.color.setScalar(intensity);
  return material;
}
var Stats = function() {
  var mode = 0;
  var container = document.createElement("div");
  container.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
  container.addEventListener("click", function(event) {
    event.preventDefault();
    showPanel(++mode % container.children.length);
  }, false);
  function addPanel(panel) {
    container.appendChild(panel.dom);
    return panel;
  }
  function showPanel(id2) {
    for (var i = 0; i < container.children.length; i++) {
      container.children[i].style.display = i === id2 ? "block" : "none";
    }
    mode = id2;
  }
  var beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0;
  var fpsPanel = addPanel(new Stats.Panel("FPS", "#0ff", "#002"));
  var msPanel = addPanel(new Stats.Panel("MS", "#0f0", "#020"));
  if (self.performance && self.performance.memory) {
    var memPanel = addPanel(new Stats.Panel("MB", "#f08", "#201"));
  }
  showPanel(0);
  return {
    REVISION: 16,
    dom: container,
    addPanel,
    showPanel,
    begin: function() {
      beginTime = (performance || Date).now();
    },
    end: function() {
      frames++;
      var time = (performance || Date).now();
      msPanel.update(time - beginTime, 200);
      if (time >= prevTime + 1e3) {
        fpsPanel.update(frames * 1e3 / (time - prevTime), 100);
        prevTime = time;
        frames = 0;
        if (memPanel) {
          var memory = performance.memory;
          memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
        }
      }
      return time;
    },
    update: function() {
      beginTime = this.end();
    },
    // Backwards Compatibility
    domElement: container,
    setMode: showPanel
  };
};
Stats.Panel = function(name2, fg2, bg2) {
  var min = Infinity, max2 = 0, round = Math.round;
  var PR = round(window.devicePixelRatio || 1);
  var WIDTH = 80 * PR, HEIGHT = 48 * PR, TEXT_X = 3 * PR, TEXT_Y = 2 * PR, GRAPH_X = 3 * PR, GRAPH_Y = 15 * PR, GRAPH_WIDTH = 74 * PR, GRAPH_HEIGHT = 30 * PR;
  var canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.cssText = "width:80px;height:48px";
  var context = canvas.getContext("2d");
  context.font = "bold " + 9 * PR + "px Helvetica,Arial,sans-serif";
  context.textBaseline = "top";
  context.fillStyle = bg2;
  context.fillRect(0, 0, WIDTH, HEIGHT);
  context.fillStyle = fg2;
  context.fillText(name2, TEXT_X, TEXT_Y);
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  context.fillStyle = bg2;
  context.globalAlpha = 0.9;
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  return {
    dom: canvas,
    update: function(value, maxValue) {
      min = Math.min(min, value);
      max2 = Math.max(max2, value);
      context.fillStyle = bg2;
      context.globalAlpha = 1;
      context.fillRect(0, 0, WIDTH, GRAPH_Y);
      context.fillStyle = fg2;
      context.fillText(round(value) + " " + name2 + " (" + round(min) + "-" + round(max2) + ")", TEXT_X, TEXT_Y);
      context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
      context.fillStyle = bg2;
      context.globalAlpha = 0.9;
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));
    }
  };
};
class TalkingHead {
  /**
  * Avatar.
  * @typedef {Object} Avatar
  * @property {string} url URL for the GLB file
  * @property {string} [body] Body form 'M' or 'F'
  * @property {string} [lipsyncLang] Lip-sync language, e.g. 'fi', 'en'
  * @property {string} [ttsLang] Text-to-speech language, e.g. "fi-FI"
  * @property {voice} [ttsVoice] Voice name.
  * @property {numeric} [ttsRate] Voice rate.
  * @property {numeric} [ttsPitch] Voice pitch.
  * @property {numeric} [ttsVolume] Voice volume.
  * @property {string} [avatarMood] Initial mood.
  * @property {boolean} [avatarMute] If true, muted.
  */
  /**
  * Loading progress.
  * @callback progressfn
  * @param {string} url URL of the resource
  * @param {Object} event Progress event
  * @param {boolean} event.lengthComputable If false, total is not known
  * @param {number} event.loaded Number of loaded items
  * @param {number} event.total Number of total items
  */
  /**
  * Callback when new subtitles have been written to the DOM node.
  * @callback subtitlesfn
  * @param {Object} node DOM node
  */
  /**
  * Callback when the speech queue processes this marker item.
  * @callback markerfn
  */
  /**
  * Audio object.
  * @typedef {Object} Audio
  * @property {ArrayBuffer|ArrayBuffer[]} audio Audio buffer or array of buffers
  * @property {string[]} words Words
  * @property {number[]} wtimes Starting times of words
  * @property {number[]} wdurations Durations of words
  * @property {string[]} [visemes] Oculus lip-sync viseme IDs
  * @property {number[]} [vtimes] Starting times of visemes
  * @property {number[]} [vdurations] Durations of visemes
  * @property {string[]} [markers] Timed callback functions
  * @property {number[]} [mtimes] Starting times of markers
  */
  /**
  * Lip-sync object.
  * @typedef {Object} Lipsync
  * @property {string[]} visemes Oculus lip-sync visemes
  * @property {number[]} times Starting times in relative units
  * @property {number[]} durations Durations in relative units
  */
  /**
  * @constructor
  * @param {Object} node DOM element of the avatar
  * @param {Object} [opt=null] Global/default options
  */
  constructor(node2, opt = null) {
    this.nodeAvatar = node2;
    this.opt = {
      jwtGet: null,
      // Function to get JSON Web Token
      ttsEndpoint: null,
      ttsApikey: null,
      ttsTrimStart: 0,
      ttsTrimEnd: 400,
      ttsLang: "fi-FI",
      ttsVoice: "fi-FI-Standard-A",
      ttsRate: 0.95,
      ttsPitch: 0,
      ttsVolume: 0,
      lipsyncLang: "fi",
      lipsyncModules: ["fi", "en", "lt"],
      pcmSampleRate: 22050,
      modelRoot: "Armature",
      modelPixelRatio: 1,
      modelFPS: 30,
      modelMovementFactor: 1,
      cameraView: "full",
      cameraDistance: 0,
      cameraX: 0,
      cameraY: 0,
      cameraRotateX: 0,
      cameraRotateY: 0,
      cameraRotateEnable: true,
      cameraPanEnable: false,
      cameraZoomEnable: false,
      lightAmbientColor: 16777215,
      lightAmbientIntensity: 2,
      lightDirectColor: 8947882,
      lightDirectIntensity: 30,
      lightDirectPhi: 1,
      lightDirectTheta: 2,
      lightSpotIntensity: 0,
      lightSpotColor: 3377407,
      lightSpotPhi: 0.1,
      lightSpotTheta: 4,
      lightSpotDispersion: 1,
      avatarMood: "neutral",
      avatarMute: false,
      markedOptions: { mangle: false, headerIds: false, breaks: true },
      statsNode: null,
      statsStyle: null
    };
    Object.assign(this.opt, opt || {});
    if (this.opt.statsNode) {
      this.stats = new Stats();
      if (this.opt.statsStyle) {
        this.stats.dom.style.cssText = this.opt.statsStyle;
      }
      this.opt.statsNode.appendChild(this.stats.dom);
    }
    this.poseTemplates = {
      "side": {
        standing: true,
        props: {
          "Hips.position": { x: 0, y: 1, z: 0 },
          "Hips.rotation": { x: -3e-3, y: -0.017, z: 0.1 },
          "Spine.rotation": { x: -0.103, y: -2e-3, z: -0.063 },
          "Spine1.rotation": { x: 0.042, y: -0.02, z: -0.069 },
          "Spine2.rotation": { x: 0.131, y: -0.012, z: -0.065 },
          "Neck.rotation": { x: 0.027, y: 6e-3, z: 0 },
          "Head.rotation": { x: 0.077, y: -0.065, z: 0 },
          "LeftShoulder.rotation": { x: 1.599, y: 0.084, z: -1.77 },
          "LeftArm.rotation": { x: 1.364, y: 0.052, z: -0.044 },
          "LeftForeArm.rotation": { x: 2e-3, y: -7e-3, z: 0.331 },
          "LeftHand.rotation": { x: 0.104, y: -0.067, z: -0.174 },
          "LeftHandThumb1.rotation": { x: 0.231, y: 0.258, z: 0.355 },
          "LeftHandThumb2.rotation": { x: -0.106, y: -0.339, z: -0.454 },
          "LeftHandThumb3.rotation": { x: -0.02, y: -0.142, z: -4e-3 },
          "LeftHandIndex1.rotation": { x: 0.148, y: 0.032, z: -0.069 },
          "LeftHandIndex2.rotation": { x: 0.326, y: -0.049, z: -0.029 },
          "LeftHandIndex3.rotation": { x: 0.247, y: -0.053, z: -0.073 },
          "LeftHandMiddle1.rotation": { x: 0.238, y: -0.057, z: -0.089 },
          "LeftHandMiddle2.rotation": { x: 0.469, y: -0.036, z: -0.081 },
          "LeftHandMiddle3.rotation": { x: 0.206, y: -0.015, z: -0.017 },
          "LeftHandRing1.rotation": { x: 0.187, y: -0.118, z: -0.157 },
          "LeftHandRing2.rotation": { x: 0.579, y: 0.02, z: -0.097 },
          "LeftHandRing3.rotation": { x: 0.272, y: 0.021, z: -0.063 },
          "LeftHandPinky1.rotation": { x: 0.405, y: -0.182, z: -0.138 },
          "LeftHandPinky2.rotation": { x: 0.613, y: 0.128, z: -0.144 },
          "LeftHandPinky3.rotation": { x: 0.268, y: 0.094, z: -0.081 },
          "RightShoulder.rotation": { x: 1.541, y: 0.192, z: 1.775 },
          "RightArm.rotation": { x: 1.273, y: -0.352, z: -0.067 },
          "RightForeArm.rotation": { x: -0.011, y: -0.031, z: -0.357 },
          "RightHand.rotation": { x: -8e-3, y: 0.312, z: -0.028 },
          "RightHandThumb1.rotation": { x: 0.23, y: -0.258, z: -0.355 },
          "RightHandThumb2.rotation": { x: -0.107, y: 0.339, z: 0.454 },
          "RightHandThumb3.rotation": { x: -0.02, y: 0.142, z: 4e-3 },
          "RightHandIndex1.rotation": { x: 0.148, y: -0.031, z: 0.069 },
          "RightHandIndex2.rotation": { x: 0.326, y: 0.049, z: 0.029 },
          "RightHandIndex3.rotation": { x: 0.247, y: 0.053, z: 0.073 },
          "RightHandMiddle1.rotation": { x: 0.237, y: 0.057, z: 0.089 },
          "RightHandMiddle2.rotation": { x: 0.469, y: 0.036, z: 0.081 },
          "RightHandMiddle3.rotation": { x: 0.206, y: 0.015, z: 0.017 },
          "RightHandRing1.rotation": { x: 0.204, y: 0.086, z: 0.135 },
          "RightHandRing2.rotation": { x: 0.579, y: -0.02, z: 0.098 },
          "RightHandRing3.rotation": { x: 0.272, y: -0.021, z: 0.063 },
          "RightHandPinky1.rotation": { x: 0.404, y: 0.182, z: 0.137 },
          "RightHandPinky2.rotation": { x: 0.613, y: -0.128, z: 0.144 },
          "RightHandPinky3.rotation": { x: 0.268, y: -0.094, z: 0.081 },
          "LeftUpLeg.rotation": { x: 0.096, y: 0.209, z: 2.983 },
          "LeftLeg.rotation": { x: -0.053, y: 0.042, z: -0.017 },
          "LeftFoot.rotation": { x: 1.091, y: 0.15, z: 0.026 },
          "LeftToeBase.rotation": { x: 0.469, y: -0.07, z: -0.015 },
          "RightUpLeg.rotation": { x: -0.307, y: -0.219, z: 2.912 },
          "RightLeg.rotation": { x: -0.359, y: 0.164, z: 0.015 },
          "RightFoot.rotation": { x: 1.035, y: 0.11, z: 5e-3 },
          "RightToeBase.rotation": { x: 0.467, y: 0.07, z: 0.015 }
        }
      },
      "hip": {
        standing: true,
        props: {
          "Hips.position": { x: 0, y: 1, z: 0 },
          "Hips.rotation": { x: -0.036, y: 0.09, z: 0.135 },
          "Spine.rotation": { x: 0.076, y: -0.035, z: 0.01 },
          "Spine1.rotation": { x: -0.096, y: 0.013, z: -0.094 },
          "Spine2.rotation": { x: -0.014, y: 2e-3, z: -0.097 },
          "Neck.rotation": { x: 0.034, y: -0.051, z: -0.075 },
          "Head.rotation": { x: 0.298, y: -0.1, z: 0.154 },
          "LeftShoulder.rotation": { x: 1.694, y: 0.011, z: -1.68 },
          "LeftArm.rotation": { x: 1.343, y: 0.177, z: -0.153 },
          "LeftForeArm.rotation": { x: -0.049, y: 0.134, z: 0.351 },
          "LeftHand.rotation": { x: 0.057, y: -0.189, z: -0.026 },
          "LeftHandThumb1.rotation": { x: 0.368, y: -0.066, z: 0.438 },
          "LeftHandThumb2.rotation": { x: -0.156, y: 0.029, z: -0.369 },
          "LeftHandThumb3.rotation": { x: 0.034, y: -9e-3, z: 0.016 },
          "LeftHandIndex1.rotation": { x: 0.157, y: -2e-3, z: -0.171 },
          "LeftHandIndex2.rotation": { x: 0.099, y: 0, z: 0 },
          "LeftHandIndex3.rotation": { x: 0.1, y: 0, z: 0 },
          "LeftHandMiddle1.rotation": { x: 0.222, y: -0.019, z: -0.16 },
          "LeftHandMiddle2.rotation": { x: 0.142, y: 0, z: 0 },
          "LeftHandMiddle3.rotation": { x: 0.141, y: 0, z: 0 },
          "LeftHandRing1.rotation": { x: 0.333, y: -0.039, z: -0.174 },
          "LeftHandRing2.rotation": { x: 0.214, y: 0, z: 0 },
          "LeftHandRing3.rotation": { x: 0.213, y: 0, z: 0 },
          "LeftHandPinky1.rotation": { x: 0.483, y: -0.069, z: -0.189 },
          "LeftHandPinky2.rotation": { x: 0.312, y: 0, z: 0 },
          "LeftHandPinky3.rotation": { x: 0.309, y: 0, z: 0 },
          "RightShoulder.rotation": { x: 1.597, y: 0.012, z: 1.816 },
          "RightArm.rotation": { x: 0.618, y: -1.274, z: -0.266 },
          "RightForeArm.rotation": { x: -0.395, y: -0.097, z: -1.342 },
          "RightHand.rotation": { x: -0.816, y: -0.057, z: -0.976 },
          "RightHandThumb1.rotation": { x: 0.42, y: 0.23, z: -1.172 },
          "RightHandThumb2.rotation": { x: -0.027, y: 0.361, z: 0.122 },
          "RightHandThumb3.rotation": { x: 0.076, y: 0.125, z: -0.371 },
          "RightHandIndex1.rotation": { x: -0.158, y: -0.045, z: 0.033 },
          "RightHandIndex2.rotation": { x: 0.391, y: 0.051, z: 0.025 },
          "RightHandIndex3.rotation": { x: 0.317, y: 0.058, z: 0.07 },
          "RightHandMiddle1.rotation": { x: 0.486, y: 0.066, z: 0.014 },
          "RightHandMiddle2.rotation": { x: 0.718, y: 0.055, z: 0.07 },
          "RightHandMiddle3.rotation": { x: 0.453, y: 0.019, z: 0.013 },
          "RightHandRing1.rotation": { x: 0.591, y: 0.241, z: 0.11 },
          "RightHandRing2.rotation": { x: 1.014, y: 0.023, z: 0.097 },
          "RightHandRing3.rotation": { x: 0.708, y: 8e-3, z: 0.066 },
          "RightHandPinky1.rotation": { x: 1.02, y: 0.305, z: 0.051 },
          "RightHandPinky2.rotation": { x: 1.187, y: -0.028, z: 0.191 },
          "RightHandPinky3.rotation": { x: 0.872, y: -0.031, z: 0.121 },
          "LeftUpLeg.rotation": { x: -0.095, y: -0.058, z: -3.338 },
          "LeftLeg.rotation": { x: -0.366, y: 0.287, z: -0.021 },
          "LeftFoot.rotation": { x: 1.131, y: 0.21, z: 0.176 },
          "LeftToeBase.rotation": { x: 0.739, y: -0.068, z: -1e-3 },
          "RightUpLeg.rotation": { x: -0.502, y: 0.362, z: 3.153 },
          "RightLeg.rotation": { x: -1.002, y: 0.109, z: 8e-3 },
          "RightFoot.rotation": { x: 0.626, y: -0.097, z: -0.194 },
          "RightToeBase.rotation": { x: 1.33, y: 0.288, z: -0.078 }
        }
      },
      "turn": {
        standing: true,
        props: {
          "Hips.position": { x: 0, y: 1, z: 0 },
          "Hips.rotation": { x: -0.07, y: -0.604, z: -4e-3 },
          "Spine.rotation": { x: -7e-3, y: 3e-3, z: 0.071 },
          "Spine1.rotation": { x: -0.053, y: 0.024, z: -0.06 },
          "Spine2.rotation": { x: 0.074, y: 0.013, z: -0.068 },
          "Neck.rotation": { x: 0.03, y: 0.186, z: -0.077 },
          "Head.rotation": { x: 0.045, y: 0.243, z: -0.086 },
          "LeftShoulder.rotation": { x: 1.717, y: -0.085, z: -1.761 },
          "LeftArm.rotation": { x: 1.314, y: 0.07, z: -0.057 },
          "LeftForeArm.rotation": { x: -0.151, y: 0.714, z: 0.302 },
          "LeftHand.rotation": { x: -0.069, y: 3e-3, z: -0.118 },
          "LeftHandThumb1.rotation": { x: 0.23, y: 0.258, z: 0.354 },
          "LeftHandThumb2.rotation": { x: -0.107, y: -0.338, z: -0.455 },
          "LeftHandThumb3.rotation": { x: -0.015, y: -0.142, z: 2e-3 },
          "LeftHandIndex1.rotation": { x: 0.145, y: 0.032, z: -0.069 },
          "LeftHandIndex2.rotation": { x: 0.323, y: -0.049, z: -0.028 },
          "LeftHandIndex3.rotation": { x: 0.249, y: -0.053, z: -0.074 },
          "LeftHandMiddle1.rotation": { x: 0.235, y: -0.057, z: -0.088 },
          "LeftHandMiddle2.rotation": { x: 0.468, y: -0.036, z: -0.081 },
          "LeftHandMiddle3.rotation": { x: 0.203, y: -0.015, z: -0.017 },
          "LeftHandRing1.rotation": { x: 0.185, y: -0.118, z: -0.157 },
          "LeftHandRing2.rotation": { x: 0.578, y: 0.02, z: -0.097 },
          "LeftHandRing3.rotation": { x: 0.27, y: 0.021, z: -0.063 },
          "LeftHandPinky1.rotation": { x: 0.404, y: -0.182, z: -0.138 },
          "LeftHandPinky2.rotation": { x: 0.612, y: 0.128, z: -0.144 },
          "LeftHandPinky3.rotation": { x: 0.267, y: 0.094, z: -0.081 },
          "RightShoulder.rotation": { x: 1.605, y: 0.17, z: 1.625 },
          "RightArm.rotation": { x: 1.574, y: -0.655, z: 0.388 },
          "RightForeArm.rotation": { x: -0.36, y: -0.849, z: -0.465 },
          "RightHand.rotation": { x: 0.114, y: 0.416, z: -0.069 },
          "RightHandThumb1.rotation": { x: 0.486, y: 9e-3, z: -0.492 },
          "RightHandThumb2.rotation": { x: -0.073, y: -0.01, z: 0.284 },
          "RightHandThumb3.rotation": { x: -0.054, y: -6e-3, z: 0.209 },
          "RightHandIndex1.rotation": { x: 0.245, y: -0.014, z: 0.052 },
          "RightHandIndex2.rotation": { x: 0.155, y: 0, z: 0 },
          "RightHandIndex3.rotation": { x: 0.153, y: 0, z: 0 },
          "RightHandMiddle1.rotation": { x: 0.238, y: 4e-3, z: 0.028 },
          "RightHandMiddle2.rotation": { x: 0.15, y: 0, z: 0 },
          "RightHandMiddle3.rotation": { x: 0.149, y: 0, z: 0 },
          "RightHandRing1.rotation": { x: 0.267, y: 0.012, z: 7e-3 },
          "RightHandRing2.rotation": { x: 0.169, y: 0, z: 0 },
          "RightHandRing3.rotation": { x: 0.167, y: 0, z: 0 },
          "RightHandPinky1.rotation": { x: 0.304, y: 0.018, z: -0.021 },
          "RightHandPinky2.rotation": { x: 0.192, y: 0, z: 0 },
          "RightHandPinky3.rotation": { x: 0.19, y: 0, z: 0 },
          "LeftUpLeg.rotation": { x: -1e-3, y: -0.058, z: -3.238 },
          "LeftLeg.rotation": { x: -0.29, y: 0.058, z: -0.021 },
          "LeftFoot.rotation": { x: 1.288, y: 0.168, z: 0.183 },
          "LeftToeBase.rotation": { x: 0.363, y: -0.09, z: -0.01 },
          "RightUpLeg.rotation": { x: -0.1, y: 0.36, z: 3.062 },
          "RightLeg.rotation": { x: -0.67, y: -0.304, z: 0.043 },
          "RightFoot.rotation": { x: 1.195, y: -0.159, z: -0.294 },
          "RightToeBase.rotation": { x: 0.737, y: 0.164, z: -2e-3 }
        }
      },
      "bend": {
        bend: true,
        standing: true,
        props: {
          "Hips.position": { x: -7e-3, y: 0.943, z: -1e-3 },
          "Hips.rotation": { x: 1.488, y: -0.633, z: 1.435 },
          "Spine.rotation": { x: -0.126, y: 7e-3, z: -0.057 },
          "Spine1.rotation": { x: -0.134, y: 9e-3, z: 0.01 },
          "Spine2.rotation": { x: -0.019, y: 0, z: -2e-3 },
          "Neck.rotation": { x: -0.159, y: 0.572, z: -0.108 },
          "Head.rotation": { x: -0.064, y: 0.716, z: -0.257 },
          "RightShoulder.rotation": { x: 1.625, y: -0.043, z: 1.382 },
          "RightArm.rotation": { x: 0.746, y: -0.96, z: -1.009 },
          "RightForeArm.rotation": { x: -0.199, y: -0.528, z: -0.38 },
          "RightHand.rotation": { x: -0.261, y: -0.043, z: -0.027 },
          "RightHandThumb1.rotation": { x: 0.172, y: -0.138, z: -0.445 },
          "RightHandThumb2.rotation": { x: -0.158, y: 0.327, z: 0.545 },
          "RightHandThumb3.rotation": { x: -0.062, y: 0.138, z: 0.152 },
          "RightHandIndex1.rotation": { x: 0.328, y: -5e-3, z: 0.132 },
          "RightHandIndex2.rotation": { x: 0.303, y: 0.049, z: 0.028 },
          "RightHandIndex3.rotation": { x: 0.241, y: 0.046, z: 0.077 },
          "RightHandMiddle1.rotation": { x: 0.309, y: 0.074, z: 0.089 },
          "RightHandMiddle2.rotation": { x: 0.392, y: 0.036, z: 0.081 },
          "RightHandMiddle3.rotation": { x: 0.199, y: 0.014, z: 0.019 },
          "RightHandRing1.rotation": { x: 0.239, y: 0.143, z: 0.091 },
          "RightHandRing2.rotation": { x: 0.275, y: -0.02, z: 0.097 },
          "RightHandRing3.rotation": { x: 0.248, y: -0.023, z: 0.061 },
          "RightHandPinky1.rotation": { x: 0.211, y: 0.154, z: 0.029 },
          "RightHandPinky2.rotation": { x: 0.348, y: -0.128, z: 0.144 },
          "RightHandPinky3.rotation": { x: 0.21, y: -0.091, z: 0.065 },
          "LeftShoulder.rotation": { x: 1.626, y: -0.027, z: -1.367 },
          "LeftArm.rotation": { x: 1.048, y: 0.737, z: 0.712 },
          "LeftForeArm.rotation": { x: -0.508, y: 0.879, z: 0.625 },
          "LeftHand.rotation": { x: 0.06, y: -0.243, z: -0.079 },
          "LeftHandThumb1.rotation": { x: 0.187, y: -0.072, z: 0.346 },
          "LeftHandThumb2.rotation": { x: -0.066, y: 8e-3, z: -0.256 },
          "LeftHandThumb3.rotation": { x: -0.085, y: 0.014, z: -0.334 },
          "LeftHandIndex1.rotation": { x: -0.1, y: 0.016, z: -0.058 },
          "LeftHandIndex2.rotation": { x: 0.334, y: 0, z: 0 },
          "LeftHandIndex3.rotation": { x: 0.281, y: 0, z: 0 },
          "LeftHandMiddle1.rotation": { x: -0.056, y: 0, z: 0 },
          "LeftHandMiddle2.rotation": { x: 0.258, y: 0, z: 0 },
          "LeftHandMiddle3.rotation": { x: 0.26, y: 0, z: 0 },
          "LeftHandRing1.rotation": { x: -0.067, y: -2e-3, z: 8e-3 },
          "LeftHandRing2.rotation": { x: 0.259, y: 0, z: 0 },
          "LeftHandRing3.rotation": { x: 0.276, y: 0, z: 0 },
          "LeftHandPinky1.rotation": { x: -0.128, y: -7e-3, z: 0.042 },
          "LeftHandPinky2.rotation": { x: 0.227, y: 0, z: 0 },
          "LeftHandPinky3.rotation": { x: 0.145, y: 0, z: 0 },
          "RightUpLeg.rotation": { x: -1.507, y: 0.2, z: -3.043 },
          "RightLeg.rotation": { x: -0.689, y: -0.124, z: 0.017 },
          "RightFoot.rotation": { x: 0.909, y: 8e-3, z: -0.093 },
          "RightToeBase.rotation": { x: 0.842, y: 0.075, z: -8e-3 },
          "LeftUpLeg.rotation": { x: -1.449, y: -0.2, z: 3.018 },
          "LeftLeg.rotation": { x: -0.74, y: -0.115, z: -8e-3 },
          "LeftFoot.rotation": { x: 1.048, y: -0.058, z: 0.117 },
          "LeftToeBase.rotation": { x: 0.807, y: -0.067, z: 3e-3 }
        }
      },
      "back": {
        standing: true,
        props: {
          "Hips.position": { x: 0, y: 1, z: 0 },
          "Hips.rotation": { x: -0.732, y: -1.463, z: -0.637 },
          "Spine.rotation": { x: -0.171, y: 0.106, z: 0.157 },
          "Spine1.rotation": { x: -0.044, y: 0.138, z: -0.059 },
          "Spine2.rotation": { x: 0.082, y: 0.133, z: -0.074 },
          "Neck.rotation": { x: 0.39, y: 0.591, z: -0.248 },
          "Head.rotation": { x: -1e-3, y: 0.596, z: -0.057 },
          "LeftShoulder.rotation": { x: 1.676, y: 7e-3, z: -1.892 },
          "LeftArm.rotation": { x: -5.566, y: 1.188, z: -0.173 },
          "LeftForeArm.rotation": { x: -0.673, y: -0.105, z: 1.702 },
          "LeftHand.rotation": { x: -0.469, y: -0.739, z: 3e-3 },
          "LeftHandThumb1.rotation": { x: 0.876, y: 0.274, z: 0.793 },
          "LeftHandThumb2.rotation": { x: 0.161, y: -0.23, z: -0.172 },
          "LeftHandThumb3.rotation": { x: 0.078, y: 0.027, z: 0.156 },
          "LeftHandIndex1.rotation": { x: -0.085, y: -2e-3, z: 9e-3 },
          "LeftHandIndex2.rotation": { x: 0.176, y: 0, z: -2e-3 },
          "LeftHandIndex3.rotation": { x: -0.036, y: 1e-3, z: -0.035 },
          "LeftHandMiddle1.rotation": { x: 0.015, y: 0.144, z: -0.076 },
          "LeftHandMiddle2.rotation": { x: 0.378, y: -7e-3, z: -0.077 },
          "LeftHandMiddle3.rotation": { x: -0.141, y: -1e-3, z: 0.031 },
          "LeftHandRing1.rotation": { x: 0.039, y: 0.02, z: -0.2 },
          "LeftHandRing2.rotation": { x: 0.25, y: -2e-3, z: -0.073 },
          "LeftHandRing3.rotation": { x: 0.236, y: 6e-3, z: -0.075 },
          "LeftHandPinky1.rotation": { x: 0.172, y: -0.033, z: -0.275 },
          "LeftHandPinky2.rotation": { x: 0.216, y: 0.043, z: -0.054 },
          "LeftHandPinky3.rotation": { x: 0.325, y: 0.078, z: -0.13 },
          "RightShoulder.rotation": { x: 2.015, y: -0.168, z: 1.706 },
          "RightArm.rotation": { x: 0.203, y: -1.258, z: -0.782 },
          "RightForeArm.rotation": { x: -0.658, y: -0.133, z: -1.401 },
          "RightHand.rotation": { x: -1.504, y: 0.375, z: -5e-3 },
          "RightHandThumb1.rotation": { x: 0.413, y: -0.158, z: -1.121 },
          "RightHandThumb2.rotation": { x: -0.142, y: -8e-3, z: 0.209 },
          "RightHandThumb3.rotation": { x: -0.091, y: 0.021, z: 0.142 },
          "RightHandIndex1.rotation": { x: -0.167, y: 0.014, z: -0.072 },
          "RightHandIndex2.rotation": { x: 0.474, y: 9e-3, z: 0.051 },
          "RightHandIndex3.rotation": { x: 0.115, y: 6e-3, z: 0.047 },
          "RightHandMiddle1.rotation": { x: 0.385, y: 0.019, z: 0.144 },
          "RightHandMiddle2.rotation": { x: 0.559, y: 0.035, z: 0.101 },
          "RightHandMiddle3.rotation": { x: 0.229, y: 0, z: 0.027 },
          "RightHandRing1.rotation": { x: 0.48, y: 0.026, z: 0.23 },
          "RightHandRing2.rotation": { x: 0.772, y: 0.038, z: 0.109 },
          "RightHandRing3.rotation": { x: 0.622, y: 0.039, z: 0.106 },
          "RightHandPinky1.rotation": { x: 0.767, y: 0.288, z: 0.353 },
          "RightHandPinky2.rotation": { x: 0.886, y: 0.049, z: 0.122 },
          "RightHandPinky3.rotation": { x: 0.662, y: 0.044, z: 0.113 },
          "LeftUpLeg.rotation": { x: -0.206, y: -0.268, z: -3.343 },
          "LeftLeg.rotation": { x: -0.333, y: 0.757, z: -0.043 },
          "LeftFoot.rotation": { x: 1.049, y: 0.167, z: 0.287 },
          "LeftToeBase.rotation": { x: 0.672, y: -0.069, z: -4e-3 },
          "RightUpLeg.rotation": { x: 0.055, y: -0.226, z: 3.037 },
          "RightLeg.rotation": { x: -0.559, y: 0.39, z: -1e-3 },
          "RightFoot.rotation": { x: 1.2, y: 0.133, z: 0.085 },
          "RightToeBase.rotation": { x: 0.92, y: 0.093, z: -0.013 }
        }
      },
      "straight": {
        standing: true,
        props: {
          "Hips.position": { x: 0, y: 0.989, z: 1e-3 },
          "Hips.rotation": { x: 0.047, y: 7e-3, z: -7e-3 },
          "Spine.rotation": { x: -0.143, y: -7e-3, z: 5e-3 },
          "Spine1.rotation": { x: -0.043, y: -0.014, z: 0.012 },
          "Spine2.rotation": { x: 0.072, y: -0.013, z: 0.013 },
          "Neck.rotation": { x: 0.048, y: -3e-3, z: 0.012 },
          "Head.rotation": { x: 0.05, y: -0.02, z: -0.017 },
          "LeftShoulder.rotation": { x: 1.62, y: -0.166, z: -1.605 },
          "LeftArm.rotation": { x: 1.275, y: 0.544, z: -0.092 },
          "LeftForeArm.rotation": { x: 0, y: 0, z: 0.302 },
          "LeftHand.rotation": { x: -0.225, y: -0.154, z: 0.11 },
          "LeftHandThumb1.rotation": { x: 0.435, y: -0.044, z: 0.457 },
          "LeftHandThumb2.rotation": { x: -0.028, y: 2e-3, z: -0.246 },
          "LeftHandThumb3.rotation": { x: -0.236, y: -0.025, z: 0.113 },
          "LeftHandIndex1.rotation": { x: 0.218, y: 8e-3, z: -0.081 },
          "LeftHandIndex2.rotation": { x: 0.165, y: -1e-3, z: -0.017 },
          "LeftHandIndex3.rotation": { x: 0.165, y: -1e-3, z: -0.017 },
          "LeftHandMiddle1.rotation": { x: 0.235, y: -0.011, z: -0.065 },
          "LeftHandMiddle2.rotation": { x: 0.182, y: -2e-3, z: -0.019 },
          "LeftHandMiddle3.rotation": { x: 0.182, y: -2e-3, z: -0.019 },
          "LeftHandRing1.rotation": { x: 0.316, y: -0.017, z: 8e-3 },
          "LeftHandRing2.rotation": { x: 0.253, y: -3e-3, z: -0.026 },
          "LeftHandRing3.rotation": { x: 0.255, y: -3e-3, z: -0.026 },
          "LeftHandPinky1.rotation": { x: 0.336, y: -0.062, z: 0.088 },
          "LeftHandPinky2.rotation": { x: 0.276, y: -4e-3, z: -0.028 },
          "LeftHandPinky3.rotation": { x: 0.276, y: -4e-3, z: -0.028 },
          "RightShoulder.rotation": { x: 1.615, y: 0.064, z: 1.53 },
          "RightArm.rotation": { x: 1.313, y: -0.424, z: 0.131 },
          "RightForeArm.rotation": { x: 0, y: 0, z: -0.317 },
          "RightHand.rotation": { x: -0.158, y: -0.639, z: -0.196 },
          "RightHandThumb1.rotation": { x: 0.44, y: 0.048, z: -0.549 },
          "RightHandThumb2.rotation": { x: -0.056, y: -8e-3, z: 0.274 },
          "RightHandThumb3.rotation": { x: -0.258, y: 0.031, z: -0.095 },
          "RightHandIndex1.rotation": { x: 0.169, y: -0.011, z: 0.105 },
          "RightHandIndex2.rotation": { x: 0.134, y: 1e-3, z: 0.011 },
          "RightHandIndex3.rotation": { x: 0.134, y: 1e-3, z: 0.011 },
          "RightHandMiddle1.rotation": { x: 0.288, y: 0.014, z: 0.092 },
          "RightHandMiddle2.rotation": { x: 0.248, y: 3e-3, z: 0.02 },
          "RightHandMiddle3.rotation": { x: 0.249, y: 3e-3, z: 0.02 },
          "RightHandRing1.rotation": { x: 0.369, y: 0.019, z: 6e-3 },
          "RightHandRing2.rotation": { x: 0.321, y: 4e-3, z: 0.026 },
          "RightHandRing3.rotation": { x: 0.323, y: 4e-3, z: 0.026 },
          "RightHandPinky1.rotation": { x: 0.468, y: 0.085, z: -0.03 },
          "RightHandPinky2.rotation": { x: 0.427, y: 7e-3, z: 0.034 },
          "RightHandPinky3.rotation": { x: 0.142, y: 1e-3, z: 0.012 },
          "LeftUpLeg.rotation": { x: -0.077, y: -0.058, z: 3.126 },
          "LeftLeg.rotation": { x: -0.252, y: 1e-3, z: -0.018 },
          "LeftFoot.rotation": { x: 1.315, y: -0.064, z: 0.315 },
          "LeftToeBase.rotation": { x: 0.577, y: -0.07, z: -9e-3 },
          "RightUpLeg.rotation": { x: -0.083, y: -0.032, z: 3.124 },
          "RightLeg.rotation": { x: -0.272, y: -3e-3, z: 0.021 },
          "RightFoot.rotation": { x: 1.342, y: 0.076, z: -0.222 },
          "RightToeBase.rotation": { x: 0.44, y: 0.069, z: 0.016 }
        }
      },
      "wide": {
        standing: true,
        props: {
          "Hips.position": { x: 0, y: 1.017, z: 0.016 },
          "Hips.rotation": { x: 0.064, y: -0.048, z: 0.059 },
          "Spine.rotation": { x: -0.123, y: 0, z: -0.018 },
          "Spine1.rotation": { x: 0.014, y: 3e-3, z: -6e-3 },
          "Spine2.rotation": { x: 0.04, y: 3e-3, z: -7e-3 },
          "Neck.rotation": { x: 0.101, y: 7e-3, z: -0.035 },
          "Head.rotation": { x: -0.091, y: -0.049, z: 0.105 },
          "RightShoulder.rotation": { x: 1.831, y: 0.017, z: 1.731 },
          "RightArm.rotation": { x: -1.673, y: -1.102, z: -3.132 },
          "RightForeArm.rotation": { x: 0.265, y: 0.23, z: -0.824 },
          "RightHand.rotation": { x: -0.52, y: 0.345, z: -0.061 },
          "RightHandThumb1.rotation": { x: 0.291, y: 0.056, z: -0.428 },
          "RightHandThumb2.rotation": { x: 0.025, y: 5e-3, z: 0.166 },
          "RightHandThumb3.rotation": { x: -0.089, y: 9e-3, z: 0.068 },
          "RightHandIndex1.rotation": { x: 0.392, y: -0.015, z: 0.11 },
          "RightHandIndex2.rotation": { x: 0.391, y: 1e-3, z: 4e-3 },
          "RightHandIndex3.rotation": { x: 0.326, y: 0, z: 3e-3 },
          "RightHandMiddle1.rotation": { x: 0.285, y: 0.068, z: 0.081 },
          "RightHandMiddle2.rotation": { x: 0.519, y: 4e-3, z: 0.011 },
          "RightHandMiddle3.rotation": { x: 0.252, y: 0, z: 1e-3 },
          "RightHandRing1.rotation": { x: 0.207, y: 0.133, z: 0.146 },
          "RightHandRing2.rotation": { x: 0.597, y: 4e-3, z: 4e-3 },
          "RightHandRing3.rotation": { x: 0.292, y: 2e-3, z: 0.012 },
          "RightHandPinky1.rotation": { x: 0.338, y: 0.182, z: 0.136 },
          "RightHandPinky2.rotation": { x: 0.533, y: 2e-3, z: 4e-3 },
          "RightHandPinky3.rotation": { x: 0.194, y: 0, z: 2e-3 },
          "LeftShoulder.rotation": { x: 1.83, y: -0.063, z: -1.808 },
          "LeftArm.rotation": { x: -1.907, y: 1.228, z: -2.959 },
          "LeftForeArm.rotation": { x: -0.159, y: 0.268, z: 0.572 },
          "LeftHand.rotation": { x: 0.069, y: -0.498, z: -0.025 },
          "LeftHandThumb1.rotation": { x: 0.738, y: 0.123, z: 0.178 },
          "LeftHandThumb2.rotation": { x: -0.26, y: 0.028, z: -0.477 },
          "LeftHandThumb3.rotation": { x: -0.448, y: 0.093, z: -0.661 },
          "LeftHandIndex1.rotation": { x: 1.064, y: 5e-3, z: -0.13 },
          "LeftHandIndex2.rotation": { x: 1.55, y: -0.143, z: -0.136 },
          "LeftHandIndex3.rotation": { x: 0.722, y: -0.076, z: -0.127 },
          "LeftHandMiddle1.rotation": { x: 1.095, y: -0.091, z: 6e-3 },
          "LeftHandMiddle2.rotation": { x: 1.493, y: -0.174, z: -0.151 },
          "LeftHandMiddle3.rotation": { x: 0.651, y: -0.031, z: -0.087 },
          "LeftHandRing1.rotation": { x: 1.083, y: -0.224, z: 0.072 },
          "LeftHandRing2.rotation": { x: 1.145, y: -0.107, z: -0.195 },
          "LeftHandRing3.rotation": { x: 1.208, y: -0.134, z: -0.158 },
          "LeftHandPinky1.rotation": { x: 0.964, y: -0.383, z: 0.128 },
          "LeftHandPinky2.rotation": { x: 1.457, y: -0.146, z: -0.159 },
          "LeftHandPinky3.rotation": { x: 1.019, y: -0.102, z: -0.141 },
          "RightUpLeg.rotation": { x: -0.221, y: -0.233, z: 2.87 },
          "RightLeg.rotation": { x: -0.339, y: -0.043, z: -0.041 },
          "RightFoot.rotation": { x: 1.081, y: 0.177, z: 0.114 },
          "RightToeBase.rotation": { x: 0.775, y: 0, z: 0 },
          "LeftUpLeg.rotation": { x: -0.185, y: 0.184, z: 3.131 },
          "LeftLeg.rotation": { x: -0.408, y: 0.129, z: 0.02 },
          "LeftFoot.rotation": { x: 1.167, y: -2e-3, z: -7e-3 },
          "LeftToeBase.rotation": { x: 0.723, y: 0, z: 0 }
        }
      },
      "oneknee": {
        kneeling: true,
        props: {
          "Hips.position": { x: -5e-3, y: 0.415, z: -0.017 },
          "Hips.rotation": { x: -0.25, y: 0.04, z: -0.238 },
          "Spine.rotation": { x: 0.037, y: 0.043, z: 0.047 },
          "Spine1.rotation": { x: 0.317, y: 0.103, z: 0.066 },
          "Spine2.rotation": { x: 0.433, y: 0.109, z: 0.054 },
          "Neck.rotation": { x: -0.156, y: -0.092, z: 0.059 },
          "Head.rotation": { x: -0.398, y: -0.032, z: 0.018 },
          "RightShoulder.rotation": { x: 1.546, y: 0.119, z: 1.528 },
          "RightArm.rotation": { x: 0.896, y: -0.247, z: -0.512 },
          "RightForeArm.rotation": { x: 7e-3, y: 0, z: -1.622 },
          "RightHand.rotation": { x: 1.139, y: -0.853, z: 0.874 },
          "RightHandThumb1.rotation": { x: 0.176, y: 0.107, z: -0.311 },
          "RightHandThumb2.rotation": { x: -0.047, y: -3e-3, z: 0.12 },
          "RightHandThumb3.rotation": { x: 0, y: 0, z: 0 },
          "RightHandIndex1.rotation": { x: 0.186, y: 5e-3, z: 0.125 },
          "RightHandIndex2.rotation": { x: 0.454, y: 5e-3, z: 0.015 },
          "RightHandIndex3.rotation": { x: 0, y: 0, z: 0 },
          "RightHandMiddle1.rotation": { x: 0.444, y: 0.035, z: 0.127 },
          "RightHandMiddle2.rotation": { x: 0.403, y: -6e-3, z: -0.04 },
          "RightHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
          "RightHandRing1.rotation": { x: 0.543, y: 0.074, z: 0.121 },
          "RightHandRing2.rotation": { x: 0.48, y: -0.018, z: -0.063 },
          "RightHandRing3.rotation": { x: 0, y: 0, z: 0 },
          "RightHandPinky1.rotation": { x: 0.464, y: 0.086, z: 0.113 },
          "RightHandPinky2.rotation": { x: 0.667, y: -0.06, z: -0.128 },
          "RightHandPinky3.rotation": { x: 0, y: 0, z: 0 },
          "LeftShoulder.rotation": { x: 1.545, y: -0.116, z: -1.529 },
          "LeftArm.rotation": { x: 0.799, y: 0.631, z: 0.556 },
          "LeftForeArm.rotation": { x: -2e-3, y: 7e-3, z: 0.926 },
          "LeftHand.rotation": { x: -0.508, y: 0.439, z: 0.502 },
          "LeftHandThumb1.rotation": { x: 0.651, y: -0.035, z: 0.308 },
          "LeftHandThumb2.rotation": { x: -0.053, y: 8e-3, z: -0.11 },
          "LeftHandThumb3.rotation": { x: 0, y: 0, z: 0 },
          "LeftHandIndex1.rotation": { x: 0.662, y: -0.053, z: -0.116 },
          "LeftHandIndex2.rotation": { x: 0.309, y: -4e-3, z: -0.02 },
          "LeftHandIndex3.rotation": { x: 0, y: 0, z: 0 },
          "LeftHandMiddle1.rotation": { x: 0.501, y: -0.062, z: -0.12 },
          "LeftHandMiddle2.rotation": { x: 0.144, y: -2e-3, z: 0.016 },
          "LeftHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
          "LeftHandRing1.rotation": { x: 0.397, y: -0.029, z: -0.143 },
          "LeftHandRing2.rotation": { x: 0.328, y: 0.01, z: 0.059 },
          "LeftHandRing3.rotation": { x: 0, y: 0, z: 0 },
          "LeftHandPinky1.rotation": { x: 0.194, y: 8e-3, z: -0.164 },
          "LeftHandPinky2.rotation": { x: 0.38, y: 0.031, z: 0.128 },
          "LeftHandPinky3.rotation": { x: 0, y: 0, z: 0 },
          "RightUpLeg.rotation": { x: -1.594, y: -0.251, z: 2.792 },
          "RightLeg.rotation": { x: -2.301, y: -0.073, z: 0.055 },
          "RightFoot.rotation": { x: 1.553, y: -0.207, z: -0.094 },
          "RightToeBase.rotation": { x: 0.459, y: 0.069, z: 0.016 },
          "LeftUpLeg.rotation": { x: -0.788, y: -0.236, z: -2.881 },
          "LeftLeg.rotation": { x: -2.703, y: 0.012, z: -0.047 },
          "LeftFoot.rotation": { x: 2.191, y: -0.102, z: 0.019 },
          "LeftToeBase.rotation": { x: 1.215, y: -0.027, z: 0.01 }
        }
      },
      "kneel": {
        kneeling: true,
        lying: true,
        props: {
          "Hips.position": { x: 0, y: 0.532, z: -2e-3 },
          "Hips.rotation": { x: 0.018, y: -8e-3, z: -0.017 },
          "Spine.rotation": { x: -0.139, y: -0.01, z: 2e-3 },
          "Spine1.rotation": { x: 2e-3, y: -2e-3, z: 1e-3 },
          "Spine2.rotation": { x: 0.028, y: -2e-3, z: 1e-3 },
          "Neck.rotation": { x: -7e-3, y: 0, z: -2e-3 },
          "Head.rotation": { x: -0.02, y: -8e-3, z: -4e-3 },
          "LeftShoulder.rotation": { x: 1.77, y: -0.428, z: -1.588 },
          "LeftArm.rotation": { x: 0.911, y: 0.343, z: 0.083 },
          "LeftForeArm.rotation": { x: 0, y: 0, z: 0.347 },
          "LeftHand.rotation": { x: 0.033, y: -0.052, z: -0.105 },
          "LeftHandThumb1.rotation": { x: 0.508, y: -0.22, z: 0.708 },
          "LeftHandThumb2.rotation": { x: -0.323, y: -0.139, z: -0.56 },
          "LeftHandThumb3.rotation": { x: -0.328, y: 0.16, z: -0.301 },
          "LeftHandIndex1.rotation": { x: 0.178, y: 0.248, z: 0.045 },
          "LeftHandIndex2.rotation": { x: 0.236, y: -2e-3, z: -0.019 },
          "LeftHandIndex3.rotation": { x: -0.062, y: 0, z: 5e-3 },
          "LeftHandMiddle1.rotation": { x: 0.123, y: -5e-3, z: -0.019 },
          "LeftHandMiddle2.rotation": { x: 0.589, y: -0.014, z: -0.045 },
          "LeftHandMiddle3.rotation": { x: 0.231, y: -2e-3, z: -0.019 },
          "LeftHandRing1.rotation": { x: 0.196, y: -8e-3, z: -0.091 },
          "LeftHandRing2.rotation": { x: 0.483, y: -9e-3, z: -0.038 },
          "LeftHandRing3.rotation": { x: 0.367, y: -5e-3, z: -0.029 },
          "LeftHandPinky1.rotation": { x: 0.191, y: -0.269, z: -0.246 },
          "LeftHandPinky2.rotation": { x: 0.37, y: -6e-3, z: -0.029 },
          "LeftHandPinky3.rotation": { x: 0.368, y: -5e-3, z: -0.029 },
          "RightShoulder.rotation": { x: 1.73, y: 0.434, z: 1.715 },
          "RightArm.rotation": { x: 0.841, y: -0.508, z: -0.155 },
          "RightForeArm.rotation": { x: 0, y: 0, z: -0.355 },
          "RightHand.rotation": { x: 0.091, y: 0.137, z: 0.197 },
          "RightHandThumb1.rotation": { x: 0.33, y: 0.051, z: -0.753 },
          "RightHandThumb2.rotation": { x: -0.113, y: 0.075, z: 0.612 },
          "RightHandThumb3.rotation": { x: -0.271, y: -0.166, z: 0.164 },
          "RightHandIndex1.rotation": { x: 0.073, y: 1e-3, z: -0.093 },
          "RightHandIndex2.rotation": { x: 0.338, y: 6e-3, z: 0.034 },
          "RightHandIndex3.rotation": { x: 0.131, y: 1e-3, z: 0.013 },
          "RightHandMiddle1.rotation": { x: 0.13, y: 5e-3, z: -0.017 },
          "RightHandMiddle2.rotation": { x: 0.602, y: 0.018, z: 0.058 },
          "RightHandMiddle3.rotation": { x: -0.031, y: 0, z: -3e-3 },
          "RightHandRing1.rotation": { x: 0.351, y: 0.019, z: 0.045 },
          "RightHandRing2.rotation": { x: 0.19, y: 2e-3, z: 0.019 },
          "RightHandRing3.rotation": { x: 0.21, y: 2e-3, z: 0.021 },
          "RightHandPinky1.rotation": { x: 0.256, y: 0.17, z: 0.118 },
          "RightHandPinky2.rotation": { x: 0.451, y: 0.01, z: 0.045 },
          "RightHandPinky3.rotation": { x: 0.346, y: 6e-3, z: 0.035 },
          "LeftUpLeg.rotation": { x: -0.06, y: 0.1, z: -2.918 },
          "LeftLeg.rotation": { x: -1.933, y: -0.01, z: 0.011 },
          "LeftFoot.rotation": { x: 0.774, y: -0.162, z: -0.144 },
          "LeftToeBase.rotation": { x: 1.188, y: 0, z: 0 },
          "RightUpLeg.rotation": { x: -0.099, y: -0.057, z: 2.922 },
          "RightLeg.rotation": { x: -1.93, y: 0.172, z: -0.02 },
          "RightFoot.rotation": { x: 0.644, y: 0.251, z: 0.212 },
          "RightToeBase.rotation": { x: 0.638, y: -0.034, z: -1e-3 }
        }
      },
      "sitting": {
        sitting: true,
        lying: true,
        props: {
          "Hips.position": { x: 0, y: 0.117, z: 5e-3 },
          "Hips.rotation": { x: -0.411, y: -0.049, z: 0.056 },
          "Spine.rotation": { x: 0.45, y: -0.039, z: -0.116 },
          "Spine1.rotation": { x: 0.092, y: -0.076, z: 0.08 },
          "Spine2.rotation": { x: 0.073, y: 0.035, z: 0.066 },
          "Neck.rotation": { x: 0.051, y: 0.053, z: -0.079 },
          "Head.rotation": { x: -0.169, y: 9e-3, z: 0.034 },
          "LeftShoulder.rotation": { x: 1.756, y: -0.037, z: -1.301 },
          "LeftArm.rotation": { x: -0.098, y: 0.016, z: 1.006 },
          "LeftForeArm.rotation": { x: -0.089, y: 0.08, z: 0.837 },
          "LeftHand.rotation": { x: 0.262, y: -0.399, z: 0.3 },
          "LeftHandThumb1.rotation": { x: 0.149, y: -0.043, z: 0.452 },
          "LeftHandThumb2.rotation": { x: 0.032, y: 6e-3, z: -0.162 },
          "LeftHandThumb3.rotation": { x: -0.086, y: -5e-3, z: -0.069 },
          "LeftHandIndex1.rotation": { x: 0.145, y: 0.032, z: -0.069 },
          "LeftHandIndex2.rotation": { x: 0.325, y: -1e-3, z: -4e-3 },
          "LeftHandIndex3.rotation": { x: 0.253, y: 0, z: -3e-3 },
          "LeftHandMiddle1.rotation": { x: 0.186, y: -0.051, z: -0.091 },
          "LeftHandMiddle2.rotation": { x: 0.42, y: -3e-3, z: -0.011 },
          "LeftHandMiddle3.rotation": { x: 0.153, y: 1e-3, z: -1e-3 },
          "LeftHandRing1.rotation": { x: 0.087, y: -0.19, z: -0.078 },
          "LeftHandRing2.rotation": { x: 0.488, y: -4e-3, z: -5e-3 },
          "LeftHandRing3.rotation": { x: 0.183, y: -1e-3, z: -0.012 },
          "LeftHandPinky1.rotation": { x: 0.205, y: -0.262, z: 0.051 },
          "LeftHandPinky2.rotation": { x: 0.407, y: -2e-3, z: -4e-3 },
          "LeftHandPinky3.rotation": { x: 0.068, y: 0, z: -2e-3 },
          "RightShoulder.rotation": { x: 1.619, y: -0.139, z: 1.179 },
          "RightArm.rotation": { x: 0.17, y: -0.037, z: -1.07 },
          "RightForeArm.rotation": { x: -0.044, y: -0.056, z: -0.665 },
          "RightHand.rotation": { x: 0.278, y: 0.454, z: -0.253 },
          "RightHandThumb1.rotation": { x: 0.173, y: 0.089, z: -0.584 },
          "RightHandThumb2.rotation": { x: -3e-3, y: -4e-3, z: 0.299 },
          "RightHandThumb3.rotation": { x: -0.133, y: -2e-3, z: 0.235 },
          "RightHandIndex1.rotation": { x: 0.393, y: -0.023, z: 0.108 },
          "RightHandIndex2.rotation": { x: 0.391, y: 1e-3, z: 4e-3 },
          "RightHandIndex3.rotation": { x: 0.326, y: 0, z: 3e-3 },
          "RightHandMiddle1.rotation": { x: 0.285, y: 0.062, z: 0.086 },
          "RightHandMiddle2.rotation": { x: 0.519, y: 3e-3, z: 0.011 },
          "RightHandMiddle3.rotation": { x: 0.252, y: -1e-3, z: 1e-3 },
          "RightHandRing1.rotation": { x: 0.207, y: 0.122, z: 0.155 },
          "RightHandRing2.rotation": { x: 0.597, y: 4e-3, z: 5e-3 },
          "RightHandRing3.rotation": { x: 0.292, y: 1e-3, z: 0.012 },
          "RightHandPinky1.rotation": { x: 0.338, y: 0.171, z: 0.149 },
          "RightHandPinky2.rotation": { x: 0.533, y: 2e-3, z: 4e-3 },
          "RightHandPinky3.rotation": { x: 0.194, y: 0, z: 2e-3 },
          "LeftUpLeg.rotation": { x: -1.957, y: 0.083, z: -2.886 },
          "LeftLeg.rotation": { x: -1.46, y: 0.123, z: 5e-3 },
          "LeftFoot.rotation": { x: -0.013, y: 0.016, z: 0.09 },
          "LeftToeBase.rotation": { x: 0.744, y: 0, z: 0 },
          "RightUpLeg.rotation": { x: -1.994, y: 0.125, z: 2.905 },
          "RightLeg.rotation": { x: -1.5, y: -0.202, z: -6e-3 },
          "RightFoot.rotation": { x: -0.012, y: -0.065, z: 0.081 },
          "RightToeBase.rotation": { x: 0.758, y: 0, z: 0 }
        }
      }
    };
    this.gestureTemplates = {
      "handup": {
        "LeftShoulder.rotation": { x: [1.5, 2, 1, 2], y: [0.2, 0.4, 1, 2], z: [-1.5, -1.3, 1, 2] },
        "LeftArm.rotation": { x: [1.5, 1.7, 1, 2], y: [-0.6, -0.4, 1, 2], z: [1, 1.2, 1, 2] },
        "LeftForeArm.rotation": { x: -0.815, y: [-0.4, 0, 1, 2], z: 1.575 },
        "LeftHand.rotation": { x: -0.529, y: -0.2, z: 0.022 },
        "LeftHandThumb1.rotation": { x: 0.745, y: -0.526, z: 0.604 },
        "LeftHandThumb2.rotation": { x: -0.107, y: -0.01, z: -0.142 },
        "LeftHandThumb3.rotation": { x: 0, y: 1e-3, z: 0 },
        "LeftHandIndex1.rotation": { x: -0.126, y: -0.035, z: -0.087 },
        "LeftHandIndex2.rotation": { x: 0.255, y: 7e-3, z: -0.085 },
        "LeftHandIndex3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandMiddle1.rotation": { x: -0.019, y: -0.128, z: -0.082 },
        "LeftHandMiddle2.rotation": { x: 0.233, y: 0.019, z: -0.074 },
        "LeftHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandRing1.rotation": { x: 5e-3, y: -0.241, z: -0.122 },
        "LeftHandRing2.rotation": { x: 0.261, y: 0.021, z: -0.076 },
        "LeftHandRing3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandPinky1.rotation": { x: 0.059, y: -0.336, z: -0.2 },
        "LeftHandPinky2.rotation": { x: 0.153, y: 0.019, z: 1e-3 },
        "LeftHandPinky3.rotation": { x: 0, y: 0, z: 0 }
      },
      "index": {
        "LeftShoulder.rotation": { x: [1.5, 2, 1, 2], y: [0.2, 0.4, 1, 2], z: [-1.5, -1.3, 1, 2] },
        "LeftArm.rotation": { x: [1.5, 1.7, 1, 2], y: [-0.6, -0.4, 1, 2], z: [1, 1.2, 1, 2] },
        "LeftForeArm.rotation": { x: -0.815, y: [-0.4, 0, 1, 2], z: 1.575 },
        "LeftHand.rotation": { x: -0.276, y: -0.506, z: -0.208 },
        "LeftHandThumb1.rotation": { x: 0.579, y: 0.228, z: 0.363 },
        "LeftHandThumb2.rotation": { x: -0.027, y: -0.04, z: -0.662 },
        "LeftHandThumb3.rotation": { x: 0, y: 1e-3, z: 0 },
        "LeftHandIndex1.rotation": { x: 0, y: -0.105, z: 0.225 },
        "LeftHandIndex2.rotation": { x: 0.256, y: -0.103, z: -0.213 },
        "LeftHandIndex3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandMiddle1.rotation": { x: 1.453, y: 0.07, z: 0.021 },
        "LeftHandMiddle2.rotation": { x: 1.599, y: 0.062, z: 0.07 },
        "LeftHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandRing1.rotation": { x: 1.528, y: -0.073, z: 0.052 },
        "LeftHandRing2.rotation": { x: 1.386, y: 0.044, z: 0.053 },
        "LeftHandRing3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandPinky1.rotation": { x: 1.65, y: -0.204, z: 0.031 },
        "LeftHandPinky2.rotation": { x: 1.302, y: 0.071, z: 0.085 },
        "LeftHandPinky3.rotation": { x: 0, y: 0, z: 0 }
      },
      "ok": {
        "LeftShoulder.rotation": { x: [1.5, 2, 1, 2], y: [0.2, 0.4, 1, 2], z: [-1.5, -1.3, 1, 2] },
        "LeftArm.rotation": { x: [1.5, 1.7, 1, 1], y: [-0.6, -0.4, 1, 2], z: [1, 1.2, 1, 2] },
        "LeftForeArm.rotation": { x: -0.415, y: [-0.4, 0, 1, 2], z: 1.575 },
        "LeftHand.rotation": { x: -0.476, y: -0.506, z: -0.208 },
        "LeftHandThumb1.rotation": { x: 0.703, y: 0.445, z: 0.899 },
        "LeftHandThumb2.rotation": { x: -0.312, y: -0.04, z: -0.938 },
        "LeftHandThumb3.rotation": { x: -0.37, y: 0.024, z: -0.393 },
        "LeftHandIndex1.rotation": { x: 0.8, y: -0.086, z: -0.091 },
        "LeftHandIndex2.rotation": { x: 1.123, y: -0.046, z: -0.074 },
        "LeftHandIndex3.rotation": { x: 0.562, y: -0.013, z: -0.043 },
        "LeftHandMiddle1.rotation": { x: -0.019, y: -0.128, z: -0.082 },
        "LeftHandMiddle2.rotation": { x: 0.233, y: 0.019, z: -0.074 },
        "LeftHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandRing1.rotation": { x: 5e-3, y: -0.241, z: -0.122 },
        "LeftHandRing2.rotation": { x: 0.261, y: 0.021, z: -0.076 },
        "LeftHandRing3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandPinky1.rotation": { x: 0.059, y: -0.336, z: -0.2 },
        "LeftHandPinky2.rotation": { x: 0.153, y: 0.019, z: 1e-3 },
        "LeftHandPinky3.rotation": { x: 0, y: 0, z: 0 }
      },
      "thumbup": {
        "LeftShoulder.rotation": { x: [1.5, 2, 1, 2], y: [0.2, 0.4, 1, 2], z: [-1.5, -1.3, 1, 2] },
        "LeftArm.rotation": { x: [1.5, 1.7, 1, 2], y: [-0.6, -0.4, 1, 2], z: [1, 1.2, 1, 2] },
        "LeftForeArm.rotation": { x: -0.415, y: 0.206, z: 1.575 },
        "LeftHand.rotation": { x: -0.276, y: -0.506, z: -0.208 },
        "LeftHandThumb1.rotation": { x: 0.208, y: -0.189, z: 0.685 },
        "LeftHandThumb2.rotation": { x: 0.129, y: -0.285, z: -0.163 },
        "LeftHandThumb3.rotation": { x: -0.047, y: 0.068, z: 0.401 },
        "LeftHandIndex1.rotation": { x: 1.412, y: -0.102, z: -0.152 },
        "LeftHandIndex2.rotation": { x: 1.903, y: -0.16, z: -0.114 },
        "LeftHandIndex3.rotation": { x: 0.535, y: -0.017, z: -0.062 },
        "LeftHandMiddle1.rotation": { x: 1.424, y: -0.103, z: -0.12 },
        "LeftHandMiddle2.rotation": { x: 1.919, y: -0.162, z: -0.114 },
        "LeftHandMiddle3.rotation": { x: 0.44, y: -0.012, z: -0.051 },
        "LeftHandRing1.rotation": { x: 1.619, y: -0.127, z: -0.053 },
        "LeftHandRing2.rotation": { x: 1.898, y: -0.16, z: -0.115 },
        "LeftHandRing3.rotation": { x: 0.262, y: -4e-3, z: -0.031 },
        "LeftHandPinky1.rotation": { x: 1.661, y: -0.131, z: -0.016 },
        "LeftHandPinky2.rotation": { x: 1.715, y: -0.067, z: -0.13 },
        "LeftHandPinky3.rotation": { x: 0.627, y: -0.023, z: -0.071 }
      },
      "thumbdown": {
        "LeftShoulder.rotation": { x: [1.5, 2, 1, 2], y: [0.2, 0.4, 1, 2], z: [-1.5, -1.3, 1, 2] },
        "LeftArm.rotation": { x: [1.5, 1.7, 1, 2], y: [-0.6, -0.4, 1, 2], z: [1, 1.2, 1, 2] },
        "LeftForeArm.rotation": { x: -2.015, y: 0.406, z: 1.575 },
        "LeftHand.rotation": { x: -0.176, y: -0.206, z: -0.208 },
        "LeftHandThumb1.rotation": { x: 0.208, y: -0.189, z: 0.685 },
        "LeftHandThumb2.rotation": { x: 0.129, y: -0.285, z: -0.163 },
        "LeftHandThumb3.rotation": { x: -0.047, y: 0.068, z: 0.401 },
        "LeftHandIndex1.rotation": { x: 1.412, y: -0.102, z: -0.152 },
        "LeftHandIndex2.rotation": { x: 1.903, y: -0.16, z: -0.114 },
        "LeftHandIndex3.rotation": { x: 0.535, y: -0.017, z: -0.062 },
        "LeftHandMiddle1.rotation": { x: 1.424, y: -0.103, z: -0.12 },
        "LeftHandMiddle2.rotation": { x: 1.919, y: -0.162, z: -0.114 },
        "LeftHandMiddle3.rotation": { x: 0.44, y: -0.012, z: -0.051 },
        "LeftHandRing1.rotation": { x: 1.619, y: -0.127, z: -0.053 },
        "LeftHandRing2.rotation": { x: 1.898, y: -0.16, z: -0.115 },
        "LeftHandRing3.rotation": { x: 0.262, y: -4e-3, z: -0.031 },
        "LeftHandPinky1.rotation": { x: 1.661, y: -0.131, z: -0.016 },
        "LeftHandPinky2.rotation": { x: 1.715, y: -0.067, z: -0.13 },
        "LeftHandPinky3.rotation": { x: 0.627, y: -0.023, z: -0.071 }
      },
      "side": {
        "LeftShoulder.rotation": { x: 1.755, y: -0.035, z: -1.63 },
        "LeftArm.rotation": { x: 1.263, y: -0.955, z: 1.024 },
        "LeftForeArm.rotation": { x: 0, y: 0, z: 0.8 },
        "LeftHand.rotation": { x: -0.36, y: -1.353, z: -0.184 },
        "LeftHandThumb1.rotation": { x: 0.137, y: -0.049, z: 0.863 },
        "LeftHandThumb2.rotation": { x: -0.293, y: 0.153, z: -0.193 },
        "LeftHandThumb3.rotation": { x: -0.271, y: -0.17, z: 0.18 },
        "LeftHandIndex1.rotation": { x: -0.018, y: 7e-3, z: 0.28 },
        "LeftHandIndex2.rotation": { x: 0.247, y: -3e-3, z: -0.025 },
        "LeftHandIndex3.rotation": { x: 0.13, y: -1e-3, z: -0.013 },
        "LeftHandMiddle1.rotation": { x: 0.333, y: -0.015, z: 0.182 },
        "LeftHandMiddle2.rotation": { x: 0.313, y: -5e-3, z: -0.032 },
        "LeftHandMiddle3.rotation": { x: 0.294, y: -4e-3, z: -0.03 },
        "LeftHandRing1.rotation": { x: 0.456, y: -0.028, z: -0.092 },
        "LeftHandRing2.rotation": { x: 0.53, y: -0.014, z: -0.052 },
        "LeftHandRing3.rotation": { x: 0.478, y: -0.012, z: -0.047 },
        "LeftHandPinky1.rotation": { x: 0.647, y: -0.049, z: -0.184 },
        "LeftHandPinky2.rotation": { x: 0.29, y: -4e-3, z: -0.029 },
        "LeftHandPinky3.rotation": { x: 0.501, y: -0.013, z: -0.049 }
      },
      "shrug": {
        "Neck.rotation": { x: [-0.3, 0.3, 1, 2], y: [-0.3, 0.3, 1, 2], z: [-0.1, 0.1] },
        "Head.rotation": { x: [-0.3, 0.3], y: [-0.3, 0.3], z: [-0.1, 0.1] },
        "RightShoulder.rotation": { x: 1.732, y: -0.058, z: 1.407 },
        "RightArm.rotation": { x: 1.305, y: 0.46, z: 0.118 },
        "RightForeArm.rotation": { x: [0, 2], y: [-1, 0.2], z: -1.637 },
        "RightHand.rotation": { x: -0.048, y: 0.165, z: -0.39 },
        "RightHandThumb1.rotation": { x: 1.467, y: 0.599, z: -1.315 },
        "RightHandThumb2.rotation": { x: -0.255, y: -0.123, z: 0.119 },
        "RightHandThumb3.rotation": { x: 0, y: -2e-3, z: 0 },
        "RightHandIndex1.rotation": { x: -0.293, y: -0.066, z: -0.112 },
        "RightHandIndex2.rotation": { x: 0.181, y: 7e-3, z: 0.069 },
        "RightHandIndex3.rotation": { x: 0, y: 0, z: 0 },
        "RightHandMiddle1.rotation": { x: -0.063, y: -0.041, z: 0.032 },
        "RightHandMiddle2.rotation": { x: 0.149, y: 5e-3, z: 0.05 },
        "RightHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
        "RightHandRing1.rotation": { x: 0.152, y: -0.03, z: 0.132 },
        "RightHandRing2.rotation": { x: 0.194, y: 7e-3, z: 0.058 },
        "RightHandRing3.rotation": { x: 0, y: 0, z: 0 },
        "RightHandPinky1.rotation": { x: 0.306, y: -0.015, z: 0.257 },
        "RightHandPinky2.rotation": { x: 0.15, y: -3e-3, z: -3e-3 },
        "RightHandPinky3.rotation": { x: 0, y: 0, z: 0 },
        "LeftShoulder.rotation": { x: 1.713, y: 0.141, z: -1.433 },
        "LeftArm.rotation": { x: 1.136, y: -0.422, z: -0.416 },
        "LeftForeArm.rotation": { x: 1.42, y: 0.123, z: 1.506 },
        "LeftHand.rotation": { x: 0.073, y: -0.138, z: 0.064 },
        "LeftHandThumb1.rotation": { x: 1.467, y: -0.599, z: 1.314 },
        "LeftHandThumb2.rotation": { x: -0.255, y: 0.123, z: -0.119 },
        "LeftHandThumb3.rotation": { x: 0, y: 1e-3, z: 0 },
        "LeftHandIndex1.rotation": { x: -0.293, y: 0.066, z: 0.112 },
        "LeftHandIndex2.rotation": { x: 0.181, y: -7e-3, z: -0.069 },
        "LeftHandIndex3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandMiddle1.rotation": { x: -0.062, y: 0.041, z: -0.032 },
        "LeftHandMiddle2.rotation": { x: 0.149, y: -5e-3, z: -0.05 },
        "LeftHandMiddle3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandRing1.rotation": { x: 0.152, y: 0.03, z: -0.132 },
        "LeftHandRing2.rotation": { x: 0.194, y: -7e-3, z: -0.058 },
        "LeftHandRing3.rotation": { x: 0, y: 0, z: 0 },
        "LeftHandPinky1.rotation": { x: 0.306, y: 0.015, z: -0.257 },
        "LeftHandPinky2.rotation": { x: 0.15, y: 3e-3, z: 3e-3 },
        "LeftHandPinky3.rotation": { x: 0, y: 0, z: 0 }
      },
      "namaste": {
        "RightShoulder.rotation": { x: 1.758, y: 0.099, z: 1.604 },
        "RightArm.rotation": { x: 0.862, y: -0.292, z: -0.932 },
        "RightForeArm.rotation": { x: 0.083, y: 0.066, z: -1.791 },
        "RightHand.rotation": { x: -0.52, y: -1e-3, z: -0.176 },
        "RightHandThumb1.rotation": { x: 0.227, y: 0.418, z: -0.776 },
        "RightHandThumb2.rotation": { x: -0.011, y: -3e-3, z: 0.171 },
        "RightHandThumb3.rotation": { x: -0.041, y: -1e-3, z: -0.013 },
        "RightHandIndex1.rotation": { x: -0.236, y: 3e-3, z: -0.028 },
        "RightHandIndex2.rotation": { x: 4e-3, y: 0, z: 1e-3 },
        "RightHandIndex3.rotation": { x: 2e-3, y: 0, z: 0 },
        "RightHandMiddle1.rotation": { x: -0.236, y: 3e-3, z: -0.028 },
        "RightHandMiddle2.rotation": { x: 4e-3, y: 0, z: 1e-3 },
        "RightHandMiddle3.rotation": { x: 2e-3, y: 0, z: 0 },
        "RightHandRing1.rotation": { x: -0.236, y: 3e-3, z: -0.028 },
        "RightHandRing2.rotation": { x: 4e-3, y: 0, z: 1e-3 },
        "RightHandRing3.rotation": { x: 2e-3, y: 0, z: 0 },
        "RightHandPinky1.rotation": { x: -0.236, y: 3e-3, z: -0.028 },
        "RightHandPinky2.rotation": { x: 4e-3, y: 0, z: 1e-3 },
        "RightHandPinky3.rotation": { x: 2e-3, y: 0, z: 0 },
        "LeftShoulder.rotation": { x: 1.711, y: -2e-3, z: -1.625 },
        "LeftArm.rotation": { x: 0.683, y: 0.334, z: 0.977 },
        "LeftForeArm.rotation": { x: 0.086, y: -0.066, z: 1.843 },
        "LeftHand.rotation": { x: -0.595, y: -0.229, z: 0.096 },
        "LeftHandThumb1.rotation": { x: 0.404, y: -0.05, z: 0.537 },
        "LeftHandThumb2.rotation": { x: -0.02, y: 4e-3, z: -0.154 },
        "LeftHandThumb3.rotation": { x: -0.049, y: 2e-3, z: -0.019 },
        "LeftHandIndex1.rotation": { x: -0.113, y: -1e-3, z: 0.014 },
        "LeftHandIndex2.rotation": { x: 3e-3, y: 0, z: 0 },
        "LeftHandIndex3.rotation": { x: 2e-3, y: 0, z: 0 },
        "LeftHandMiddle1.rotation": { x: -0.113, y: -1e-3, z: 0.014 },
        "LeftHandMiddle2.rotation": { x: 4e-3, y: 0, z: 0 },
        "LeftHandMiddle3.rotation": { x: 2e-3, y: 0, z: 0 },
        "LeftHandRing1.rotation": { x: -0.113, y: -1e-3, z: 0.014 },
        "LeftHandRing2.rotation": { x: 3e-3, y: 0, z: 0 },
        "LeftHandRing3.rotation": { x: 2e-3, y: 0, z: 0 },
        "LeftHandPinky1.rotation": { x: -0.122, y: -1e-3, z: -0.057 },
        "LeftHandPinky2.rotation": { x: 0.012, y: 1e-3, z: 0.07 },
        "LeftHandPinky3.rotation": { x: 2e-3, y: 0, z: 0 }
      }
    };
    this.poseDelta = {
      props: {
        "Hips.quaternion": { x: 0, y: 0, z: 0 },
        "Spine.quaternion": { x: 0, y: 0, z: 0 },
        "Spine1.quaternion": { x: 0, y: 0, z: 0 },
        "Neck.quaternion": { x: 0, y: 0, z: 0 },
        "Head.quaternion": { x: 0, y: 0, z: 0 },
        "Spine1.scale": { x: 0, y: 0, z: 0 },
        "Neck.scale": { x: 0, y: 0, z: 0 },
        "LeftArm.scale": { x: 0, y: 0, z: 0 },
        "RightArm.scale": { x: 0, y: 0, z: 0 }
      }
    };
    ["Left", "Right"].forEach((x) => {
      ["Leg", "UpLeg", "Arm", "ForeArm", "Hand"].forEach((y2) => {
        this.poseDelta.props[x + y2 + ".quaternion"] = { x: 0, y: 0, z: 0 };
      });
      ["HandThumb", "HandIndex", "HandMiddle", "HandRing", "HandPinky"].forEach((y2) => {
        this.poseDelta.props[x + y2 + "1.quaternion"] = { x: 0, y: 0, z: 0 };
        this.poseDelta.props[x + y2 + "2.quaternion"] = { x: 0, y: 0, z: 0 };
        this.poseDelta.props[x + y2 + "3.quaternion"] = { x: 0, y: 0, z: 0 };
      });
    });
    const names = /* @__PURE__ */ new Set();
    Object.values(this.poseTemplates).forEach((x) => {
      Object.keys(this.propsToThreeObjects(x.props)).forEach((y2) => names.add(y2));
    });
    Object.keys(this.poseDelta.props).forEach((x) => {
      names.add(x);
    });
    this.posePropNames = [...names];
    this.poseName = "side";
    this.poseWeightOnLeft = true;
    this.gesture = null;
    this.poseCurrentTemplate = this.poseTemplates[this.poseName];
    this.poseBase = this.poseFactory(this.poseCurrentTemplate);
    this.poseTarget = this.poseFactory(this.poseCurrentTemplate);
    this.poseStraight = this.propsToThreeObjects(this.poseTemplates["straight"].props);
    this.poseAvatar = null;
    this.avatarHeight = 1.7;
    this.animMoods = {
      "neutral": {
        baseline: { eyesLookDown: 0.1 },
        speech: { deltaRate: 0, deltaPitch: 0, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 1500, dt: [1200, 500, 1e3], vs: { chestInhale: [0.5, 0.5, 0] } },
          { name: "pose", alt: [
            { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["side"] } },
            {
              p: 0.4,
              delay: [5e3, 2e4],
              vs: { pose: ["hip"] },
              "M": { delay: [5e3, 2e4], vs: { pose: ["wide"] } }
            },
            { delay: [5e3, 2e4], vs: { pose: ["straight"] } }
          ] },
          {
            name: "head",
            idle: { delay: [0, 1e3], dt: [[200, 5e3]], vs: { headRotateX: [[-0.04, 0.1]], headRotateY: [[-0.3, 0.3]], headRotateZ: [[-0.08, 0.08]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [200, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-0.6, 0.6]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [1e3, 8e3, 1, 2], dt: [50, [100, 300], 100], vs: { eyeBlinkLeft: [1, 1, 0], eyeBlinkRight: [1, 1, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0, 0.3]], browOuterUpLeft: [[0, 0.3]], browOuterUpRight: [[0, 0.3]] } }
        ]
      },
      "happy": {
        baseline: { mouthSmile: 0.2, eyesLookDown: 0.1 },
        speech: { deltaRate: 0, deltaPitch: 0.1, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 1500, dt: [1200, 500, 1e3], vs: { chestInhale: [0.5, 0.5, 0] } },
          {
            name: "pose",
            idle: {
              alt: [
                { p: 0.6, delay: [5e3, 2e4], vs: { pose: ["side"] } },
                {
                  p: 0.2,
                  delay: [5e3, 2e4],
                  vs: { pose: ["hip"] },
                  "M": { delay: [5e3, 2e4], vs: { pose: ["side"] } }
                },
                { p: 0.1, delay: [5e3, 2e4], vs: { pose: ["straight"] } },
                { delay: [5e3, 1e4], vs: { pose: ["wide"] } },
                { delay: [1e3, 3e3], vs: { pose: ["turn"] } }
              ]
            },
            talking: {
              alt: [
                { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["side"] } },
                { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["straight"] } },
                {
                  delay: [5e3, 2e4],
                  vs: { pose: ["hip"] },
                  "M": { delay: [5e3, 2e4], vs: { pose: ["wide"] } }
                }
              ]
            }
          },
          {
            name: "head",
            idle: { dt: [[1e3, 5e3]], vs: { headRotateX: [[-0.04, 0.1]], headRotateY: [[-0.3, 0.3]], headRotateZ: [[-0.08, 0.08]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-0.6, 0.6]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [1e3, 8e3, 1, 2], dt: [50, [100, 300], 100], vs: { eyeBlinkLeft: [1, 1, 0], eyeBlinkRight: [1, 1, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthLeft: [[0, 0.3, 2]], mouthSmile: [[0, 0.2, 3]], mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0, 0.3]], browOuterUpLeft: [[0, 0.3]], browOuterUpRight: [[0, 0.3]] } }
        ]
      },
      "angry": {
        baseline: { eyesLookDown: 0.1, browDownLeft: 0.6, browDownRight: 0.6, jawForward: 0.3, mouthFrownLeft: 0.7, mouthFrownRight: 0.7, mouthRollLower: 0.2, mouthShrugLower: 0.3, handFistLeft: 1, handFistRight: 1 },
        speech: { deltaRate: -0.2, deltaPitch: 0.2, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 500, dt: [1e3, 500, 1e3], vs: { chestInhale: [0.7, 0.7, 0] } },
          { name: "pose", alt: [
            { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["side"] } },
            { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["straight"] } },
            {
              p: 0.2,
              delay: [5e3, 2e4],
              vs: { pose: ["hip"] },
              "M": { delay: [5e3, 2e4], vs: { pose: ["wide"] } }
            }
          ] },
          {
            name: "head",
            idle: { delay: [100, 500], dt: [[200, 5e3]], vs: { headRotateX: [[-0.04, 0.1]], headRotateY: [[-0.2, 0.2]], headRotateZ: [[-0.08, 0.08]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-0.6, 0.6]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [1e3, 8e3, 1, 2], dt: [50, [100, 300], 100], vs: { eyeBlinkLeft: [1, 1, 0], eyeBlinkRight: [1, 1, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0, 0.3]], browOuterUpLeft: [[0, 0.3]], browOuterUpRight: [[0, 0.3]] } }
        ]
      },
      "sad": {
        baseline: { eyesLookDown: 0.2, browDownRight: 0.1, browInnerUp: 0.6, browOuterUpRight: 0.2, eyeSquintLeft: 0.7, eyeSquintRight: 0.7, mouthFrownLeft: 0.8, mouthFrownRight: 0.8, mouthLeft: 0.2, mouthPucker: 0.5, mouthRollLower: 0.2, mouthRollUpper: 0.2, mouthShrugLower: 0.2, mouthShrugUpper: 0.2, mouthStretchLeft: 0.4 },
        speech: { deltaRate: -0.2, deltaPitch: -0.2, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 1500, dt: [1e3, 500, 1e3], vs: { chestInhale: [0.3, 0.3, 0] } },
          { name: "pose", alt: [
            { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["side"] } },
            { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["straight"] } },
            {
              delay: [5e3, 1e4],
              vs: { pose: ["side"] },
              full: { delay: [5e3, 1e4], vs: { pose: ["oneknee"] } }
            }
          ] },
          {
            name: "head",
            idle: { delay: [100, 500], dt: [[200, 5e3]], vs: { headRotateX: [[-0.04, 0.1]], headRotateY: [[-0.2, 0.2]], headRotateZ: [[-0.08, 0.08]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-0.6, 0.6]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [1e3, 8e3, 1, 2], dt: [50, [100, 300], 100], vs: { eyeBlinkLeft: [1, 1, 0], eyeBlinkRight: [1, 1, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0, 0.3]], browOuterUpLeft: [[0, 0.3]], browOuterUpRight: [[0, 0.3]] } }
        ]
      },
      "fear": {
        baseline: { browInnerUp: 0.7, eyeSquintLeft: 0.5, eyeSquintRight: 0.5, eyeWideLeft: 0.6, eyeWideRight: 0.6, mouthClose: 0.1, mouthFunnel: 0.3, mouthShrugLower: 0.5, mouthShrugUpper: 0.5 },
        speech: { deltaRate: -0.2, deltaPitch: 0, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 500, dt: [1e3, 500, 1e3], vs: { chestInhale: [0.7, 0.7, 0] } },
          { name: "pose", alt: [
            { p: 0.8, delay: [5e3, 2e4], vs: { pose: ["side"] } },
            { delay: [5e3, 2e4], vs: { pose: ["straight"] } },
            { delay: [5e3, 1e4], vs: { pose: ["wide"] } },
            {
              delay: [5e3, 1e4],
              vs: { pose: ["side"] },
              full: { delay: [5e3, 1e4], vs: { pose: ["oneknee"] } }
            }
          ] },
          {
            name: "head",
            idle: { delay: [100, 500], dt: [[200, 3e3]], vs: { headRotateX: [[-0.06, 0.12]], headRotateY: [[-0.7, 0.7]], headRotateZ: [[-0.1, 0.1]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [100, 2e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-1, 1]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [2e3, 8e3, 1, 2], dt: [50, [100, 300], 100], vs: { eyeBlinkLeft: [1, 1, 0], eyeBlinkRight: [1, 1, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0, 0.3]], browOuterUpLeft: [[0, 0.3]], browOuterUpRight: [[0, 0.3]] } }
        ]
      },
      "disgust": {
        baseline: { browDownLeft: 0.7, browDownRight: 0.1, browInnerUp: 0.3, eyeSquintLeft: 1, eyeSquintRight: 1, eyeWideLeft: 0.5, eyeWideRight: 0.5, eyesRotateX: 0.05, mouthLeft: 0.4, mouthPressLeft: 0.3, mouthRollLower: 0.3, mouthShrugLower: 0.3, mouthShrugUpper: 0.8, mouthUpperUpLeft: 0.3, noseSneerLeft: 1, noseSneerRight: 0.7 },
        speech: { deltaRate: -0.2, deltaPitch: 0, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 1500, dt: [1e3, 500, 1e3], vs: { chestInhale: [0.5, 0.5, 0] } },
          { name: "pose", alt: [
            { delay: [5e3, 1e4], vs: { pose: ["side"] } }
          ] },
          {
            name: "head",
            idle: { delay: [100, 500], dt: [[200, 5e3]], vs: { headRotateX: [[-0.04, 0.1]], headRotateY: [[-0.2, 0.2]], headRotateZ: [[-0.08, 0.08]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-0.6, 0.6]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [2e3, 8e3, 1, 2], dt: [50, [100, 300], 100], vs: { eyeBlinkLeft: [1, 1, 0], eyeBlinkRight: [1, 1, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0, 0.3]], browOuterUpLeft: [[0, 0.3]], browOuterUpRight: [[0, 0.3]] } }
        ]
      },
      "love": {
        baseline: { browInnerUp: 0.4, browOuterUpLeft: 0.2, browOuterUpRight: 0.2, mouthSmile: 0.2, eyeBlinkLeft: 0.6, eyeBlinkRight: 0.6, eyeWideLeft: 0.7, eyeWideRight: 0.7, headRotateX: 0.1, mouthDimpleLeft: 0.1, mouthDimpleRight: 0.1, mouthPressLeft: 0.2, mouthShrugUpper: 0.2, mouthUpperUpLeft: 0.1, mouthUpperUpRight: 0.1 },
        speech: { deltaRate: -0.1, deltaPitch: -0.7, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 1500, dt: [1500, 500, 1500], vs: { chestInhale: [0.8, 0.8, 0] } },
          { name: "pose", alt: [
            { p: 0.4, delay: [5e3, 2e4], vs: { pose: ["side"] } },
            { p: 0.2, delay: [5e3, 2e4], vs: { pose: ["straight"] } },
            {
              p: 0.2,
              delay: [5e3, 2e4],
              vs: { pose: ["hip"] },
              "M": { delay: [5e3, 2e4], vs: { pose: ["side"] } }
            },
            {
              delay: [5e3, 1e4],
              vs: { pose: ["side"] },
              full: { delay: [5e3, 1e4], vs: { pose: ["kneel"] } }
            },
            {
              delay: [1e3, 3e3],
              vs: { pose: ["turn"] },
              "M": { delay: [1e3, 3e3], vs: { pose: ["wide"] } }
            },
            {
              delay: [1e3, 3e3],
              vs: { pose: ["back"] },
              "M": { delay: [1e3, 3e3], vs: { pose: ["wide"] } }
            },
            {
              delay: [5e3, 2e4],
              vs: { pose: ["side"] },
              "M": { delay: [5e3, 2e4], vs: { pose: ["side"] } },
              full: { delay: [5e3, 2e4], vs: { pose: ["bend"] } }
            },
            {
              delay: [1e3, 3e3],
              vs: { pose: ["side"] },
              full: { delay: [5e3, 1e4], vs: { pose: ["oneknee"] } }
            }
          ] },
          {
            name: "head",
            idle: { dt: [[1e3, 5e3]], vs: { headRotateX: [[-0.04, 0.1]], headRotateY: [[-0.3, 0.3]], headRotateZ: [[-0.08, 0.08]] } },
            talking: { dt: [[0, 1e3, 0]], vs: { headRotateX: [[-0.05, 0.15, 1, 2]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.1, 0.1]] } }
          },
          { name: "eyes", delay: [300, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { eyesRotateY: [[-0.6, 0.6]], eyesRotateX: [[-0.2, 0.6]] } },
          { name: "blink", delay: [2e3, 8e3, 1, 2], dt: [50, [200, 300], 100], vs: { eyeBlinkLeft: [0.6, 0.6, 0], eyeBlinkRight: [0.6, 0.6, 0] } },
          { name: "mouth", delay: [1e3, 5e3], dt: [[100, 500], [100, 5e3, 2]], vs: { mouthLeft: [[0, 0.3, 2]], mouthRollLower: [[0, 0.3, 2]], mouthRollUpper: [[0, 0.3, 2]], mouthStretchLeft: [[0, 0.3]], mouthStretchRight: [[0, 0.3]], mouthPucker: [[0, 0.3]] } },
          { name: "misc", delay: [100, 5e3], dt: [[500, 1e3], [1e3, 5e3, 2]], vs: { eyeSquintLeft: [[0, 0.3, 3]], eyeSquintRight: [[0, 0.3, 3]], browInnerUp: [[0.3, 0.6]], browOuterUpLeft: [[0.1, 0.3]], browOuterUpRight: [[0.1, 0.3]] } }
        ]
      },
      "sleep": {
        baseline: { eyeBlinkLeft: 1, eyeBlinkRight: 1, eyesClosed: 0.6 },
        speech: { deltaRate: 0, deltaPitch: -0.2, deltaVolume: 0 },
        anims: [
          { name: "breathing", delay: 1500, dt: [1e3, 500, 1e3], vs: { chestInhale: [0.6, 0.6, 0] } },
          { name: "pose", alt: [
            { delay: [5e3, 2e4], vs: { pose: ["side"] } }
          ] },
          { name: "head", delay: [1e3, 5e3], dt: [[2e3, 1e4]], vs: { headRotateX: [[0, 0.4]], headRotateY: [[-0.1, 0.1]], headRotateZ: [[-0.04, 0.04]] } },
          { name: "eyes", delay: 10010, dt: [], vs: {} },
          { name: "blink", delay: 10020, dt: [], vs: {} },
          { name: "mouth", delay: 10030, dt: [], vs: {} },
          { name: "misc", delay: 10040, dt: [], vs: {} }
        ]
      }
    };
    this.moodName = this.opt.avatarMood || "neutral";
    this.mood = this.animMoods[this.moodName];
    if (!this.mood) {
      this.moodName = "neutral";
      this.mood = this.animMoods["neutral"];
    }
    this.randomized = [
      "mouthDippleLeft",
      "mouthDippleRight",
      "mouthLeft",
      "mouthPress",
      "mouthStretchLeft",
      "mouthStretchRight",
      "mouthShrugLower",
      "mouthShrugUpper",
      "noseSneerLeft",
      "noseSneerRight",
      "mouthRollLower",
      "mouthRollUpper",
      "browDownLeft",
      "browDownRight",
      "browOuterUpLeft",
      "browOuterUpRight",
      "cheekPuff",
      "cheekSquintLeft",
      "cheekSquintRight"
    ];
    this.animEmojis = {
      "": { dt: [300, 2e3], vs: { pose: ["straight"], browInnerUp: [0.4], eyeWideLeft: [0.7], eyeWideRight: [0.7], mouthPressLeft: [0.6], mouthPressRight: [0.6], mouthRollLower: [0.3], mouthStretchLeft: [1], mouthStretchRight: [1] } },
      "": { link: "" },
      "": { dt: [300, 2e3], vs: { browDownRight: [0.1], browInnerUp: [0.7], browOuterUpRight: [0.2], eyeLookInRight: [0.7], eyeLookOutLeft: [0.7], eyeSquintLeft: [1], eyeSquintRight: [0.8], eyesRotateY: [0.7], mouthLeft: [0.4], mouthPucker: [0.4], mouthShrugLower: [0.3], mouthShrugUpper: [0.2], mouthSmile: [0.2], mouthSmileLeft: [0.4], mouthSmileRight: [0.2], mouthStretchLeft: [0.5], mouthUpperUpLeft: [0.6], noseSneerLeft: [0.7] } },
      "": { dt: [300, 2e3], vs: { mouthSmile: [0.5] } },
      "": { link: "" },
      "": { dt: [300, 1e3, 1e3], vs: { browInnerUp: [0.6], eyeSquintLeft: [1], eyeSquintRight: [1], mouthSmile: [0.7], noseSneerLeft: [0.7], noseSneerRight: [0.7] } },
      "": { link: "" },
      "": { dt: [300, 2e3], vs: { browInnerUp: [0.6], jawOpen: [0.1], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthOpen: [0.3], mouthPressLeft: [0.3], mouthPressRight: [0.3], mouthRollLower: [0.4], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { dt: [300, 2e3], vs: { browInnerUp: [0.6], eyeWideLeft: [0.7], eyeWideRight: [0.7], jawOpen: [0.1], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthOpen: [0.3], mouthPressLeft: [0.3], mouthPressRight: [0.3], mouthRollLower: [0.4], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { dt: [300, 2e3], vs: { browInnerUp: [0.3], eyeSquintLeft: [1], eyeSquintRight: [1], jawOpen: [0.2], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthOpen: [0.3], mouthPressLeft: [0.3], mouthPressRight: [0.3], mouthRollLower: [0.4], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { dt: [300, 2e3], vs: { browInnerUp: [0.3], eyeSquintLeft: [1], eyeSquintRight: [1], jawOpen: [0.3], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthPressLeft: [0.5], mouthPressRight: [0.5], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { dt: [300, 2e3], vs: { browInnerUp: [0.3], eyeSquintLeft: [1], eyeSquintRight: [1], eyesClosed: [0.6], jawOpen: [0.3], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthPressLeft: [0.5], mouthPressRight: [0.5], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { dt: [300, 100, 1500, 500, 500], vs: { browInnerUp: [0.8], eyesClosed: [1], jawOpen: [0.7], mouthFunnel: [0.5], mouthSmile: [1], tongueOut: [0, 1, 1, 0] } },
      "": { link: "" },
      "": { link: "" },
      "": { link: "" },
      "": { link: "" },
      "": { link: "" },
      "": { dt: [300, 2e3], vs: { browInnerUp: [0.3], eyeSquintLeft: [1], eyeSquintRight: [1], eyesClosed: [0.6], jawOpen: [0.3], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthPressLeft: [0.5], mouthPressRight: [0.5], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { link: "" },
      "": { link: "" },
      "": { dt: [500, 200, 500, 500], vs: { mouthSmile: [0.5], mouthOpen: [0.2], mouthSmileLeft: [0, 0.5, 0], eyeBlinkLeft: [0, 0.7, 0], eyeBlinkRight: [0, 0, 0], headRotateX: [0.05, 0.05, 0.05, 0], headRotateZ: [-0.05, -0.05, -0.05, 0], browDownLeft: [0, 0.7, 0], cheekSquintLeft: [0, 0.7, 0], eyeSquintLeft: [0, 1, 0], eyesClosed: [0] } },
      "": { dt: [1e3, 1e3], vs: { browInnerUp: [1], eyeSquintLeft: [1], eyeSquintRight: [1], eyesClosed: [0.1], jawOpen: [0], mouthFrownLeft: [1], mouthFrownRight: [1], mouthOpen: [0.5], mouthPucker: [0.5], mouthUpperUpLeft: [0.6], mouthUpperUpRight: [0.6] } },
      "": { dt: [1e3, 1e3], vs: { browDownLeft: [0.2], browDownRight: [0.2], browInnerUp: [1], eyeWideLeft: [0.9], eyeWideRight: [0.9], eyesClosed: [0.1], mouthClose: [0.2], mouthFrownLeft: [1], mouthFrownRight: [1], mouthPressLeft: [0.4], mouthPressRight: [0.4], mouthPucker: [1], mouthRollLower: [0.6], mouthRollUpper: [0.2], mouthUpperUpLeft: [0.8], mouthUpperUpRight: [0.8] } },
      "": { dt: [1e3, 1e3], vs: { browInnerUp: [0.7], eyeSquintLeft: [1], eyeSquintRight: [1], eyesClosed: [0.5], headRotateX: [0.3], mouthClose: [0.2], mouthFrownLeft: [1], mouthFrownRight: [1], mouthPucker: [1], mouthRollLower: [1], mouthShrugLower: [0.2], mouthUpperUpLeft: [0.8], mouthUpperUpRight: [0.8] } },
      "": { dt: [1e3, 1e3], vs: { browInnerUp: [1], eyeSquintLeft: [1], eyeSquintRight: [1], eyesClosed: [0.5], headRotateX: [0.3], mouthClose: [0.2], mouthFrownLeft: [1], mouthFrownRight: [1], mouthPressLeft: [0.4], mouthPressRight: [0.4], mouthPucker: [1], mouthRollLower: [0.6], mouthRollUpper: [0.2], mouthUpperUpLeft: [0.8], mouthUpperUpRight: [0.8] } },
      "": { dt: [1e3, 1e3], vs: { browInnerUp: [1], eyeWideLeft: [0.5], eyeWideRight: [0.5], eyesRotateY: [0.05], eyesRotateX: [0.05], mouthClose: [0.2], mouthFunnel: [0.5], mouthPucker: [0.4], mouthRollLower: [0.4], mouthRollUpper: [0.4] } },
      "": { dt: [500, 1500], vs: { mouthFrownLeft: [1], mouthFrownRight: [1], mouthPucker: [0.1], mouthRollLower: [0.8] } },
      "": { dt: [500, 1e3, 1e3], vs: { browInnerUp: [0.6], eyeBlinkLeft: [1], eyeBlinkRight: [1], eyeSquintLeft: [1], eyeSquintRight: [1], mouthPucker: [0, 0.5], noseSneerLeft: [0, 0.7], noseSneerRight: [0, 0.7], viseme_U: [0, 1] } },
      "": { dt: [500, 500, 200, 500], vs: { browInnerUp: [0.6], eyeBlinkLeft: [0, 0, 1, 0], eyeBlinkRight: [0], eyesRotateY: [0], headRotateY: [0], headRotateX: [0, 0.05, 0.05, 0], headRotateZ: [0, -0.05, -0.05, 0], eyeSquintLeft: [1], eyeSquintRight: [1], mouthPucker: [0, 0.5, 0], noseSneerLeft: [0, 0.7], noseSneerRight: [0.7], viseme_U: [0, 1] } },
      "": { dt: [1e3, 1e3], vs: { browInnerUp: [0.6], eyeSquintLeft: [1], eyeSquintRight: [1], mouthSmile: [0.7], noseSneerLeft: [0.7], noseSneerRight: [0.7] } },
      "": { dt: [1e3, 1e3], vs: { browInnerUp: [0.6], jawOpen: [0.1], mouthDimpleLeft: [0.2], mouthDimpleRight: [0.2], mouthOpen: [0.3], mouthPressLeft: [0.3], mouthPressRight: [0.3], mouthRollLower: [0.4], mouthShrugUpper: [0.4], mouthSmile: [0.7], mouthUpperUpLeft: [0.3], mouthUpperUpRight: [0.3], noseSneerLeft: [0.4], noseSneerRight: [0.4] } },
      "": { link: "" },
      "": { dt: [1e3, 1500], vs: { browDownLeft: [1], browDownRight: [1], eyesLookUp: [0.2], jawForward: [0.3], mouthFrownLeft: [1], mouthFrownRight: [1], headRotateX: [0.15] } },
      "": { dt: [1e3, 1500], vs: { browDownLeft: [1], browDownRight: [1], eyesLookUp: [0.2], jawForward: [0.3], mouthFrownLeft: [1], mouthFrownRight: [1], headRotateX: [0.15] } },
      "": { link: "" },
      "": { dt: [1e3, 1e3], vs: { browDownRight: [0.1], browInnerUp: [0.7], browOuterUpRight: [0.2], eyeLookInRight: [0.7], eyeLookOutLeft: [0.7], eyeSquintLeft: [1], eyeSquintRight: [0.8], eyesRotateY: [0.7], mouthFrownLeft: [1], mouthFrownRight: [1], mouthLeft: [0.2], mouthPucker: [0.5], mouthRollLower: [0.2], mouthRollUpper: [0.2], mouthShrugLower: [0.2], mouthShrugUpper: [0.2], mouthStretchLeft: [0.5] } },
      "": { dt: [500, 1500], vs: { browInnerUp: [0.8], eyeWideLeft: [0.5], eyeWideRight: [0.5], jawOpen: [0.7], mouthFunnel: [0.5] } },
      "": { dt: [500, 1500], vs: { browDownLeft: [1], browDownRight: [1], browInnerUp: [1], mouthDimpleLeft: [0.5], mouthDimpleRight: [0.5], mouthLowerDownLeft: [1], mouthLowerDownRight: [1], mouthPressLeft: [0.4], mouthPressRight: [0.4], mouthPucker: [0.5], mouthSmile: [0.1], mouthSmileLeft: [0.2], mouthSmileRight: [0.2], mouthStretchLeft: [1], mouthStretchRight: [1], mouthUpperUpLeft: [1], mouthUpperUpRight: [1] } },
      "": { dt: [500, 1500], vs: { browInnerUp: [0.8], eyeWideLeft: [1], eyeWideRight: [1], eyesRotateX: [-0.8], headRotateX: [0.15], mouthPucker: [0.5], mouthRollLower: [0.6], mouthRollUpper: [0.5], mouthShrugLower: [0], mouthSmile: [0] } },
      "": { dt: [500, 1500], vs: {
        browDownLeft: [1],
        browOuterUpRight: [1],
        eyeSquintLeft: [0.6],
        mouthFrownLeft: [0.7],
        mouthFrownRight: [0.7],
        mouthLowerDownLeft: [0.3],
        mouthPressRight: [0.4],
        mouthPucker: [0.1],
        mouthRight: [0.5],
        mouthRollLower: [0.5],
        mouthRollUpper: [0.2],
        handRight: [{ x: 0.1, y: 0.1, z: 0.1, d: 1e3 }, { d: 1e3 }],
        handFistRight: [0.1]
      } },
      "": { dt: [500, 1500], vs: { eyesRotateY: [-0.8] } },
      "": { dt: [5e3, 5e3], vs: { eyeBlinkLeft: [1], eyeBlinkRight: [1], headRotateX: [0.2], headRotateZ: [0.1] } },
      "": { dt: [300, 2e3], vs: { mouthSmile: [0.5], gesture: [["handup", 2, true], null] } },
      "": { dt: [300, 2e3], vs: { mouthSmile: [0.5], gesture: [["handup", 2], null] } },
      "": { link: "" },
      "": { dt: [300, 2e3], vs: { mouthSmile: [0.5], gesture: [["thumbup", 2], null] } },
      "": { dt: [300, 2e3], vs: { browDownLeft: [1], browDownRight: [1], eyesLookUp: [0.2], jawForward: [0.3], mouthFrownLeft: [1], mouthFrownRight: [1], headRotateX: [0.15], gesture: [["thumbdown", 2], null] } },
      "": { dt: [300, 2e3], vs: { mouthSmile: [0.5], gesture: [["ok", 2], null] } },
      "": { dt: [1e3, 1500], vs: { gesture: [["shrug", 2], null] } },
      "": { link: "" },
      "": { link: "" },
      "": { dt: [1500, 300, 1e3], vs: { eyeBlinkLeft: [0, 1], eyeBlinkRight: [0, 1], headRotateX: [0], headRotateZ: [0.1], gesture: [["namaste", 2], null] } },
      "yes": { dt: [[200, 500], [200, 500], [200, 500], [200, 500]], vs: { headRotateX: [[0.1, 0.2], 0.1, [0.1, 0.2], 0], headRotateZ: [[-0.2, 0.2]] } },
      "no": { dt: [[200, 500], [200, 500], [200, 500], [200, 500], [200, 500]], vs: { headRotateY: [[-0.1, -0.05], [0.05, 0.1], [-0.1, -0.05], [0.05, 0.1], 0], headRotateZ: [[-0.2, 0.2]] } }
    };
    this.animBaseline = {};
    this.animFixed = {};
    this.animQueue = [];
    this.animClips = [];
    this.animPoses = [];
    this.animFrameDur = 1e3 / this.opt.modelFPS;
    this.animClock = 0;
    this.animSlowdownRate = 1;
    this.animTimeLast = 0;
    this.easing = this.sigmoidFactory(5);
    this.lipsync = {};
    this.opt.lipsyncModules.forEach((x) => this.lipsyncGetProcessor(x));
    this.visemeNames = [
      "aa",
      "E",
      "I",
      "O",
      "U",
      "PP",
      "SS",
      "TH",
      "DD",
      "FF",
      "kk",
      "nn",
      "RR",
      "CH",
      "sil"
    ];
    this.audioCtx = new AudioContext();
    this.audioSpeechSource = this.audioCtx.createBufferSource();
    this.audioBackgroundSource = this.audioCtx.createBufferSource();
    this.audioBackgroundGainNode = this.audioCtx.createGain();
    this.audioSpeechGainNode = this.audioCtx.createGain();
    this.audioReverbNode = this.audioCtx.createConvolver();
    this.setReverb(null);
    this.audioBackgroundGainNode.connect(this.audioReverbNode);
    this.audioSpeechGainNode.connect(this.audioReverbNode);
    this.audioReverbNode.connect(this.audioCtx.destination);
    this.audioPlaylist = [];
    const b64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    this.b64Lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (let i = 0; i < b64Chars.length; i++) this.b64Lookup[b64Chars.charCodeAt(i)] = i;
    this.stateName = "idle";
    this.speechQueue = [];
    this.isSpeaking = false;
    if (this.opt.ttsEndpoint) {
      let audio = new Audio();
      if (audio.canPlayType("audio/ogg")) {
        this.ttsAudioEncoding = "OGG-OPUS";
      } else if (audio.canPlayType("audio/mp3")) {
        this.ttsAudioEncoding = "MP3";
      } else {
        throw new Error("There was no support for either OGG or MP3 audio.");
      }
    } else {
      throw new Error("You must provide some Google-compliant Text-To-Speech Endpoint.");
    }
    this.renderer = new WebGLRenderer({ antialias: true, alpha: true });
    this.renderer.setPixelRatio(this.opt.modelPixelRatio * window.devicePixelRatio);
    this.renderer.setSize(this.nodeAvatar.clientWidth, this.nodeAvatar.clientHeight);
    this.renderer.outputColorSpace = SRGBColorSpace;
    this.renderer.toneMapping = ACESFilmicToneMapping;
    this.renderer.shadowMap.enabled = false;
    this.nodeAvatar.appendChild(this.renderer.domElement);
    this.camera = new PerspectiveCamera(10, this.nodeAvatar.clientWidth / this.nodeAvatar.clientHeight, 0.1, 2e3);
    this.scene = new Scene();
    this.lightAmbient = new AmbientLight(
      new Color(this.opt.lightAmbientColor),
      this.opt.lightAmbientIntensity
    );
    this.lightDirect = new DirectionalLight(
      new Color(this.opt.lightDirectColor),
      this.opt.lightDirectIntensity
    );
    this.lightSpot = new SpotLight(
      new Color(this.opt.lightSpotColor),
      this.opt.lightSpotIntensity,
      0,
      this.opt.lightSpotDispersion
    );
    this.setLighting(this.opt);
    const pmremGenerator = new PMREMGenerator(this.renderer);
    pmremGenerator.compileEquirectangularShader();
    this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment()).texture;
    this.resizeobserver = new ResizeObserver(this.onResize.bind(this));
    this.resizeobserver.observe(this.nodeAvatar);
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableZoom = this.opt.cameraZoomEnable;
    this.controls.enableRotate = this.opt.cameraRotateEnable;
    this.controls.enablePan = this.opt.cameraPanEnable;
    this.controls.minDistance = 2;
    this.controls.maxDistance = 2e3;
    this.controls.autoRotateSpeed = 0;
    this.controls.autoRotate = false;
    this.controls.update();
    this.cameraClock = null;
    this.ikMesh = new SkinnedMesh();
    const ikSetup = {
      "LeftShoulder": null,
      "LeftArm": "LeftShoulder",
      "LeftForeArm": "LeftArm",
      "LeftHand": "LeftForeArm",
      "LeftHandMiddle1": "LeftHand",
      "RightShoulder": null,
      "RightArm": "RightShoulder",
      "RightForeArm": "RightArm",
      "RightHand": "RightForeArm",
      "RightHandMiddle1": "RightHand"
    };
    const ikBones = [];
    Object.entries(ikSetup).forEach((e, i) => {
      const bone = new Bone();
      bone.name = e[0];
      if (e[1]) {
        this.ikMesh.getObjectByName(e[1]).add(bone);
      } else {
        this.ikMesh.add(bone);
      }
      ikBones.push(bone);
    });
    this.ikMesh.bind(new Skeleton(ikBones));
  }
  /**
  * Convert a Base64 MP3 chunk to ArrayBuffer.
  * @param {string} chunk Base64 encoded chunk
  * @return {ArrayBuffer} ArrayBuffer
  */
  b64ToArrayBuffer(chunk) {
    let bufLen = 3 * chunk.length / 4;
    if (chunk[chunk.length - 1] === "=") {
      bufLen--;
      if (chunk[chunk.length - 2] === "=") {
        bufLen--;
      }
    }
    const arrBuf = new ArrayBuffer(bufLen);
    const arr = new Uint8Array(arrBuf);
    let i, p2 = 0, c1, c2, c3, c4;
    for (i = 0; i < chunk.length; i += 4) {
      c1 = this.b64Lookup[chunk.charCodeAt(i)];
      c2 = this.b64Lookup[chunk.charCodeAt(i + 1)];
      c3 = this.b64Lookup[chunk.charCodeAt(i + 2)];
      c4 = this.b64Lookup[chunk.charCodeAt(i + 3)];
      arr[p2++] = c1 << 2 | c2 >> 4;
      arr[p2++] = (c2 & 15) << 4 | c3 >> 2;
      arr[p2++] = (c3 & 3) << 6 | c4 & 63;
    }
    return arrBuf;
  }
  /**
  * Concatenate an array of ArrayBuffers.
  * @param {ArrayBuffer[]} bufs Array of ArrayBuffers
  * @return {ArrayBuffer} Concatenated ArrayBuffer
  */
  concatArrayBuffers(bufs) {
    let len = 0;
    for (let i = 0; i < bufs.length; i++) {
      len += bufs[i].byteLength;
    }
    let buf = new ArrayBuffer(len);
    let arr = new Uint8Array(buf);
    let p2 = 0;
    for (let i = 0; i < bufs.length; i++) {
      arr.set(new Uint8Array(bufs[i]), p2);
      p2 += bufs[i].byteLength;
    }
    return buf;
  }
  /**
  * Convert PCM buffer to AudioBuffer.
  * NOTE: Only signed 16bit little endian supported.
  * @param {ArrayBuffer} buf PCM buffer
  * @return {AudioBuffer} AudioBuffer
  */
  pcmToAudioBuffer(buf) {
    const arr = new Int16Array(buf);
    const floats = new Float32Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      floats[i] = arr[i] >= 32768 ? -(65536 - arr[i]) / 32768 : arr[i] / 32767;
    }
    const audio = this.audioCtx.createBuffer(1, floats.length, this.opt.pcmSampleRate);
    audio.copyToChannel(floats, 0, 0);
    return audio;
  }
  /**
  * Convert internal notation to THREE objects.
  * NOTE: All rotations are converted to quaternions.
  * @param {Object} p Pose
  * @return {Object} A new pose object.
  */
  propsToThreeObjects(p2) {
    const r2 = {};
    for (let [key, val] of Object.entries(p2)) {
      const ids = key.split(".");
      let v2;
      let x = Array.isArray(val.x) ? this.gaussianRandom(...val.x) : val.x;
      let y2 = Array.isArray(val.y) ? this.gaussianRandom(...val.y) : val.y;
      let z2 = Array.isArray(val.z) ? this.gaussianRandom(...val.z) : val.z;
      if (ids[1] === "position" || ids[1] === "scale") {
        v2 = new Vector3(x, y2, z2);
      } else if (ids[1] === "rotation") {
        key = ids[0] + ".quaternion";
        v2 = new Quaternion().setFromEuler(new Euler(x, y2, z2, "XYZ")).normalize();
      } else if (ids[1] === "quaternion") {
        v2 = new Quaternion(x, y2, z2, val.w).normalize();
      }
      if (v2) {
        r2[key] = v2;
      }
    }
    return r2;
  }
  /**
  * Clear 3D object.
  * @param {Object} obj Object
  */
  clearThree(obj) {
    while (obj.children.length) {
      this.clearThree(obj.children[0]);
      obj.remove(obj.children[0]);
    }
    if (obj.geometry) obj.geometry.dispose();
    if (obj.material) {
      Object.keys(obj.material).forEach((x) => {
        if (obj.material[x] && obj.material[x] !== null && typeof obj.material[x].dispose === "function") {
          obj.material[x].dispose();
        }
      });
      obj.material.dispose();
    }
  }
  /**
  * Loader for 3D avatar model.
  * @param {string} avatar Avatar object with 'url' property to GLTF/GLB file.
  * @param {progressfn} [onprogress=null] Callback for progress
  */
  async showAvatar(avatar, onprogress = null) {
    if (!avatar || !avatar.hasOwnProperty("url")) {
      throw new Error("Invalid parameter. The avatar must have at least 'url' specified.");
    }
    const loader = new GLTFLoader();
    let gltf = await loader.loadAsync(avatar.url, onprogress);
    const required = [this.opt.modelRoot];
    this.posePropNames.forEach((x) => required.push(x.split(".")[0]));
    required.forEach((x) => {
      if (!gltf.scene.getObjectByName(x)) {
        throw new Error("Avatar object " + x + " not found");
      }
    });
    this.stop();
    this.avatar = avatar;
    this.mixer = null;
    if (this.armature) {
      this.clearThree(this.scene);
    }
    this.armature = gltf.scene.getObjectByName(this.opt.modelRoot);
    this.armature.scale.setScalar(1);
    this.morphs = [];
    this.armature.traverse((x) => {
      if (x.morphTargetInfluences && x.morphTargetInfluences.length && x.morphTargetDictionary) {
        this.morphs.push(x);
      }
      x.frustumCulled = false;
    });
    if (this.morphs.length === 0) {
      throw new Error("Blend shapes not found");
    }
    this.poseAvatar = { props: {} };
    this.posePropNames.forEach((x) => {
      const ids = x.split(".");
      const o = this.armature.getObjectByName(ids[0]);
      this.poseAvatar.props[x] = o[ids[1]];
      if (this.poseBase.props.hasOwnProperty(x)) {
        this.poseAvatar.props[x].copy(this.poseBase.props[x]);
      } else {
        this.poseBase.props[x] = this.poseAvatar.props[x].clone();
      }
      if (this.poseDelta.props.hasOwnProperty(x) && !this.poseTarget.props.hasOwnProperty(x)) {
        this.poseTarget.props[x] = this.poseAvatar.props[x].clone();
      }
      this.poseTarget.props[x].t = this.animClock;
      this.poseTarget.props[x].d = 2e3;
    });
    this.ikMesh.traverse((x) => {
      if (x.isBone) {
        x.position.copy(this.armature.getObjectByName(x.name).position);
      }
    });
    this.scene.add(gltf.scene);
    this.scene.add(this.lightAmbient);
    this.scene.add(this.lightDirect);
    this.scene.add(this.lightSpot);
    this.lightSpot.target = this.armature.getObjectByName("Head");
    const plEye = new Vector3();
    this.armature.getObjectByName("LeftEye").getWorldPosition(plEye);
    this.avatarHeight = plEye.y + 0.2;
    if (!this.viewName) this.setView(this.opt.cameraView);
    this.setMood(this.avatar.avatarMood || this.moodName || this.opt.avatarMood);
    this.start();
  }
  /**
  * Get view names.
  * @return {string[]} Supported view names.
  */
  getViewNames() {
    return ["full", "mid", "upper", "head"];
  }
  /**
  * Get current view.
  * @return {string} View name.
  */
  getView() {
    return this.viewName;
  }
  /**
  * Fit 3D object to the view.
  * @param {string} [view=null] Camera view. If null, reset current view
  * @param {Object} [opt=null] Options
  */
  setView(view, opt = null) {
    if (view !== "full" && view !== "upper" && view !== "head" && view !== "mid") return;
    if (!this.armature) {
      this.opt.cameraView = view;
      return;
    }
    this.viewName = view || this.viewName;
    opt = opt || {};
    const fov2 = this.camera.fov * (Math.PI / 180);
    let x = -(opt.cameraX || this.opt.cameraX) * Math.tan(fov2 / 2);
    let y2 = (1 - (opt.cameraY || this.opt.cameraY)) * Math.tan(fov2 / 2);
    let z2 = opt.cameraDistance || this.opt.cameraDistance;
    if (this.viewName === "head") {
      z2 += 2;
      y2 = y2 * z2 + 4 * this.avatarHeight / 5;
    } else if (this.viewName === "upper") {
      z2 += 4.5;
      y2 = y2 * z2 + 2 * this.avatarHeight / 3;
    } else if (this.viewName === "mid") {
      z2 += 8;
      y2 = y2 * z2 + this.avatarHeight / 3;
    } else {
      z2 += 12;
      y2 = y2 * z2;
    }
    x = x * z2;
    this.controlsEnd = new Vector3(x, y2, 0);
    this.cameraEnd = new Vector3(x, y2, z2).applyEuler(new Euler(opt.cameraRotateX || opt.cameraRotateX, opt.cameraRotateY || this.opt.cameraRotateY, 0));
    if (this.cameraClock === null) {
      this.controls.target.copy(this.controlsEnd);
      this.camera.position.copy(this.cameraEnd);
    }
    this.controlsStart = this.controls.target.clone();
    this.cameraStart = this.camera.position.clone();
    this.cameraClock = 0;
  }
  /**
  * Change light colors and intensities.
  * @param {Object} opt Options
  */
  setLighting(opt) {
    opt = opt || {};
    if (opt.hasOwnProperty("lightAmbientColor")) {
      this.lightAmbient.color.set(new Color(opt.lightAmbientColor));
    }
    if (opt.hasOwnProperty("lightAmbientIntensity")) {
      this.lightAmbient.intensity = opt.lightAmbientIntensity;
      this.lightAmbient.visible = opt.lightAmbientIntensity !== 0;
    }
    if (opt.hasOwnProperty("lightDirectColor")) {
      this.lightDirect.color.set(new Color(opt.lightDirectColor));
    }
    if (opt.hasOwnProperty("lightDirectIntensity")) {
      this.lightDirect.intensity = opt.lightDirectIntensity;
      this.lightDirect.visible = opt.lightDirectIntensity !== 0;
    }
    if (opt.hasOwnProperty("lightDirectPhi") && opt.hasOwnProperty("lightDirectTheta")) {
      this.lightDirect.position.setFromSphericalCoords(2, opt.lightDirectPhi, opt.lightDirectTheta);
    }
    if (opt.hasOwnProperty("lightSpotColor")) {
      this.lightSpot.color.set(new Color(opt.lightSpotColor));
    }
    if (opt.hasOwnProperty("lightSpotIntensity")) {
      this.lightSpot.intensity = opt.lightSpotIntensity;
      this.lightSpot.visible = opt.lightSpotIntensity !== 0;
    }
    if (opt.hasOwnProperty("lightSpotPhi") && opt.hasOwnProperty("lightSpotTheta")) {
      this.lightSpot.position.setFromSphericalCoords(2, opt.lightSpotPhi, opt.lightSpotTheta);
      this.lightSpot.position.add(new Vector3(0, 1.5, 0));
    }
    if (opt.hasOwnProperty("lightSpotDispersion")) {
      this.lightSpot.angle = opt.lightSpotDispersion;
    }
  }
  /**
  * Render scene.
  */
  render() {
    if (this.isRunning) {
      const blinkl = this.getValue("eyeBlinkLeft");
      const blinkr = this.getValue("eyeBlinkRight");
      const lookdown = this.getValue("eyesLookDown") / 2;
      const limitl = lookdown + this.getValue("browDownLeft") / 2;
      const limitr = lookdown + this.getValue("browDownRight") / 2;
      this.setValue("eyeBlinkLeft", Math.max(blinkl, limitl));
      this.setValue("eyeBlinkRight", Math.max(blinkr, limitr));
      this.renderer.render(this.scene, this.camera);
      this.setValue("eyeBlinkLeft", blinkl);
      this.setValue("eyeBlinkRight", blinkr);
    }
  }
  /**
  * Resize avatar.
  */
  onResize() {
    this.camera.aspect = this.nodeAvatar.clientWidth / this.nodeAvatar.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.nodeAvatar.clientWidth, this.nodeAvatar.clientHeight);
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }
  /**
  * Update avatar pose.
  * @param {number} t High precision timestamp in ms.
  */
  updatePoseBase(t2) {
    for (const [key, v2] of Object.entries(this.poseTarget.props)) {
      const o = this.poseAvatar.props[key];
      if (o) {
        const alpha = (t2 - v2.t) / v2.d;
        if (alpha > 1 || !this.poseBase.props.hasOwnProperty(key)) {
          o.copy(v2);
        } else {
          if (o.isQuaternion) {
            o.copy(this.poseBase.props[key].slerp(v2, this.easing(alpha)));
          } else if (o.isVector3) {
            o.copy(this.poseBase.props[key].lerp(v2, this.easing(alpha)));
          }
        }
      }
    }
  }
  /**
  * Update avatar pose deltas
  */
  updatePoseDelta() {
    for (const [key, d] of Object.entries(this.poseDelta.props)) {
      const e = new Euler(d.x, d.y, d.z);
      const o = this.poseAvatar.props[key];
      if (o.isQuaternion) {
        const q2 = new Quaternion().setFromEuler(e).normalize();
        o.multiply(q2);
      } else if (o.isVector3) {
        o.add(e);
      }
    }
  }
  /**
  * Get given pose as a string.
  * @param {Object} pose Pose
  * @param {number} [prec=1000] Precision used in values
  * @return {string} Pose as a string
  */
  getPoseString(pose, prec = 1e3) {
    let s = "{";
    Object.entries(pose).forEach((x, i) => {
      const ids = x[0].split(".");
      if (ids[1] === "position" || ids[1] === "rotation" || ids[1] === "quaternion") {
        const key = ids[1] === "quaternion" ? ids[0] + ".rotation" : x[0];
        const val = x[1].isQuaternion ? new Euler().setFromQuaternion(x[1]) : x[1];
        s += (i ? ", " : "") + "'" + key + "':{";
        s += "x:" + Math.round(val.x * prec) / prec;
        s += ", y:" + Math.round(val.y * prec) / prec;
        s += ", z:" + Math.round(val.z * prec) / prec;
        s += "}";
      }
    });
    s += "}";
    return s;
  }
  /**
  * Return pose template property taking into account mirror pose and gesture.
  * @param {string} key Property key
  * @return {Quaternion|Vector3} Position or rotation
  */
  getPoseTemplateProp(key) {
    const ids = key.split(".");
    let target = ids[0] + "." + (ids[1] === "rotation" ? "quaternion" : ids[1]);
    if (this.gesture && this.gesture.hasOwnProperty(target)) {
      return this.gesture[target].clone();
    } else {
      let source = ids[0] + "." + (ids[1] === "quaternion" ? "rotation" : ids[1]);
      if (!this.poseWeightOnLeft) {
        if (source.startsWith("Left")) {
          source = "Right" + source.substring(4);
          target = "Right" + target.substring(4);
        } else if (source.startsWith("Right")) {
          source = "Left" + source.substring(5);
          target = "Left" + target.substring(5);
        }
      }
      let q2;
      if (this.poseTarget.template.props.hasOwnProperty(target)) {
        const o = {};
        o[target] = this.poseTarget.template.props[target];
        q2 = this.propsToThreeObjects(o)[target];
      } else if (this.poseTarget.template.props.hasOwnProperty(source)) {
        const o = {};
        o[source] = this.poseTarget.template.props[source];
        q2 = this.propsToThreeObjects(o)[target];
      }
      if (q2 && !this.poseWeightOnLeft && q2.isQuaternion) {
        q2.x *= -1;
        q2.w *= -1;
      }
      return q2;
    }
  }
  /**
  * Change body weight from current leg to another.
  * @param {Object} p Pose properties
  * @return {Object} Mirrored pose.
  */
  mirrorPose(p2) {
    const r2 = {};
    for (let [key, v2] of Object.entries(p2)) {
      if (v2.isQuaternion) {
        if (key.startsWith("Left")) {
          key = "Right" + key.substring(4);
        } else if (key.startsWith("Right")) {
          key = "Left" + key.substring(5);
        }
        v2.x *= -1;
        v2.w *= -1;
      }
      r2[key] = v2.clone();
      r2[key].t = v2.t;
      r2[key].d = v2.d;
    }
    return r2;
  }
  /**
  * Create a new pose.
  * @param {Object} template Pose template
  * @param {numeric} [ms=2000] Transition duration in ms
  * @return {Object} A new pose object.
  */
  poseFactory(template, ms = 2e3) {
    const o = {
      template,
      props: this.propsToThreeObjects(template.props)
    };
    for (const [p2, v2] of Object.entries(o.props)) {
      if (this.opt.modelMovementFactor < 1 && template.standing && (p2 === "Hips.quaternion" || p2 === "Spine.quaternion" || p2 === "Spine1.quaternion" || p2 === "Spine2.quaternion" || p2 === "Neck.quaternion" || p2 === "LeftUpLeg.quaternion" || p2 === "LeftLeg.quaternion" || p2 === "RightUpLeg.quaternion" || p2 === "RightLeg.quaternion")) {
        const ref = this.poseStraight[p2];
        const angle = v2.angleTo(ref);
        v2.rotateTowards(ref, (1 - this.opt.modelMovementFactor) * angle);
      }
      v2.t = this.animClock;
      v2.d = ms;
    }
    return o;
  }
  /**
  * Set a new pose and start transition timer.
  * @param {Object} template Pose template, if null update current pose
  * @param {number} [ms=2000] Transition time in milliseconds
  */
  setPoseFromTemplate(template, ms = 2e3) {
    const isIntermediate = template && this.poseTarget && this.poseTarget.template && (this.poseTarget.template.standing && template.lying || this.poseTarget.template.lying && template.standing);
    const isSameTemplate = template && template === this.poseCurrentTemplate;
    const isWeightOnLeft = this.poseWeightOnLeft;
    let duration = isIntermediate ? 1e3 : ms;
    if (isIntermediate) {
      this.poseCurrentTemplate = this.poseTemplates["oneknee"];
      setTimeout(() => {
        this.setPoseFromTemplate(template, ms);
      }, duration);
    } else {
      this.poseCurrentTemplate = template || this.poseCurrentTemplate;
    }
    this.poseTarget = this.poseFactory(this.poseCurrentTemplate, duration);
    this.poseWeightOnLeft = true;
    if (!isSameTemplate && !isWeightOnLeft || isSameTemplate && isWeightOnLeft) {
      this.poseTarget.props = this.mirrorPose(this.poseTarget.props);
      this.poseWeightOnLeft = !this.poseWeightOnLeft;
    }
    if (this.gesture) {
      for (let [p2, v2] of Object.entries(this.gesture)) {
        if (this.poseTarget.props.hasOwnProperty(p2)) {
          this.poseTarget.props[p2].copy(v2);
          this.poseTarget.props[p2].t = v2.t;
          this.poseTarget.props[p2].d = v2.d;
        }
      }
    }
    Object.keys(this.poseDelta.props).forEach((key) => {
      if (!this.poseTarget.props.hasOwnProperty(key)) {
        this.poseTarget.props[key] = this.poseBase.props[key].clone();
        this.poseTarget.props[key].t = this.animClock;
        this.poseTarget.props[key].d = duration;
      }
    });
  }
  /**
  * Get morph target value.
  * @param {string} mt Morph target
  * @return {number} Value
  */
  getValue(mt) {
    if (mt === "headRotateX") {
      return this.poseDelta.props["Head.quaternion"].x;
    } else if (mt === "headRotateY") {
      return this.poseDelta.props["Head.quaternion"].y;
    } else if (mt === "headRotateZ") {
      return this.poseDelta.props["Head.quaternion"].z;
    } else if (mt.startsWith("handFist")) {
      const side = mt.substring(8);
      return this.poseDelta.props[side + "HandMiddle1.quaternion"].x;
    } else if (mt === "chestInhale") {
      return this.poseDelta.props["Spine1.scale"].x * 20;
    } else {
      const ndx = this.morphs[0].morphTargetDictionary[mt];
      if (ndx !== void 0) {
        return this.morphs[0].morphTargetInfluences[ndx];
      } else {
        return 0;
      }
    }
  }
  /**
  * Set morph target value.
  * @param {string} mt Morph target
  * @param {number} v Value
  */
  setValue(mt, v2) {
    if (mt === "headRotateX") {
      this.poseDelta.props["Head.quaternion"].x = v2;
      this.poseDelta.props["Spine1.quaternion"].x = v2 / 2;
      this.poseDelta.props["Spine.quaternion"].x = v2 / 8;
      this.poseDelta.props["Hips.quaternion"].x = v2 / 24;
    } else if (mt === "headRotateY") {
      this.poseDelta.props["Head.quaternion"].y = v2;
      this.poseDelta.props["Spine1.quaternion"].y = v2 / 2;
      this.poseDelta.props["Spine.quaternion"].y = v2 / 2;
      this.poseDelta.props["Hips.quaternion"].y = v2 / 4;
      this.poseDelta.props["LeftUpLeg.quaternion"].y = v2 / 2;
      this.poseDelta.props["RightUpLeg.quaternion"].y = v2 / 2;
      this.poseDelta.props["LeftLeg.quaternion"].y = v2 / 4;
      this.poseDelta.props["RightLeg.quaternion"].y = v2 / 4;
    } else if (mt === "headRotateZ") {
      this.poseDelta.props["Head.quaternion"].z = v2;
      this.poseDelta.props["Spine1.quaternion"].z = v2 / 12;
      this.poseDelta.props["Spine.quaternion"].z = v2 / 12;
      this.poseDelta.props["Hips.quaternion"].z = v2 / 24;
    } else if (mt.startsWith("handFist")) {
      const side = mt.substring(8);
      [
        "HandThumb",
        "HandIndex",
        "HandMiddle",
        "HandRing",
        "HandPinky"
      ].forEach((x, i) => {
        if (i === 0) {
          this.poseDelta.props[side + x + "1.quaternion"].x = 0;
          this.poseDelta.props[side + x + "2.quaternion"].z = (side === "Left" ? -1 : 1) * v2;
          this.poseDelta.props[side + x + "3.quaternion"].z = (side === "Left" ? -1 : 1) * v2;
        } else {
          this.poseDelta.props[side + x + "1.quaternion"].x = v2;
          this.poseDelta.props[side + x + "2.quaternion"].x = 1.5 * v2;
          this.poseDelta.props[side + x + "3.quaternion"].x = 1.5 * v2;
        }
      });
    } else if (mt === "chestInhale") {
      const scale = v2 / 20;
      const d = { x: scale, y: scale / 2, z: 3 * scale };
      const dneg = { x: 1 / (1 + scale) - 1, y: 1 / (1 + scale / 2) - 1, z: 1 / (1 + 3 * scale) - 1 };
      this.poseDelta.props["Spine1.scale"] = d;
      this.poseDelta.props["Neck.scale"] = dneg;
      this.poseDelta.props["LeftArm.scale"] = dneg;
      this.poseDelta.props["RightArm.scale"] = dneg;
    } else {
      this.morphs.forEach((x) => {
        const ndx = x.morphTargetDictionary[mt];
        if (ndx !== void 0) {
          x.morphTargetInfluences[ndx] = v2;
        }
      });
    }
  }
  /**
  * Get mood names.
  * @return {string[]} Mood names.
  */
  getMoodNames() {
    return Object.keys(this.animMoods);
  }
  /**
  * Get current mood.
  * @return {string[]} Mood name.
  */
  getMood() {
    return this.opt.avatarMood;
  }
  /**
  * Set mood.
  * @param {string} s Mood name.
  */
  setMood(s) {
    s = (s || "").trim().toLowerCase();
    if (!this.animMoods.hasOwnProperty(s)) throw new Error("Unknown mood.");
    this.moodName = s;
    this.mood = this.animMoods[this.moodName];
    for (let mt of ["handFistLeft", "handFistRight", ...Object.keys(this.morphs[0].morphTargetDictionary)]) {
      this.setBaselineValue(mt, this.mood.baseline.hasOwnProperty(mt) ? this.mood.baseline[mt] : 0);
    }
    this.mood.anims.forEach((x) => {
      let i = this.animQueue.findIndex((y2) => y2.template.name === x.name);
      if (i !== -1) {
        this.animQueue.splice(i, 1);
      }
      this.animQueue.push(this.animFactory(x, -1));
    });
  }
  /**
  * Get morph target names.
  * @return {string[]} Morph target names.
  */
  getMorphTargetNames() {
    return [
      "headRotateX",
      "headRotateY",
      "headRotateZ",
      "eyesRotateX",
      "eyesRotateY",
      "chestInhale",
      "handFistLeft",
      "handFistRight",
      ...Object.keys(this.morphs[0].morphTargetDictionary)
    ].sort();
  }
  /**
  * Get baseline value for the morph target.
  * @param {string} mt Morph target name
  * @return {number} Value, undefined if not in baseline
  */
  getBaselineValue(mt) {
    if (mt === "eyesRotateY") {
      const ll2 = this.getBaselineValue("eyeLookOutLeft");
      if (ll2 === void 0) return void 0;
      const lr = this.getBaselineValue("eyeLookInLeft");
      if (lr === void 0) return void 0;
      const rl2 = this.getBaselineValue("eyeLookOurRight");
      if (rl2 === void 0) return void 0;
      const rr = this.getBaselineValue("eyeLookInRight");
      if (rr === void 0) return void 0;
      return ll2 - lr;
    } else if (mt === "eyesRotateX") {
      const d = this.getBaselineValue("eyesLookDown");
      if (d === void 0) return void 0;
      const u2 = this.getBaselineValue("eyeLookUp");
      if (u2 === void 0) return void 0;
      return d - u2;
    } else {
      return this.animBaseline.hasOwnProperty(mt) ? this.animBaseline[mt].target : void 0;
    }
  }
  /**
  * Set baseline for morph target.
  * @param {string} mt Morph target name
  * @param {number} v Value, null if to be removed from baseline
  */
  setBaselineValue(mt, v2) {
    if (mt === "eyesRotateY") {
      this.setBaselineValue("eyeLookOutLeft", v2 === null ? null : v2 > 0 ? v2 : 0);
      this.setBaselineValue("eyeLookInLeft", v2 === null ? null : v2 > 0 ? 0 : -v2);
      this.setBaselineValue("eyeLookOutRight", v2 === null ? null : v2 > 0 ? 0 : -v2);
      this.setBaselineValue("eyeLookInRight", v2 === null ? null : v2 > 0 ? v2 : 0);
    } else if (mt === "eyesRotateX") {
      this.setBaselineValue("eyesLookDown", v2 === null ? null : v2 > 0 ? v2 : 0);
      this.setBaselineValue("eyesLookUp", v2 === null ? null : v2 > 0 ? 0 : -v2);
    } else if (mt === "eyeLookOutLeft" || mt === "eyeLookInLeft" || mt === "eyeLookOutRight" || mt === "eyeLookInRight" || mt === "eyesLookDown" || mt === "eyesLookUp") ;
    else {
      if (v2 === null) {
        if (this.animBaseline.hasOwnProperty(mt)) {
          delete this.animBaseline[mt];
        }
      } else {
        this.animBaseline[mt] = { target: v2 };
      }
    }
  }
  /**
  * Get fixed value for the morph target.
  * @param {string} mt Morph target name
  * @return {number} Value, undefined if not fixed
  */
  getFixedValue(mt) {
    if (mt === "eyesRotateY") {
      const ll2 = this.getFixedValue("eyeLookOutLeft");
      if (ll2 === void 0) return void 0;
      const lr = this.getFixedValue("eyeLookInLeft");
      if (lr === void 0) return void 0;
      const rl2 = this.getFixedValue("eyeLookOutRight");
      if (rl2 === void 0) return void 0;
      const rr = this.getFixedValue("eyeLookInRight");
      if (rr === void 0) return void 0;
      return ll2 - lr;
    } else if (mt === "eyesRotateX") {
      const d = this.getFixedValue("eyesLookDown");
      if (d === void 0) return void 0;
      const u2 = this.getFixedValue("eyeLookUp");
      if (u2 === void 0) return void 0;
      return d - u2;
    } else {
      return this.animFixed.hasOwnProperty(mt) ? this.animFixed[mt].target : void 0;
    }
  }
  /**
  * Fix morph target.
  * @param {string} mt Morph target name
  * @param {number} v Value, null if to be removed
  */
  setFixedValue(mt, v2) {
    if (mt === "eyesRotateY") {
      this.setFixedValue("eyeLookOutLeft", v2 === null ? null : v2 > 0 ? v2 : 0);
      this.setFixedValue("eyeLookInLeft", v2 === null ? null : v2 > 0 ? 0 : -v2);
      this.setFixedValue("eyeLookOutRight", v2 === null ? null : v2 > 0 ? 0 : -v2);
      this.setFixedValue("eyeLookInRight", v2 === null ? null : v2 > 0 ? v2 : 0);
    } else if (mt === "eyesRotateX") {
      this.setFixedValue("eyesLookDown", v2 === null ? null : v2 > 0 ? v2 : 0);
      this.setFixedValue("eyesLookUp", v2 === null ? null : v2 > 0 ? 0 : -v2);
    } else {
      if (v2 === null) {
        if (this.animFixed.hasOwnProperty(mt)) {
          delete this.animFixed[mt];
        }
      } else {
        this.animFixed[mt] = { target: v2 };
      }
    }
  }
  /**
  * Create a new animation based on an animation template.
  * @param {Object} t Animation template
  * @param {number} [loop=false] Number of loops, false if not looped
  * @param {number} [scaleTime=1] Scale template times
  * @param {number} [scaleValue=1] Scale template values
  * @return {Object} New animation object.
  */
  animFactory(t2, loop = false, scaleTime = 1, scaleValue = 1) {
    const o = { template: t2, ts: [0], vs: {} };
    let a = t2;
    while (1) {
      if (a.hasOwnProperty(this.stateName)) {
        a = a[this.stateName];
      } else if (a.hasOwnProperty(this.moodName)) {
        a = a[this.moodName];
      } else if (a.hasOwnProperty(this.poseName)) {
        a = a[this.poseName];
      } else if (a.hasOwnProperty(this.viewName)) {
        a = a[this.viewName];
      } else if (this.avatar.body && a.hasOwnProperty(this.avatar.body)) {
        a = a[this.avatar.body];
      } else if (a.hasOwnProperty("alt")) {
        let b = a.alt[0];
        if (a.alt.length > 1) {
          const coin = Math.random();
          let p2 = 0;
          for (let i = 0; i < a.alt.length; i++) {
            p2 += a.alt[i].p || (1 - p2) / (a.alt.length - i);
            if (coin < p2) {
              b = a.alt[i];
              break;
            }
          }
        }
        a = b;
      } else {
        break;
      }
    }
    const delay = a.delay ? Array.isArray(a.delay) ? this.gaussianRandom(...a.delay) : a.delay : 0;
    if (a.hasOwnProperty("dt")) {
      a.dt.forEach((x, i) => {
        o.ts[i + 1] = o.ts[i] + (Array.isArray(x) ? this.gaussianRandom(...x) : x);
      });
    }
    o.ts = o.ts.map((x) => this.animClock + delay + x * scaleTime);
    for (let [mt, vs] of Object.entries(a.vs)) {
      const base = this.getBaselineValue(mt);
      const v2 = vs.map((x) => {
        if (x === null) {
          return null;
        } else if (typeof x === "function") {
          return x;
        } else if (typeof x === "string" || x instanceof String) {
          return x.slice();
        } else if (Array.isArray(x)) {
          if (mt === "gesture") {
            return x.slice();
          } else {
            return (base === void 0 ? 0 : base) + scaleValue * this.gaussianRandom(...x);
          }
        } else if (x instanceof Object && x.constructor === Object) {
          return Object.assign({}, x);
        } else {
          return (base === void 0 ? 0 : base) + scaleValue * x;
        }
      });
      if (mt === "eyesRotateY") {
        o.vs["eyeLookOutLeft"] = [null, ...v2.map((x) => x > 0 ? x : 0)];
        o.vs["eyeLookInLeft"] = [null, ...v2.map((x) => x > 0 ? 0 : -x)];
        o.vs["eyeLookOutRight"] = [null, ...v2.map((x) => x > 0 ? 0 : -x)];
        o.vs["eyeLookInRight"] = [null, ...v2.map((x) => x > 0 ? x : 0)];
      } else if (mt === "eyesRotateX") {
        o.vs["eyesLookDown"] = [null, ...v2.map((x) => x > 0 ? x : 0)];
        o.vs["eyesLookUp"] = [null, ...v2.map((x) => x > 0 ? 0 : -x)];
      } else {
        o.vs[mt] = [null, ...v2];
      }
    }
    for (let mt of Object.keys(o.vs)) {
      while (o.vs[mt].length - 1 < o.ts.length) o.vs[mt].push(o.vs[mt][o.vs[mt].length - 1]);
    }
    if (t2.hasOwnProperty("mood")) o.mood = t2.mood.slice();
    if (loop) o.loop = loop;
    return o;
  }
  /**
  * Calculate the correct value based on a given time using the given function.
  * @param {number[]} ts Time sequence
  * @param {number[]} vs Value sequence
  * @param {number} t Time.
  * @param {function} [fun=null] Ease in and out function, null = use linear function
  * @return {number} Value based on the given time.
  */
  valueAnimationSeq(ts, vs, t2, fun = null) {
    let iMin = 0;
    let iMax = ts.length - 1;
    if (t2 <= ts[iMin]) return typeof vs[iMin] === "function" ? vs[iMin]() : vs[iMin];
    if (t2 >= ts[iMax]) return typeof vs[iMax] === "function" ? vs[iMax]() : vs[iMax];
    while (t2 > ts[iMin + 1]) iMin++;
    iMax = iMin + 1;
    let k2 = ((typeof vs[iMax] === "function" ? vs[iMax]() : vs[iMax]) - (typeof vs[iMin] === "function" ? vs[iMin]() : vs[iMin])) / (ts[iMax] - ts[iMin]);
    if (fun) k2 = fun((t2 - ts[iMin]) / (ts[iMax] - ts[iMin])) * k2;
    const b = (typeof vs[iMin] === "function" ? vs[iMin]() : vs[iMin]) - k2 * ts[iMin];
    return k2 * t2 + b;
  }
  /**
  * Return gaussian distributed random value between start and end with skew.
  * @param {number} start Start value
  * @param {number} end End value
  * @param {number} [skew=1] Skew
  * @param {number} [samples=5] Number of samples, 1 = uniform distribution.
  * @return {number} Gaussian random value.
  */
  gaussianRandom(start, end, skew = 1, samples = 5) {
    let r2 = 0;
    for (let i = 0; i < samples; i++) r2 += Math.random();
    return start + Math.pow(r2 / samples, skew) * (end - start);
  }
  /**
  * Create a sigmoid function.
  * @param {number} k Sharpness of ease.
  * @return {function} Sigmoid function.
  */
  sigmoidFactory(k2) {
    function base(t2) {
      return 1 / (1 + Math.exp(-k2 * t2)) - 0.5;
    }
    var corr = 0.5 / base(1);
    return function(t2) {
      return corr * base(2 * Math.max(Math.min(t2, 1), 0) - 1) + 0.5;
    };
  }
  /**
  * Convert value from one range to another.
  * @param {number} value Value
  * @param {number[]} r1 Source range
  * @param {number[]} r2 Target range
  * @return {number} Scaled value
  */
  convertRange(value, r1, r2) {
    return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];
  }
  /**
  * Animate the avatar.
  * @param {number} t High precision timestamp in ms.
  */
  animate(t2) {
    if (this.isRunning) {
      requestAnimationFrame(this.animate.bind(this));
    } else {
      return;
    }
    let dt = t2 - this.animTimeLast;
    if (dt < this.animFrameDur) return;
    dt = dt / this.animSlowdownRate;
    this.animClock += dt;
    this.animTimeLast = t2;
    if (this.stats) {
      this.stats.begin();
    }
    if (this.viewName !== "full") {
      const randomizedMs = this.randomized[Math.floor(Math.random() * this.randomized.length)];
      const v2 = this.getValue(randomizedMs);
      const vb2 = this.getBaselineValue(randomizedMs);
      if (v2 === vb2) {
        const randomizedV = (this.mood.baseline[randomizedMs] || 0) + Math.random() / 5;
        this.setBaselineValue(randomizedMs, randomizedV);
      }
    }
    const o = {};
    for (let [mt, x] of Object.entries(this.animBaseline)) {
      const v2 = this.getValue(mt);
      const restrain = this.isSpeaking && mt.startsWith("mouth") ? 3 : 1;
      const target = x.target / restrain;
      if (v2 !== target) {
        if (x.t0 === void 0) {
          x.t0 = this.animClock;
          x.v0 = v2;
        }
        let delay = 1e3;
        o[mt] = this.valueAnimationSeq([x.t0, x.t0 + delay], [x.v0, target], this.animClock, this.easing);
      } else {
        x.t0 = void 0;
      }
    }
    for (let i = 0; i < this.animQueue.length; i++) {
      const x = this.animQueue[i];
      if (this.animClock >= x.ts[0]) {
        for (let [mt, vs] of Object.entries(x.vs)) {
          if (mt === "subtitles") {
            o[mt] = o.hasOwnProperty(mt) ? o[mt] + vs : "" + vs;
            delete x.vs[mt];
          } else if (mt === "function") {
            vs.forEach((fn) => {
              if (fn && typeof fn === "function") {
                fn();
              }
            });
            delete x.vs[mt];
          } else if (mt === "speak") {
            o[mt] = o.hasOwnProperty(mt) ? o[mt] + " " + vs : "" + vs;
            delete x.vs[mt];
          } else if (mt === "pose") {
            o[mt] = "" + vs[1];
            delete x.vs[mt];
          } else if (mt === "gesture") {
            for (let j = 0; j < x.ts.length; j++) {
              if (vs[j] && this.animClock >= x.ts[j]) {
                o[mt] = vs[j];
                vs[j] = null;
              }
            }
          } else if (mt === "moveto" || mt === "handLeft" || mt === "handRight") {
            for (let j = 0; j < x.ts.length; j++) {
              if (vs[j] && this.animClock >= x.ts[j]) {
                o[mt] = Object.assign(o[mt] || {}, vs[j]);
                vs[j] = null;
              }
            }
          } else {
            if (vs[0] === null) vs[0] = this.getValue(mt);
            o[mt] = this.valueAnimationSeq(x.ts, vs, this.animClock, this.easing);
            if (this.animBaseline.hasOwnProperty(mt)) this.animBaseline[mt].t0 = void 0;
            for (let j = 0; j < i; j++) {
              if (this.animQueue[j].vs.hasOwnProperty(mt)) delete this.animQueue[j].vs[mt];
            }
          }
        }
        if (this.animClock >= x.ts[x.ts.length - 1]) {
          if (x.hasOwnProperty("mood")) this.setMood(x.mood);
          if (x.loop) {
            let restrain = this.isSpeaking && (x.template.name === "head" || x.template.name === "eyes") ? 4 : 1;
            this.animQueue[i] = this.animFactory(x.template, x.loop > 0 ? x.loop - 1 : x.loop, 1, 1 / restrain);
          } else {
            this.animQueue.splice(i--, 1);
          }
        }
      }
    }
    for (let [mt, x] of Object.entries(this.animFixed)) {
      const v2 = this.getValue(mt);
      if (v2 !== x.target) {
        if (x.t0 === void 0) {
          x.t0 = this.animClock;
          x.v0 = v2;
        }
        let delay = 1e3;
        o[mt] = this.valueAnimationSeq([x.t0, x.t0 + delay], [x.v0, x.target], this.animClock, this.easing);
      } else {
        if (o.hasOwnProperty(mt)) delete o[mt];
        x.t0 = void 0;
      }
      if (this.animBaseline.hasOwnProperty(mt)) this.animBaseline[mt].t0 = void 0;
    }
    for (let [mt, x] of Object.entries(o)) {
      if (mt === "subtitles") {
        if (this.onSubtitles && typeof this.onSubtitles === "function") {
          this.onSubtitles("" + x);
        }
      } else if (mt === "speak") {
        this.speakText("" + x);
      } else if (mt === "pose") {
        this.poseName = "" + x;
        this.setPoseFromTemplate(this.poseTemplates[this.poseName]);
      } else if (mt === "gesture") {
        this.playGesture(...x);
      } else if (mt === "moveto") {
        Object.entries(x.props).forEach((e) => {
          if (e[1]) {
            this.poseTarget.props[e[0]].copy(e[1]);
          } else {
            this.poseTarget.props[e[0]].copy(this.getPoseTemplateProp(e[0]));
          }
          this.poseTarget.props[e[0]].t = this.animClock;
          this.poseTarget.props[e[0]].d = e[1] && e[1].d ? e[1].d : x.duration || 2e3;
        });
      } else if (mt === "handLeft") {
        this.ikSolve({
          iterations: 20,
          root: "LeftShoulder",
          effector: "LeftHandMiddle1",
          links: [
            { link: "LeftHand", minx: -0.5, maxx: 0.5, miny: -1, maxy: 1, minz: -0.5, maxz: 0.5 },
            { link: "LeftForeArm", minx: -0.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -0.5, maxz: 3 },
            { link: "LeftArm", minx: -1.5, maxx: 1.5, miny: 0, maxy: 0, minz: -1, maxz: 3 }
          ]
        }, x.x ? new Vector3(x.x, x.y, x.z) : null, true, x.d);
      } else if (mt === "handRight") {
        this.ikSolve({
          iterations: 20,
          root: "RightShoulder",
          effector: "RightHandMiddle1",
          links: [
            { link: "RightHand", minx: -0.5, maxx: 0.5, miny: -1, maxy: 1, minz: -0.5, maxz: 0.5, maxAngle: 0.1 },
            { link: "RightForeArm", minx: -0.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -3, maxz: 0.5, maxAngle: 0.2 },
            { link: "RightArm", minx: -1.5, maxx: 1.5, miny: 0, maxy: 0, minz: -1, maxz: 3 }
          ]
        }, x.x ? new Vector3(x.x, x.y, x.z) : null, true, x.d);
      } else {
        this.setValue(mt, x);
      }
    }
    this.updatePoseBase(this.animClock);
    if (this.mixer) {
      this.mixer.update(dt / 1e3 * this.mixer.timeScale);
    }
    this.updatePoseDelta();
    const box = new Box3();
    box.setFromObject(this.armature);
    const ltoePos = new Vector3();
    const rtoePos = new Vector3();
    this.armature.getObjectByName("LeftToeBase").getWorldPosition(ltoePos);
    this.armature.getObjectByName("RightToeBase").getWorldPosition(rtoePos);
    const hips = this.armature.getObjectByName("Hips");
    hips.position.y -= box.min.y / 2;
    hips.position.x -= (ltoePos.x + rtoePos.x) / 4;
    hips.position.z -= (ltoePos.z + rtoePos.z) / 2;
    if (this.cameraClock !== null && this.cameraClock < 1e3) {
      this.cameraClock += dt;
      if (this.cameraClock > 1e3) this.cameraClock = 1e3;
      let s = new Spherical().setFromVector3(this.cameraStart);
      let sEnd = new Spherical().setFromVector3(this.cameraEnd);
      s.phi += this.easing(this.cameraClock / 1e3) * (sEnd.phi - s.phi);
      s.theta += this.easing(this.cameraClock / 1e3) * (sEnd.theta - s.theta);
      s.radius += this.easing(this.cameraClock / 1e3) * (sEnd.radius - s.radius);
      s.makeSafe();
      this.camera.position.setFromSpherical(s);
      if (this.controlsStart.x !== this.controlsEnd.x) {
        this.controls.target.copy(this.controlsStart.lerp(this.controlsEnd, this.easing(this.cameraClock / 1e3)));
      } else {
        s.setFromVector3(this.controlsStart);
        sEnd.setFromVector3(this.controlsEnd);
        s.phi += this.easing(this.cameraClock / 1e3) * (sEnd.phi - s.phi);
        s.theta += this.easing(this.cameraClock / 1e3) * (sEnd.theta - s.theta);
        s.radius += this.easing(this.cameraClock / 1e3) * (sEnd.radius - s.radius);
        s.makeSafe();
        this.controls.target.setFromSpherical(s);
      }
      this.controls.update();
    }
    if (this.controls.autoRotate) this.controls.update();
    if (this.stats) {
      this.stats.end();
    }
    this.render();
  }
  /**
  * Reset all the visemes
  */
  resetLips() {
    this.visemeNames.forEach((x) => {
      this.morphs.forEach((y2) => {
        const ndx = y2.morphTargetDictionary["viseme_" + x];
        if (ndx !== void 0) {
          y2.morphTargetInfluences[ndx] = 0;
        }
      });
    });
  }
  /**
  * Get lip-sync processor based on language. Import module dynamically.
  * @param {string} lang Language
  * @return {Object} Pre-processsed text.
  */
  lipsyncGetProcessor(lang, path = "./") {
    if (!this.lipsync.hasOwnProperty(lang)) {
      const moduleName = path + "lipsync-" + lang.toLowerCase() + ".mjs";
      const className = "Lipsync" + lang.charAt(0).toUpperCase() + lang.slice(1);
      import(moduleName).then((module) => {
        this.lipsync[lang] = new module[className]();
      });
    }
  }
  /**
  * Preprocess text for tts/lipsync, including:
  * - convert symbols/numbers to words
  * - filter out characters that should be left unspoken
  * @param {string} s Text
  * @param {string} lang Language
  * @return {string} Pre-processsed text.
  */
  lipsyncPreProcessText(s, lang) {
    const o = this.lipsync[lang] || Object.values(this.lipsync)[0];
    return o.preProcessText(s);
  }
  /**
  * Convert words to Oculus LipSync Visemes.
  * @param {string} w Word
  * @param {string} lang Language
  * @return {Lipsync} Lipsync object.
  */
  lipsyncWordsToVisemes(w2, lang) {
    const o = this.lipsync[lang] || Object.values(this.lipsync)[0];
    return o.wordsToVisemes(w2);
  }
  /**
  * Add text to the speech queue.
  * @param {string} s Text.
  * @param {Options} [opt=null] Text-specific options for lipsync/TTS language, voice, rate and pitch, mood and mute
  * @param {subtitlesfn} [onsubtitles=null] Callback when a subtitle is written
  * @param {number[][]} [excludes=null] Array of [start, end] index arrays to not speak
  */
  speakText(s, opt = null, onsubtitles = null, excludes = null) {
    opt = opt || {};
    const dividersSentence = /[!\.\?\n\p{Extended_Pictographic}]/ug;
    const dividersWord = /[ ]/ug;
    const speakables = /[\p{L}\p{N},\.'!\$\+\p{Dash_Punctuation}%&\?]/ug;
    const emojis = /[\p{Extended_Pictographic}]/ug;
    const lipsyncLang = opt.lipsyncLang || this.avatar.lipsyncLang || this.opt.lipsyncLang;
    let markdownWord = "";
    let textWord = "";
    let markId = 0;
    let ttsSentence = [];
    let lipsyncAnim = [];
    const letters = [...s];
    for (let i = 0; i < letters.length; i++) {
      const isLast = i === letters.length - 1;
      const isSpeakable = letters[i].match(speakables);
      const isEndOfSentence = letters[i].match(dividersSentence);
      const isEndOfWord = letters[i].match(dividersWord);
      if (onsubtitles) {
        markdownWord += letters[i];
      }
      if (isSpeakable) {
        if (!excludes || excludes.every((x) => i < x[0] || i > x[1])) {
          textWord += letters[i];
        }
      }
      if (isEndOfWord || isEndOfSentence || isLast) {
        if (textWord.length) {
          textWord = this.lipsyncPreProcessText(textWord, lipsyncLang);
          if (textWord.length) {
            ttsSentence.push({
              mark: markId,
              word: textWord
            });
          }
        }
        if (markdownWord.length) {
          lipsyncAnim.push({
            mark: markId,
            template: { name: "subtitles" },
            ts: [0],
            vs: {
              subtitles: markdownWord
            }
          });
          markdownWord = "";
        }
        if (textWord.length) {
          const v2 = this.lipsyncWordsToVisemes(textWord, lipsyncLang);
          if (v2 && v2.visemes && v2.visemes.length) {
            const d = v2.times[v2.visemes.length - 1] + v2.durations[v2.visemes.length - 1];
            for (let j = 0; j < v2.visemes.length; j++) {
              lipsyncAnim.push({
                mark: markId,
                template: { name: "viseme" },
                ts: [(v2.times[j] - 0.6) / d, (v2.times[j] + 0.5) / d, (v2.times[j] + v2.durations[j] + 0.5) / d],
                vs: {
                  ["viseme_" + v2.visemes[j]]: [null, v2.visemes[j] === "PP" || v2.visemes[j] === "FF" ? 0.9 : 0.6, 0]
                }
              });
            }
          }
          textWord = "";
          markId++;
        }
      }
      if (isEndOfSentence || isLast) {
        if (ttsSentence.length || isLast && lipsyncAnim.length) {
          const o = {
            anim: lipsyncAnim
          };
          if (onsubtitles) o.onSubtitles = onsubtitles;
          if (ttsSentence.length && !opt.avatarMute) {
            o.text = ttsSentence;
            if (opt.avatarMood) o.mood = opt.avatarMood;
            if (opt.ttsLang) o.lang = opt.ttsLang;
            if (opt.ttsVoice) o.voice = opt.ttsVoice;
            if (opt.ttsRate) o.rate = opt.ttsRate;
            if (opt.ttsVoice) o.pitch = opt.ttsPitch;
            if (opt.ttsVolume) o.volume = opt.ttsVolume;
          }
          this.speechQueue.push(o);
          ttsSentence = [];
          textWord = "";
          markId = 0;
          lipsyncAnim = [];
        }
        if (letters[i].match(emojis)) {
          let emoji = this.animEmojis[letters[i]];
          if (emoji && emoji.link) emoji = this.animEmojis[emoji.link];
          if (emoji) {
            this.speechQueue.push({ emoji });
          }
        }
        this.speechQueue.push({ break: 100 });
      }
    }
    this.speechQueue.push({ break: 1e3 });
    this.startSpeaking();
  }
  /**
  * Add emoji to speech queue.
  * @param {string} e Emoji.
  */
  async speakEmoji(e) {
    let emoji = this.animEmojis[e];
    if (emoji && emoji.link) emoji = this.animEmojis[emoji.link];
    if (emoji) {
      this.speechQueue.push({ emoji });
    }
    this.startSpeaking();
  }
  /**
  * Add a break to the speech queue.
  * @param {numeric} t Duration in milliseconds.
  */
  async speakBreak(t2) {
    this.speechQueue.push({ break: t2 });
    this.startSpeaking();
  }
  /**
  * Callback when speech queue processes this marker.
  * @param {markerfn} onmarker Callback function.
  */
  async speakMarker(onmarker) {
    this.speechQueue.push({ marker: onmarker });
    this.startSpeaking();
  }
  /**
  * Play background audio.
  * @param {string} url URL for the audio, stop if null.
  */
  async playBackgroundAudio(url) {
    let response = await fetch(url);
    let arraybuffer = await response.arrayBuffer();
    this.stopBackgroundAudio();
    this.audioBackgroundSource = this.audioCtx.createBufferSource();
    this.audioBackgroundSource.loop = true;
    this.audioBackgroundSource.buffer = await this.audioCtx.decodeAudioData(arraybuffer);
    this.audioBackgroundSource.playbackRate.value = 1 / this.animSlowdownRate;
    this.audioBackgroundSource.connect(this.audioBackgroundGainNode);
    this.audioBackgroundSource.start(0);
  }
  /**
  * Stop background audio.
  */
  stopBackgroundAudio() {
    try {
      this.audioBackgroundSource.stop();
    } catch (error) {
    }
    this.audioBackgroundSource.disconnect();
  }
  /**
  * Setup the convolver node based on an impulse.
  * @param {string} [url=null] URL for the impulse, dry impulse if null
  */
  async setReverb(url = null) {
    if (url) {
      let response = await fetch(url);
      let arraybuffer = await response.arrayBuffer();
      this.audioReverbNode.buffer = await this.audioCtx.decodeAudioData(arraybuffer);
    } else {
      const samplerate = this.audioCtx.sampleRate;
      const impulse = this.audioCtx.createBuffer(2, samplerate, samplerate);
      impulse.getChannelData(0)[0] = 1;
      impulse.getChannelData(1)[0] = 1;
      this.audioReverbNode.buffer = impulse;
    }
  }
  /**
  * Set audio gain.
  * @param {number} speech Gain for speech, if null do not change
  * @param {number} background Gain for background audio, if null do not change
  */
  setMixerGain(speech, background) {
    if (speech !== null) {
      this.audioSpeechGainNode.gain.value = speech;
    }
    if (background !== null) {
      this.audioBackgroundGainNode.gain.value = background;
    }
  }
  /**
  * Add audio to the speech queue.
  * @param {Audio} r Audio message.
  * @param {Options} [opt=null] Text-specific options for lipsyncLang
  * @param {subtitlesfn} [onsubtitles=null] Callback when a subtitle is written
  */
  speakAudio(r2, opt = null, onsubtitles = null) {
    opt = opt || {};
    const lipsyncLang = opt.lipsyncLang || this.avatar.lipsyncLang || this.opt.lipsyncLang;
    const o = {};
    if (r2.words) {
      let lipsyncAnim = [];
      for (let i = 0; i < r2.words.length; i++) {
        const word = r2.words[i];
        const time = r2.wtimes[i];
        let duration = r2.wdurations[i];
        if (word.length) {
          if (onsubtitles) {
            lipsyncAnim.push({
              template: { name: "subtitles" },
              ts: [time],
              vs: {
                subtitles: " " + word
              }
            });
          }
          if (!r2.visemes) {
            const w2 = this.lipsyncPreProcessText(word, lipsyncLang);
            const v2 = this.lipsyncWordsToVisemes(w2, lipsyncLang);
            if (v2 && v2.visemes && v2.visemes.length) {
              const dTotal = v2.times[v2.visemes.length - 1] + v2.durations[v2.visemes.length - 1];
              const overdrive = Math.min(duration, Math.max(0, duration - v2.visemes.length * 150));
              let level = 0.6 + this.convertRange(overdrive, [0, duration], [0, 0.4]);
              duration = Math.min(duration, v2.visemes.length * 200);
              if (dTotal > 0) {
                for (let j = 0; j < v2.visemes.length; j++) {
                  const t2 = time + v2.times[j] / dTotal * duration;
                  const d = v2.durations[j] / dTotal * duration;
                  lipsyncAnim.push({
                    template: { name: "viseme" },
                    ts: [t2 - Math.min(60, 2 * d / 3), t2 + Math.min(25, d / 2), t2 + d + Math.min(60, d / 2)],
                    vs: {
                      ["viseme_" + v2.visemes[j]]: [null, v2.visemes[j] === "PP" || v2.visemes[j] === "FF" ? 0.9 : level, 0]
                    }
                  });
                }
              }
            }
          }
        }
      }
      if (r2.visemes) {
        for (let i = 0; i < r2.visemes.length; i++) {
          const viseme = r2.visemes[i];
          const time = r2.vtimes[i];
          const duration = r2.vdurations[i];
          lipsyncAnim.push({
            template: { name: "viseme" },
            ts: [time - 2 * duration / 3, time + duration / 2, time + duration + duration / 2],
            vs: {
              ["viseme_" + viseme]: [null, viseme === "PP" || viseme === "FF" ? 0.9 : 0.6, 0]
            }
          });
        }
      }
      if (r2.markers) {
        for (let i = 0; i < r2.markers.length; i++) {
          const fn = r2.markers[i];
          const time = r2.mtimes[i];
          lipsyncAnim.push({
            template: { name: "markers" },
            ts: [time],
            vs: { "function": [fn] }
          });
        }
      }
      if (lipsyncAnim.length) {
        o.anim = lipsyncAnim;
      }
    }
    if (r2.audio) {
      o.audio = r2.audio;
    }
    if (onsubtitles) {
      o.onSubtitles = onsubtitles;
    }
    if (Object.keys(o).length) {
      this.speechQueue.push(o);
      this.speechQueue.push({ break: 300 });
      this.startSpeaking();
    }
  }
  /**
  * Play audio playlist using Web Audio API.
  * @param {boolean} [force=false] If true, forces to proceed
  */
  async playAudio(force = false) {
    if (!this.armature || this.isAudioPlaying && !force) return;
    this.isAudioPlaying = true;
    if (this.audioPlaylist.length) {
      const item = this.audioPlaylist.shift();
      if (this.audioCtx.state === "suspended") {
        const resume = this.audioCtx.resume();
        const timeout = new Promise((_r, rej) => setTimeout(() => rej("p2"), 1e3));
        try {
          await Promise.race([resume, timeout]);
        } catch (e) {
          console.log("Can't play audio. Web Audio API suspended. This is often due to calling some speak method before the first user action, which is typically prevented by the browser.");
          this.playAudio(true);
          return;
        }
      }
      let audio;
      if (Array.isArray(item.audio)) {
        let buf = this.concatArrayBuffers(item.audio);
        audio = this.pcmToAudioBuffer(buf);
      } else {
        audio = item.audio;
      }
      this.audioSpeechSource = this.audioCtx.createBufferSource();
      this.audioSpeechSource.buffer = audio;
      this.audioSpeechSource.playbackRate.value = 1 / this.animSlowdownRate;
      this.audioSpeechSource.connect(this.audioSpeechGainNode);
      this.audioSpeechSource.addEventListener("ended", () => {
        this.audioSpeechSource.disconnect();
        this.playAudio(true);
      }, { once: true });
      const delay = 100;
      if (item.anim) {
        item.anim.forEach((x) => {
          for (let i = 0; i < x.ts.length; i++) {
            x.ts[i] = this.animClock + x.ts[i] + delay;
          }
          this.animQueue.push(x);
        });
      }
      this.audioSpeechSource.start(delay / 1e3);
    } else {
      this.isAudioPlaying = false;
      this.startSpeaking(true);
    }
  }
  /**
  * Take the next queue item from the speech queue, convert it to text, and
  * load the audio file.
  * @param {boolean} [force=false] If true, forces to proceed (e.g. after break)
  */
  async startSpeaking(force = false) {
    if (!this.armature || this.isSpeaking && !force) return;
    this.stateName = "talking";
    this.isSpeaking = true;
    if (this.speechQueue.length) {
      let line = this.speechQueue.shift();
      if (line.emoji) {
        this.lookAtCamera(500);
        let duration = line.emoji.dt.reduce((a, b) => a + b, 0);
        this.animQueue.push(this.animFactory(line.emoji));
        setTimeout(this.startSpeaking.bind(this), duration, true);
      } else if (line.break) {
        setTimeout(this.startSpeaking.bind(this), line.break, true);
      } else if (line.audio) {
        this.lookAtCamera(500);
        this.speakWithHands();
        this.audioPlaylist.push({ anim: line.anim, audio: line.audio });
        this.onSubtitles = line.onSubtitles || null;
        this.resetLips();
        if (line.mood) this.setMood(line.mood);
        this.playAudio();
      } else if (line.text) {
        this.lookAtCamera(500);
        try {
          let ssml = "<speak>";
          line.text.forEach((x, i) => {
            if (i > 0) {
              ssml += " <mark name='" + x.mark + "'/>";
            }
            ssml += x.word.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&apos;").replace(new RegExp("^\\p{Dash_Punctuation}$", "ug"), '<break time="750ms"/>');
          });
          ssml += "</speak>";
          const o = {
            method: "POST",
            headers: {
              "Content-Type": "application/json; charset=utf-8"
            },
            body: JSON.stringify({
              "input": {
                "ssml": ssml
              },
              "voice": {
                "languageCode": line.lang || this.avatar.ttsLang || this.opt.ttsLang,
                "name": line.voice || this.avatar.ttsVoice || this.opt.ttsVoice
              },
              "audioConfig": {
                "audioEncoding": this.ttsAudioEncoding,
                "speakingRate": (line.rate || this.avatar.ttsRate || this.opt.ttsRate) + this.mood.speech.deltaRate,
                "pitch": (line.pitch || this.avatar.ttsPitch || this.opt.ttsPitch) + this.mood.speech.deltaPitch,
                "volumeGainDb": (line.volume || this.avatar.ttsVolume || this.opt.ttsVolume) + this.mood.speech.deltaVolume
              },
              "enableTimePointing": [1]
              // Timepoint information for mark tags
            })
          };
          if (this.opt.jwtGet && typeof this.opt.jwtGet === "function") {
            o.headers["Authorization"] = "Bearer " + await this.opt.jwtGet();
          }
          const res = await fetch(this.opt.ttsEndpoint + (this.opt.ttsApikey ? "?key=" + this.opt.ttsApikey : ""), o);
          const data = await res.json();
          if (res.status === 200 && data && data.audioContent) {
            const buf = this.b64ToArrayBuffer(data.audioContent);
            const audio = await this.audioCtx.decodeAudioData(buf);
            this.speakWithHands();
            const times = [0];
            let markIndex = 0;
            line.text.forEach((x, i) => {
              if (i > 0) {
                let ms = times[times.length - 1];
                if (data.timepoints[markIndex]) {
                  ms = data.timepoints[markIndex].timeSeconds * 1e3;
                  if (data.timepoints[markIndex].markName === "" + x.mark) {
                    markIndex++;
                  }
                }
                times.push(ms);
              }
            });
            const timepoints = [{ mark: 0, time: 0 }];
            times.forEach((x, i) => {
              if (i > 0) {
                let prevDuration = x - times[i - 1];
                if (prevDuration > 150) prevDuration - 150;
                timepoints[i - 1].duration = prevDuration;
                timepoints.push({ mark: i, time: x });
              }
            });
            let d = 1e3 * audio.duration;
            if (d > this.opt.ttsTrimEnd) d = d - this.opt.ttsTrimEnd;
            timepoints[timepoints.length - 1].duration = d - timepoints[timepoints.length - 1].time;
            line.anim.forEach((x) => {
              const timepoint = timepoints[x.mark];
              if (timepoint) {
                for (let i = 0; i < x.ts.length; i++) {
                  x.ts[i] = timepoint.time + x.ts[i] * timepoint.duration + this.opt.ttsTrimStart;
                }
              }
            });
            this.audioPlaylist.push({ anim: line.anim, audio });
            this.onSubtitles = line.onSubtitles || null;
            this.resetLips();
            if (line.mood) this.setMood(line.mood);
            this.playAudio();
          } else {
            this.startSpeaking(true);
          }
        } catch (error) {
          console.error("Error:", error);
          this.startSpeaking(true);
        }
      } else if (line.anim) {
        this.onSubtitles = line.onSubtitles || null;
        this.resetLips();
        if (line.mood) this.setMood(line.mood);
        line.anim.forEach((x, i) => {
          for (let j = 0; j < x.ts.length; j++) {
            x.ts[j] = this.animClock + 10 * i;
          }
          this.animQueue.push(x);
        });
        setTimeout(this.startSpeaking.bind(this), 10 * line.anim.length, true);
      } else if (line.marker) {
        if (typeof line.marker === "function") {
          line.marker();
        }
        this.startSpeaking(true);
      } else {
        this.startSpeaking(true);
      }
    } else {
      this.stateName = "idle";
      this.isSpeaking = false;
    }
  }
  /**
  * Pause speaking.
  */
  pauseSpeaking() {
    try {
      this.audioSpeechSource.stop();
    } catch (error) {
    }
    this.audioPlaylist.length = 0;
    this.stateName = "idle";
    this.isSpeaking = false;
    this.isAudioPlaying = false;
    this.animQueue = this.animQueue.filter((x) => x.template.name !== "viseme");
    if (this.armature) {
      this.resetLips();
      this.render();
    }
  }
  /**
  * Stop speaking and clear the speech queue.
  */
  stopSpeaking() {
    try {
      this.audioSpeechSource.stop();
    } catch (error) {
    }
    this.audioPlaylist.length = 0;
    this.speechQueue.length = 0;
    this.animQueue = this.animQueue.filter((x) => x.template.name !== "viseme");
    this.stateName = "idle";
    this.isSpeaking = false;
    this.isAudioPlaying = false;
    if (this.armature) {
      this.resetLips();
      this.render();
    }
  }
  /**
  * Turn head and eyes to look at the camera.
  * @param {number} t Time in milliseconds
  */
  lookAtCamera(t2) {
    this.lookAt(null, null, t2);
  }
  /**
  * Turn head and eyes to look at the point (x,y).
  * @param {number} x X-coordinate relative to visual viewport
  * @param {number} y Y-coordinate relative to visual viewport
  * @param {number} t Time in milliseconds
  */
  lookAt(x, y2, t2) {
    const rect = this.nodeAvatar.getBoundingClientRect();
    const lEye = this.armature.getObjectByName("LeftEye");
    const rEye = this.armature.getObjectByName("RightEye");
    lEye.updateMatrixWorld(true);
    rEye.updateMatrixWorld(true);
    const plEye = new Vector3().setFromMatrixPosition(lEye.matrixWorld);
    const prEye = new Vector3().setFromMatrixPosition(rEye.matrixWorld);
    const pEyes = new Vector3().addVectors(plEye, prEye).divideScalar(2);
    pEyes.project(this.camera);
    let eyesx = (pEyes.x + 1) / 2 * rect.width + rect.left;
    let eyesy = -(pEyes.y - 1) / 2 * rect.height + rect.top;
    if (x === null) x = eyesx;
    if (y2 === null) y2 = eyesy;
    let q2 = this.poseTarget.props["Hips.quaternion"].clone();
    q2.multiply(this.poseTarget.props["Spine.quaternion"]);
    q2.multiply(this.poseTarget.props["Spine1.quaternion"]);
    q2.multiply(this.poseTarget.props["Spine2.quaternion"]);
    q2.multiply(this.poseTarget.props["Neck.quaternion"]);
    q2.multiply(this.poseTarget.props["Head.quaternion"]);
    let e = new Euler().setFromQuaternion(q2);
    let rx = e.x / (40 / 24);
    let ry = e.y / (9 / 4);
    let camerarx = Math.min(0.4, Math.max(-0.4, this.camera.rotation.x));
    let camerary = Math.min(0.4, Math.max(-0.4, this.camera.rotation.y));
    let maxx = Math.max(window.innerWidth - eyesx, eyesx);
    let maxy = Math.max(window.innerHeight - eyesy, eyesy);
    let rotx = this.convertRange(y2, [eyesy - maxy, eyesy + maxy], [-0.3, 0.6]) - rx + camerarx;
    let roty = this.convertRange(x, [eyesx - maxx, eyesx + maxx], [-0.8, 0.8]) - ry + camerary;
    rotx = Math.min(0.6, Math.max(-0.3, rotx));
    roty = Math.min(0.8, Math.max(-0.8, roty));
    let drotx = (Math.random() - 0.5) / 4;
    let droty = (Math.random() - 0.5) / 4;
    if (t2) {
      let old = this.animQueue.findIndex((y3) => y3.template.name === "lookat");
      if (old !== -1) {
        this.animQueue.splice(old, 1);
      }
      const templateLookAt = {
        name: "lookat",
        dt: [750, t2],
        vs: {
          headRotateX: [rotx + drotx],
          headRotateY: [roty + droty],
          eyesRotateX: [-3 * drotx + 0.1],
          eyesRotateY: [-5 * droty],
          browInnerUp: [[0, 0.7]],
          mouthLeft: [[0, 0.7]],
          mouthRight: [[0, 0.7]]
        }
      };
      this.animQueue.push(this.animFactory(templateLookAt));
    }
  }
  /**
  * Set the closest hand to touch at (x,y).
  * @param {number} x X-coordinate relative to visual viewport
  * @param {number} y Y-coordinate relative to visual viewport
  * @return {Boolean} If true, (x,y) touch the avatar
  */
  touchAt(x, y2) {
    const rect = this.nodeAvatar.getBoundingClientRect();
    const pointer = new Vector2(
      (x - rect.left) / rect.width * 2 - 1,
      -((y2 - rect.top) / rect.height) * 2 + 1
    );
    const raycaster = new Raycaster();
    raycaster.setFromCamera(pointer, this.camera);
    const intersects2 = raycaster.intersectObject(this.armature);
    if (intersects2.length > 0) {
      const target = intersects2[0].point;
      const LeftArmPos = new Vector3();
      const RightArmPos = new Vector3();
      this.armature.getObjectByName("LeftArm").getWorldPosition(LeftArmPos);
      this.armature.getObjectByName("RightArm").getWorldPosition(RightArmPos);
      const LeftD2 = LeftArmPos.distanceToSquared(target);
      const RightD2 = RightArmPos.distanceToSquared(target);
      if (LeftD2 < RightD2) {
        this.ikSolve({
          iterations: 20,
          root: "LeftShoulder",
          effector: "LeftHandMiddle1",
          links: [
            { link: "LeftHand", minx: -0.5, maxx: 0.5, miny: -1, maxy: 1, minz: -0.5, maxz: 0.5, maxAngle: 0.1 },
            { link: "LeftForeArm", minx: -0.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -0.5, maxz: 3, maxAngle: 0.2 },
            { link: "LeftArm", minx: -1.5, maxx: 1.5, miny: 0, maxy: 0, minz: -1, maxz: 3 }
          ]
        }, target, false, 1e3);
        this.setValue("handFistLeft", 0);
      } else {
        this.ikSolve({
          iterations: 20,
          root: "RightShoulder",
          effector: "RightHandMiddle1",
          links: [
            { link: "RightHand", minx: -0.5, maxx: 0.5, miny: -1, maxy: 1, minz: -0.5, maxz: 0.5, maxAngle: 0.1 },
            { link: "RightForeArm", minx: -0.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -3, maxz: 0.5, maxAngle: 0.2 },
            { link: "RightArm", minx: -1.5, maxx: 1.5, miny: 0, maxy: 0, minz: -1, maxz: 3 }
          ]
        }, target, false, 1e3);
        this.setValue("handFistRight", 0);
      }
    } else {
      ["LeftArm", "LeftForeArm", "LeftHand", "RightArm", "RightForeArm", "RightHand"].forEach((x2) => {
        let key = x2 + ".quaternion";
        this.poseTarget.props[key].copy(this.getPoseTemplateProp(key));
        this.poseTarget.props[key].t = this.animClock;
        this.poseTarget.props[key].d = 1e3;
      });
    }
    return intersects2.length > 0;
  }
  /**
  * Talk with hands.
  * @param {number} [delay=0] Delay in milliseconds
  * @param {number} [prob=1] Probability of hand movement
  */
  speakWithHands(delay = 0, prob = 0.5) {
    if (this.mixer || this.gesture || !this.poseTarget.template.standing || this.poseTarget.template.bend || Math.random() > prob) return;
    this.ikSolve({
      root: "LeftShoulder",
      effector: "LeftHandMiddle1",
      links: [
        { link: "LeftHand", minx: -0.5, maxx: 0.5, miny: -1, maxy: 1, minz: -0.5, maxz: 0.5 },
        { link: "LeftForeArm", minx: -0.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -0.5, maxz: 3 },
        { link: "LeftArm", minx: -1.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -1, maxz: 3 }
      ]
    }, new Vector3(
      this.gaussianRandom(0, 0.5),
      this.gaussianRandom(-0.8, -0.2),
      this.gaussianRandom(0, 0.5)
    ), true);
    this.ikSolve({
      root: "RightShoulder",
      effector: "RightHandMiddle1",
      links: [
        { link: "RightHand", minx: -0.5, maxx: 0.5, miny: -1, maxy: 1, minz: -0.5, maxz: 0.5 },
        { link: "RightForeArm", minx: -0.5, maxx: 1.5, miny: -1.5, maxy: 1.5, minz: -3, maxz: 0.5 },
        { link: "RightArm" }
      ]
    }, new Vector3(
      this.gaussianRandom(-0.5, 0),
      this.gaussianRandom(-0.8, -0.2),
      this.gaussianRandom(0, 0.5)
    ), true);
    const dt = [];
    const moveto = [];
    dt.push(100 + Math.round(Math.random() * 500));
    moveto.push({ duration: 1e3, props: {
      "LeftHand.quaternion": new Quaternion().setFromEuler(new Euler(0, -1 - Math.random(), 0)),
      "RightHand.quaternion": new Quaternion().setFromEuler(new Euler(0, 1 + Math.random(), 0))
    } });
    ["LeftArm", "LeftForeArm", "RightArm", "RightForeArm"].forEach((x) => {
      moveto[0].props[x + ".quaternion"] = this.ikMesh.getObjectByName(x).quaternion.clone();
    });
    dt.push(1e3 + Math.round(Math.random() * 500));
    moveto.push({ duration: 2e3, props: {} });
    ["LeftArm", "LeftForeArm", "RightArm", "RightForeArm", "LeftHand", "RightHand"].forEach((x) => {
      moveto[1].props[x + ".quaternion"] = null;
    });
    const anim = this.animFactory({
      name: "talkinghands",
      delay,
      dt,
      vs: { moveto }
    });
    this.animQueue.push(anim);
  }
  /**
  * Get slowdown.
  * @return {numeric} Slowdown factor.
  */
  getSlowdownRate(k2) {
    return this.animSlowdownRate;
  }
  /**
  * Set slowdown.
  * @param {numeric} k Slowdown factor.
  */
  setSlowdownRate(k2) {
    this.animSlowdownRate = k2;
    this.audioSpeechSource.playbackRate.value = 1 / this.animSlowdownRate;
    this.audioBackgroundSource.playbackRate.value = 1 / this.animSlowdownRate;
  }
  /**
  * Get autorotate speed.
  * @return {numeric} Autorotate speed.
  */
  getAutoRotateSpeed(k2) {
    return this.controls.autoRotateSpeed;
  }
  /**
  * Set autorotate.
  * @param {numeric} speed Autorotate speed, e.g. value 2 = 30 secs per orbit at 60fps.
  */
  setAutoRotateSpeed(speed) {
    this.controls.autoRotateSpeed = speed;
    this.controls.autoRotate = speed > 0;
  }
  /**
  * Start animation cycle.
  */
  start() {
    if (this.armature && this.isRunning === false) {
      this.audioCtx.resume();
      this.animTimeLast = performance.now();
      this.isRunning = true;
      requestAnimationFrame(this.animate.bind(this));
    }
  }
  /**
  * Stop animation cycle.
  */
  stop() {
    this.isRunning = false;
    this.audioCtx.suspend();
  }
  /**
  * Play RPM/Mixamo animation clip.
  * @param {string|Object} url URL to animation file FBX
  * @param {progressfn} [onprogress=null] Callback for progress
  * @param {number} [dur=10] Duration in seconds, but at least once
  * @param {number} [ndx=0] Index of the clip
  * @param {number} [scale=0.01] Position scale factor
  */
  async playAnimation(url, onprogress = null, dur = 10, ndx = 0, scale = 0.01) {
    if (!this.armature) return;
    let item = this.animClips.find((x) => x.url === url + "-" + ndx);
    if (item) {
      let anim = this.animQueue.find((x) => x.template.name === "pose");
      if (anim) {
        anim.ts[0] = Infinity;
      }
      Object.entries(item.pose.props).forEach((x) => {
        this.poseBase.props[x[0]] = x[1].clone();
        this.poseTarget.props[x[0]] = x[1].clone();
        this.poseTarget.props[x[0]].t = 0;
        this.poseTarget.props[x[0]].d = 1e3;
      });
      this.mixer = new AnimationMixer(this.armature);
      this.mixer.addEventListener("finished", this.stopAnimation.bind(this), { once: true });
      const repeat = Math.ceil(dur / item.clip.duration);
      const action = this.mixer.clipAction(item.clip);
      action.setLoop(LoopRepeat, repeat);
      action.clampWhenFinished = true;
      action.fadeIn(0.5).play();
    } else {
      const loader = new FBXLoader();
      let fbx = await loader.loadAsync(url, onprogress);
      if (fbx && fbx.animations && fbx.animations[ndx]) {
        let anim = fbx.animations[ndx];
        const props = {};
        anim.tracks.forEach((t2) => {
          t2.name = t2.name.replaceAll("mixamorig", "");
          const ids = t2.name.split(".");
          if (ids[1] === "position") {
            for (let i = 0; i < t2.values.length; i++) {
              t2.values[i] = t2.values[i] * scale;
            }
            props[t2.name] = new Vector3(t2.values[0], t2.values[1], t2.values[2]);
          } else if (ids[1] === "quaternion") {
            props[t2.name] = new Quaternion(t2.values[0], t2.values[1], t2.values[2], t2.values[3]);
          } else if (ids[1] === "rotation") {
            props[ids[0] + ".quaternion"] = new Quaternion().setFromEuler(new Euler(t2.values[0], t2.values[1], t2.values[2], "XYZ")).normalize();
          }
        });
        const newPose = { props };
        if (props["Hips.position"]) {
          if (props["Hips.position"].y < 0.5) {
            newPose.lying = true;
          } else {
            newPose.standing = true;
          }
        }
        this.animClips.push({
          url: url + "-" + ndx,
          clip: anim,
          pose: newPose
        });
        this.playAnimation(url, onprogress, dur, ndx, scale);
      } else {
        const msg = "Animation " + url + " (ndx=" + ndx + ") not found";
        console.error(msg);
      }
    }
  }
  /**
  * Stop running animations.
  */
  stopAnimation() {
    this.mixer = null;
    if (this.gesture) {
      for (let [p2, v2] of Object.entries(this.gesture)) {
        v2.t = this.animClock;
        v2.d = 1e3;
        if (this.poseTarget.props.hasOwnProperty(p2)) {
          this.poseTarget.props[p2].copy(v2);
          this.poseTarget.props[p2].t = this.animClock;
          this.poseTarget.props[p2].d = 1e3;
        }
      }
    }
    let anim = this.animQueue.find((x) => x.template.name === "pose");
    if (anim) {
      anim.ts[0] = this.animClock;
    }
    this.setPoseFromTemplate(null);
  }
  /**
  * Play RPM/Mixamo pose.
  * @param {string|Object} url Pose name | URL to FBX
  * @param {progressfn} [onprogress=null] Callback for progress
  * @param {number} [dur=5] Duration of the pose in seconds
  * @param {number} [ndx=0] Index of the clip
  * @param {number} [scale=0.01] Position scale factor
  */
  async playPose(url, onprogress = null, dur = 5, ndx = 0, scale = 0.01) {
    if (!this.armature) return;
    let pose = this.poseTemplates[url];
    if (!pose) {
      const item = this.animPoses.find((x) => x.url === url + "-" + ndx);
      if (item) {
        pose = item.pose;
      }
    }
    if (pose) {
      this.poseName = url;
      this.mixer = null;
      let anim = this.animQueue.find((x) => x.template.name === "pose");
      if (anim) {
        anim.ts[0] = this.animClock + dur * 1e3 + 2e3;
      }
      this.setPoseFromTemplate(pose);
    } else {
      const loader = new FBXLoader();
      let fbx = await loader.loadAsync(url, onprogress);
      if (fbx && fbx.animations && fbx.animations[ndx]) {
        let anim = fbx.animations[ndx];
        const props = {};
        anim.tracks.forEach((t2) => {
          t2.name = t2.name.replaceAll("mixamorig", "");
          const ids = t2.name.split(".");
          if (ids[1] === "position") {
            props[t2.name] = new Vector3(t2.values[0] * scale, t2.values[1] * scale, t2.values[2] * scale);
          } else if (ids[1] === "quaternion") {
            props[t2.name] = new Quaternion(t2.values[0], t2.values[1], t2.values[2], t2.values[3]);
          } else if (ids[1] === "rotation") {
            props[ids[0] + ".quaternion"] = new Quaternion().setFromEuler(new Euler(t2.values[0], t2.values[1], t2.values[2], "XYZ")).normalize();
          }
        });
        const newPose = { props };
        if (props["Hips.position"]) {
          if (props["Hips.position"].y < 0.5) {
            newPose.lying = true;
          } else {
            newPose.standing = true;
          }
        }
        this.animPoses.push({
          url: url + "-" + ndx,
          pose: newPose
        });
        this.playPose(url, onprogress, dur, ndx, scale);
      } else {
        const msg = "Pose " + url + " (ndx=" + ndx + ") not found";
        console.error(msg);
      }
    }
  }
  /**
  * Stop the pose. (Functionality is the same as in stopAnimation.)
  */
  stopPose() {
    this.stopAnimation();
  }
  /**
  * Play a gesture, which is either a hand gesture, an emoji animation or their
  * combination.
  * @param {string} name Gesture name
  * @param {number} [dur=3] Duration of the gesture in seconds
  * @param {boolean} [mirror=false] Mirror gesture
  * @param {number} [ms=1000] Transition time in milliseconds
  */
  playGesture(name2, dur = 3, mirror = false, ms = 1e3) {
    if (!this.armature) return;
    let g = this.gestureTemplates[name2];
    if (g) {
      if (this.gestureTimeout) {
        clearTimeout(this.gestureTimeout);
        this.gestureTimeout = null;
      }
      let ndx = this.animQueue.findIndex((y2) => y2.template.name === "talkinghands");
      if (ndx !== -1) {
        this.animQueue[ndx].ts = this.animQueue[ndx].ts.map((x) => 0);
      }
      this.gesture = this.propsToThreeObjects(g);
      if (mirror) {
        this.gesture = this.mirrorPose(this.gesture);
      }
      if (name2 === "namaste" && this.avatar.body === "M") {
        this.gesture["RightArm.quaternion"].rotateTowards(new Quaternion(0, 1, 0, 0), -0.25);
        this.gesture["LeftArm.quaternion"].rotateTowards(new Quaternion(0, 1, 0, 0), -0.25);
      }
      for (let [p2, v2] of Object.entries(this.gesture)) {
        v2.t = this.animClock;
        v2.d = ms;
        if (this.poseTarget.props.hasOwnProperty(p2)) {
          this.poseTarget.props[p2].copy(v2);
          this.poseTarget.props[p2].t = this.animClock;
          this.poseTarget.props[p2].d = ms;
        }
      }
      if (dur && Number.isFinite(dur)) {
        this.gestureTimeout = setTimeout(this.stopGesture.bind(this, ms), 1e3 * dur);
      }
    }
    let e = this.animEmojis[name2];
    if (e) {
      if (e && e.link) {
        e = this.animEmojis[e.link];
      }
      if (e) {
        this.lookAtCamera(500);
        const anim = this.animFactory(e);
        anim.gesture = true;
        if (dur && Number.isFinite(dur)) {
          const first = anim.ts[0];
          const last = anim.ts[anim.ts.length - 1];
          const scale = 1e3 * dur / (last - first);
          anim.ts = anim.ts.map((x) => first + scale * (x - first));
        }
        this.animQueue.push(anim);
      }
    }
  }
  /**
  * Stop the gesture.
  * @param {number} [ms=1000] Transition time in milliseconds
  */
  stopGesture(ms = 1e3) {
    if (this.gestureTimeout) {
      clearTimeout(this.gestureTimeout);
      this.gestureTimeout = null;
    }
    if (this.gesture) {
      const gs = Object.entries(this.gesture);
      this.gesture = null;
      for (const [p2, v2] of gs) {
        if (this.poseTarget.props.hasOwnProperty(p2)) {
          this.poseTarget.props[p2].copy(this.getPoseTemplateProp(p2));
          this.poseTarget.props[p2].t = this.animClock;
          this.poseTarget.props[p2].d = ms;
        }
      }
    }
    let i = this.animQueue.findIndex((y2) => y2.gesture);
    if (i !== -1) {
      this.animQueue.splice(i, 1);
    }
  }
  /**
  * Cyclic Coordinate Descent (CCD) Inverse Kinematic (IK) algorithm.
  * Adapted from:
  * https://github.com/mrdoob/three.js/blob/master/examples/jsm/animation/CCDIKSolver.js
  * @param {Object} ik IK configuration object
  * @param {Vector3} [target=null] Target coordinate, if null return to template
  * @param {Boolean} [relative=false] If true, target is relative to root
  * @param {numeric} [d=null] If set, apply in d milliseconds
  */
  ikSolve(ik2, target = null, relative = false, d = null) {
    const q2 = new Quaternion();
    const targetVec = new Vector3();
    const effectorPos = new Vector3();
    const effectorVec = new Vector3();
    const linkPos = new Vector3();
    const invLinkQ = new Quaternion();
    const linkScale = new Vector3();
    const axis = new Vector3();
    const vector = new Vector3();
    const root2 = this.ikMesh.getObjectByName(ik2.root);
    root2.position.setFromMatrixPosition(this.armature.getObjectByName(ik2.root).matrixWorld);
    root2.quaternion.setFromRotationMatrix(this.armature.getObjectByName(ik2.root).matrixWorld);
    if (target && relative) {
      target.add(root2.position);
    }
    const effector = this.ikMesh.getObjectByName(ik2.effector);
    const links = ik2.links;
    links.forEach((x) => {
      x.bone = this.ikMesh.getObjectByName(x.link);
      x.bone.quaternion.copy(this.getPoseTemplateProp(x.link + ".quaternion"));
    });
    root2.updateMatrixWorld(true);
    const iterations = ik2.iterations || 10;
    if (target) {
      for (let i = 0; i < iterations; i++) {
        let rotated = false;
        for (let j = 0, jl2 = links.length; j < jl2; j++) {
          const bone = links[j].bone;
          bone.matrixWorld.decompose(linkPos, invLinkQ, linkScale);
          invLinkQ.invert();
          effectorPos.setFromMatrixPosition(effector.matrixWorld);
          effectorVec.subVectors(effectorPos, linkPos);
          effectorVec.applyQuaternion(invLinkQ);
          effectorVec.normalize();
          targetVec.subVectors(target, linkPos);
          targetVec.applyQuaternion(invLinkQ);
          targetVec.normalize();
          let angle = targetVec.dot(effectorVec);
          if (angle > 1) {
            angle = 1;
          } else if (angle < -1) {
            angle = -1;
          }
          angle = Math.acos(angle);
          if (angle < 1e-5) continue;
          if (links[j].minAngle !== void 0 && angle < links[j].minAngle) {
            angle = links[j].minAngle;
          }
          if (links[j].maxAngle !== void 0 && angle > links[j].maxAngle) {
            angle = links[j].maxAngle;
          }
          axis.crossVectors(effectorVec, targetVec);
          axis.normalize();
          q2.setFromAxisAngle(axis, angle);
          bone.quaternion.multiply(q2);
          bone.rotation.setFromVector3(vector.setFromEuler(bone.rotation).clamp(new Vector3(
            links[j].minx !== void 0 ? links[j].minx : -Infinity,
            links[j].miny !== void 0 ? links[j].miny : -Infinity,
            links[j].minz !== void 0 ? links[j].minz : -Infinity
          ), new Vector3(
            links[j].maxx !== void 0 ? links[j].maxx : Infinity,
            links[j].maxy !== void 0 ? links[j].maxy : Infinity,
            links[j].maxz !== void 0 ? links[j].maxz : Infinity
          )));
          bone.updateMatrixWorld(true);
          rotated = true;
        }
        if (!rotated) break;
      }
    }
    if (d) {
      links.forEach((x) => {
        this.poseTarget.props[x.link + ".quaternion"].copy(x.bone.quaternion);
        this.poseTarget.props[x.link + ".quaternion"].t = this.animClock;
        this.poseTarget.props[x.link + ".quaternion"].d = d;
      });
    }
  }
}
const API_KEY = "0f4404a5f9f56";
const Avatar = reactExports.forwardRef((_, ref) => {
  const containerRef = reactExports.useRef(null);
  const loadingRef = reactExports.useRef(null);
  const talkingHeadRef = reactExports.useRef(null);
  const microsoftSynthesizerRef = reactExports.useRef(null);
  const microsoftQueueRef = reactExports.useRef([]);
  reactExports.useEffect(() => {
    if (!containerRef.current) return;
    if (!loadingRef.current) return;
    if (talkingHeadRef.current) return;
    talkingHeadRef.current = new TalkingHead(containerRef.current, {
      ttsEndpoint: "https://eu-texttospeech.googleapis.com/v1beta1/text:synthesize",
      // ttsApikey: "put-your-own-Google-TTS-API-key-here", // <- Change this
      lipsyncModules: [],
      // cameraView: "upper",
      cameraView: "full",
      avatarMood: "neutral",
      // Stats display that can be used when testing performance
      statsNode: containerRef.current,
      statsStyle: "position: absolute; bottom: 0px; left: 0px; cursor: pointer; opacity: 0.9; z-index: 10000;"
    });
    const load = async (nodeLoading) => {
      try {
        nodeLoading.textContent = "Loading...";
        await talkingHeadRef.current.showAvatar({
          //   url: 'https://models.readyplayer.me/64bfa15f0e72c63d7c3934a6.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown&textureSizeLimit=1024&textureFormat=png',
          // url: 'https://models.readyplayer.me/634519dc116d01f44d3b9734.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown&textureSizeLimit=1024&textureFormat=png',
          url: "https://models.readyplayer.me/670a24c892f67441779a5bad.glb?morphTargets=ARKit,Oculus+Visemes,mouthOpen,mouthSmile,eyesClosed,eyesLookUp,eyesLookDown&textureSizeLimit=1024&textureFormat=png",
          body: "F",
          avatarMood: "neutral"
          //   ttsLang: "en-GB",
          //   ttsVoice: "en-GB-Standard-A",
          //   lipsyncLang: 'en'
        }, (ev) => {
          if (ev.lengthComputable) {
            let val = Math.min(100, Math.round(ev.loaded / ev.total * 100));
            nodeLoading.textContent = "Loading " + val + "%";
          }
        });
        nodeLoading.style.display = "none";
      } catch (error) {
        console.error("Error loading avatar:", error);
        if (error instanceof Error) {
          nodeLoading.textContent = error.message;
        } else {
          nodeLoading.textContent = "An unknown error occurred";
        }
      }
    };
    load(loadingRef.current);
    return () => {
      if (containerRef.current) ;
    };
  }, []);
  const escapeHTML = (s) => {
    return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  };
  async function microsoftSpeak(s, node2 = null, onprocessed = null) {
    if (!talkingHeadRef.current) return;
    const microsoftQueue = microsoftQueueRef.current;
    if (s === null) {
      microsoftQueue.push(null);
    } else {
      const id2 = "zh-CN-XiaoyuMultilingualNeural";
      const lang = "zh-CN";
      const ssml = "<speak version='1.0' xmlns:mstts='http://www.w3.org/2001/mstts' xml:lang='" + lang + "'><voice name='" + id2 + "'><mstts:viseme type='redlips_front'/>" + escapeHTML(s) + "</voice></speak>";
      microsoftQueue.push({
        ssml,
        node: node2,
        onprocessed,
        speak: { audio: [], words: [], wtimes: [], wdurations: [], visemes: [], vtimes: [], vdurations: [] }
      });
    }
    if (microsoftQueue.length === 1) {
      microsoftProcessQueue();
    }
  }
  async function microsoftProcessQueue() {
    const microsoftQueue = microsoftQueueRef.current;
    let microsoftSynthesizer = microsoftSynthesizerRef.current;
    if (microsoftQueue.length) {
      const job = microsoftQueue[0];
      if (job === null) {
        microsoftQueue.shift();
        if (microsoftQueue.length === 0 && microsoftSynthesizer) {
          microsoftSynthesizer.close();
          microsoftSynthesizerRef.current = null;
        }
      } else {
        if (!microsoftSynthesizer) {
          const endpoint = `https://api.zzcreation.com/web/ws?x-api-key=${API_KEY}`;
          const config = microsoft_cognitiveservices_speech_sdk.SpeechConfig.fromEndpoint(new URL(endpoint));
          config.setProperty("SpeechServiceConnection_Endpoint", endpoint);
          config.speechSynthesisOutputFormat = microsoft_cognitiveservices_speech_sdk.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm;
          microsoftSynthesizer = new microsoft_cognitiveservices_speech_sdk.SpeechSynthesizer(config);
          const visemeMap = [
            "sil",
            "aa",
            "aa",
            "O",
            "E",
            // 0 - 4
            "E",
            "I",
            "U",
            "O",
            "aa",
            // 5 - 9
            "O",
            "I",
            "kk",
            "RR",
            "nn",
            // 10 - 14
            "SS",
            "SS",
            "TH",
            "FF",
            "DD",
            // 15 - 19
            "kk",
            "PP"
            // 20 - 21
          ];
          microsoftSynthesizer.visemeReceived = function(_2, e) {
            if (microsoftQueue[0] && microsoftQueue[0].speak) {
              const o = microsoftQueue[0].speak;
              const viseme = visemeMap[e.visemeId];
              const time = e.audioOffset / 1e4;
              if (o.vdurations.length) {
                if (o.visemes[o.visemes.length - 1] === 0) {
                  o.visemes.pop();
                  o.vtimes.pop();
                  o.vdurations.pop();
                } else {
                  o.vdurations[o.vdurations.length - 1] = time - o.vtimes[o.vdurations.length - 1];
                }
              }
              o.visemes.push(viseme);
              o.vtimes.push(time);
              o.vdurations.push(75);
            }
          };
          microsoftSynthesizer.wordBoundary = function(_2, e) {
            if (microsoftQueue[0] && microsoftQueue[0].speak) {
              const o = microsoftQueue[0].speak;
              const word = e.text;
              const time = e.audioOffset / 1e4;
              const duration = e.duration / 1e4;
              if (e.boundaryType === "PunctuationBoundary" && o.words.length) {
                o.words[o.words.length - 1] += word;
              } else if (e.boundaryType === "WordBoundary" || e.boundaryType === "PunctuationBoundary") {
                o.words.push(word);
                o.wtimes.push(time);
                o.wdurations.push(duration);
              }
            }
          };
        }
        microsoftSynthesizer.speakSsmlAsync(
          job.ssml,
          function(result) {
            if (microsoftQueue[0] && microsoftQueue[0].speak) {
              if (result.reason === microsoft_cognitiveservices_speech_sdk.ResultReason.SynthesizingAudioCompleted) {
                const job2 = microsoftQueue[0];
                job2.speak.audio.push(result.audioData);
                talkingHeadRef.current.speakAudio(job2.speak, {}, null);
                if (job2.onprocessed) job2.onprocessed();
              }
              microsoftQueue.shift();
              microsoftProcessQueue();
            }
          },
          function(err2) {
            if (job.onprocessed) job.onprocessed();
            console.log(err2);
            microsoftQueue.shift();
            microsoftProcessQueue();
          }
        );
      }
    }
  }
  reactExports.useImperativeHandle(ref, () => ({
    speak: async (text2) => {
      if (text2) {
        await microsoftSpeak(text2, null);
      }
    }
    // Add more methods as needed
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: containerRef, style: { display: "block", width: "100%", height: "100%", position: "relative" } }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: loadingRef })
  ] });
});
function ok$1() {
}
function unreachable() {
}
function stringify$1(values, options) {
  const settings = {};
  const input = values[values.length - 1] === "" ? [...values, ""] : values;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
const emptyOptions$2 = {};
function name(name2, options) {
  const settings = emptyOptions$2;
  const re2 = settings.jsx ? nameReJsx : nameRe;
  return re2.test(name2);
}
const re = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty$1(thing.value) : false : empty$1(thing);
}
function empty$1(value) {
  return value.replace(re, "") === "";
}
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(definitions, space2) {
  const property = {};
  const normal = {};
  let index2 = -1;
  while (++index2 < definitions.length) {
    Object.assign(property, definitions[index2].property);
    Object.assign(normal, definitions[index2].normal);
  }
  return new Schema(property, normal, space2);
}
function normalize$1(value) {
  return value.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;
let powers = 0;
const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" }));
const checks = Object.keys(types);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space2) {
    let index2 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index2 < checks.length) {
        const check = checks[index2];
        mark(this, checks[index2], (mask & types[check]) === types[check]);
      }
    }
  }
}
DefinedInfo.prototype.defined = true;
function mark(values, key, value) {
  if (value) {
    values[key] = value;
  }
}
const own$4 = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own$4.call(definition2.properties, prop)) {
      const value = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize$1(prop)] = prop;
      normal[normalize$1(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}
const xlink = create({
  space: "xlink",
  transform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const xml = create({
  space: "xml",
  transform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});
const aria = create({
  transform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});
const html$2 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});
const svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap$1 = /[A-Z]/g;
function find(schema, value) {
  const normal = normalize$1(value);
  let prop = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap$1, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
const html$1 = merge([xml, xlink, xmlns, aria, html$2], "html");
const svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function stringify(values) {
  return values.join(" ").trim();
}
var cjs = {};
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;
var TRIM_REGEX = /^\s+|\s+$/g;
var NEWLINE = "\n";
var FORWARD_SLASH = "/";
var ASTERISK = "*";
var EMPTY_STRING = "";
var TYPE_COMMENT = "comment";
var TYPE_DECLARATION = "declaration";
var inlineStyleParser = function(style, options) {
  if (typeof style !== "string") {
    throw new TypeError("First argument must be a string");
  }
  if (!style) return [];
  options = options || {};
  var lineno = 1;
  var column = 1;
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }
  function position2() {
    var start = { line: lineno, column };
    return function(node2) {
      node2.position = new Position(start);
      whitespace2();
      return node2;
    };
  }
  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column };
    this.source = options.source;
  }
  Position.prototype.content = style;
  function error(msg) {
    var err2 = new Error(
      options.source + ":" + lineno + ":" + column + ": " + msg
    );
    err2.reason = msg;
    err2.filename = options.source;
    err2.line = lineno;
    err2.column = column;
    err2.source = style;
    if (options.silent) ;
    else {
      throw err2;
    }
  }
  function match(re2) {
    var m2 = re2.exec(style);
    if (!m2) return;
    var str = m2[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m2;
  }
  function whitespace2() {
    match(WHITESPACE_REGEX);
  }
  function comments(rules) {
    var c;
    rules = rules || [];
    while (c = comment()) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }
  function comment() {
    var pos = position2();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
    var i = 2;
    while (EMPTY_STRING != style.charAt(i) && (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
      ++i;
    }
    i += 2;
    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error("End of comment missing");
    }
    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;
    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }
  function declaration() {
    var pos = position2();
    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment();
    if (!match(COLON_REGEX)) return error("property missing ':'");
    var val = match(VALUE_REGEX);
    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
    });
    match(SEMICOLON_REGEX);
    return ret;
  }
  function declarations() {
    var decls = [];
    comments(decls);
    var decl;
    while (decl = declaration()) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }
    return decls;
  }
  whitespace2();
  return declarations();
};
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cjs, "__esModule", { value: true });
var _default = cjs.default = StyleToObject;
var inline_style_parser_1 = __importDefault(inlineStyleParser);
function StyleToObject(style, iterator) {
  var styleObject = null;
  if (!style || typeof style !== "string") {
    return styleObject;
  }
  var declarations = (0, inline_style_parser_1.default)(style);
  var hasIterator = typeof iterator === "function";
  declarations.forEach(function(declaration) {
    if (declaration.type !== "declaration") {
      return;
    }
    var property = declaration.property, value = declaration.value;
    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      styleObject = styleObject || {};
      styleObject[property] = value;
    }
  });
  return styleObject;
}
const styleToObject = _default.default || _default;
const pointEnd = point$2("end");
const pointStart = point$2("start");
function point$2(type) {
  return point2;
  function point2(node2) {
    const point3 = node2 && node2.position && node2.position[type] || {};
    if (typeof point3.line === "number" && point3.line > 0 && typeof point3.column === "number" && point3.column > 0) {
      return {
        line: point3.line,
        column: point3.column,
        offset: typeof point3.offset === "number" && point3.offset > -1 ? point3.offset : void 0
      };
    }
  }
}
function position$1(node2) {
  const start = pointStart(node2);
  const end = pointEnd(node2);
  if (start && end) {
    return { start, end };
  }
}
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point$1(value);
  }
  return "";
}
function point$1(point2) {
  return index(point2 && point2.line) + ":" + index(point2 && point2.column);
}
function position(pos) {
  return point$1(pos && pos.start) + "-" + point$1(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index2);
        options.ruleId = origin.slice(index2 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start ? start.column : void 0;
    this.fatal = void 0;
    this.file;
    this.message = reason;
    this.line = start ? start.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual;
    this.expected;
    this.note;
    this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const own$3 = {}.hasOwnProperty;
const emptyMap = /* @__PURE__ */ new Map();
const cap = /[A-Z]/g;
const dashSomething = /-([a-z])/g;
const tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
const tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
const docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create2;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create2 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create2 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create2,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg : html$1,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one$1(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one$1(state, node2, key) {
  if (node2.type === "element") {
    return element$1(state, node2, key);
  }
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
    return mdxExpression(state, node2);
  }
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
    return mdxJsxElement(state, node2, key);
  }
  if (node2.type === "mdxjsEsm") {
    return mdxEsm(state, node2);
  }
  if (node2.type === "root") {
    return root$1(state, node2, key);
  }
  if (node2.type === "text") {
    return text$3(state, node2);
  }
}
function element$1(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    schema = svg;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = findComponentFromName(state, node2.tagName, false);
  const props = createElementProps(state, node2);
  let children = createChildren(state, node2);
  if (tableElements.has(node2.tagName)) {
    children = children.filter(function(child) {
      return typeof child === "string" ? !whitespace(child) : true;
    });
  }
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const program = node2.data.estree;
    const expression = program.body[0];
    ok$1(expression.type === "ExpressionStatement");
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateExpression(expression.expression)
    );
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  }
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.name === "svg" && parentSchema.space === "html") {
    schema = svg;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
  const props = createJsxElementProps(state, node2);
  const children = createChildren(state, node2);
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function root$1(state, node2, key) {
  const props = {};
  addChildren(props, createChildren(state, node2));
  return state.create(node2, state.Fragment, props, key);
}
function text$3(_, node2) {
  return node2.value;
}
function addNode(state, props, type, node2) {
  if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
    props.node = node2;
  }
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    if (value) {
      props.children = value;
    }
  }
}
function productionCreate(_, jsx, jsxs) {
  return create2;
  function create2(_2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const fn = isStaticChildren ? jsxs : jsx;
    return key ? fn(type, props, key) : fn(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create2;
  function create2(node2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const point2 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point2 ? point2.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point2 ? point2.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue;
  let prop;
  for (prop in node2.properties) {
    if (prop !== "children" && own$3.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key, value] = result;
        if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
          alignValue = value;
        } else {
          props[key] = value;
        }
      }
    }
  }
  if (alignValue) {
    const style = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "mdxJsxExpressionAttribute") {
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const program = attribute.data.estree;
        const expression = program.body[0];
        ok$1(expression.type === "ExpressionStatement");
        const objectExpression = expression.expression;
        ok$1(objectExpression.type === "ObjectExpression");
        const property = objectExpression.properties[0];
        ok$1(property.type === "SpreadElement");
        Object.assign(
          props,
          state.evaluater.evaluateExpression(property.argument)
        );
      } else {
        crashEstree(state, node2.position);
      }
    } else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value === "object") {
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const program = attribute.value.data.estree;
          const expression = program.body[0];
          ok$1(expression.type === "ExpressionStatement");
          value = state.evaluater.evaluateExpression(expression.expression);
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        value = attribute.value === null ? true : attribute.value;
      }
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  }
  return props;
}
function createChildren(state, node2) {
  const children = [];
  let index2 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index2 < node2.children.length) {
    const child = node2.children[index2];
    let key;
    if (state.passKeys) {
      const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
      if (name2) {
        const count = countsByName.get(name2) || 0;
        key = name2 + "-" + count;
        countsByName.set(name2, count + 1);
      }
    }
    const result = one$1(state, child, key);
    if (result !== void 0) children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify$1(value) : stringify(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, value) {
  const result = {};
  try {
    styleToObject(value, replacer);
  } catch (error) {
    if (!state.ignoreInvalidStyle) {
      const cause = (
        /** @type {Error} */
        error
      );
      const message = new VFileMessage("Cannot parse `style` attribute", {
        ancestors: state.ancestors,
        cause,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      message.file = state.filePath || void 0;
      message.url = docs + "#cannot-parse-style-attribute";
      throw message;
    }
  }
  return result;
  function replacer(name2, value2) {
    let key = name2;
    if (key.slice(0, 2) !== "--") {
      if (key.slice(0, 4) === "-ms-") key = "ms-" + key.slice(4);
      key = key.replace(dashSomething, toCamel);
    }
    result[key] = value2;
  }
}
function findComponentFromName(state, name$1, allowExpression) {
  let result;
  if (!allowExpression) {
    result = { type: "Literal", value: name$1 };
  } else if (name$1.includes(".")) {
    const identifiers = name$1.split(".");
    let index2 = -1;
    let node2;
    while (++index2 < identifiers.length) {
      const prop = name(identifiers[index2]) ? { type: "Identifier", name: identifiers[index2] } : { type: "Literal", value: identifiers[index2] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: Boolean(index2 && prop.type === "Literal"),
        optional: false
      } : prop;
    }
    result = node2;
  } else {
    result = name(name$1) && !/^[a-z]/.test(name$1) ? { type: "Identifier", name: name$1 } : { type: "Literal", value: name$1 };
  }
  if (result.type === "Literal") {
    const name2 = (
      /** @type {keyof JSX.IntrinsicElements} */
      result.value
    );
    return own$3.call(state.components, name2) ? state.components[name2] : name2;
  }
  if (state.evaluater) {
    return state.evaluater.evaluateExpression(result);
  }
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  message.file = state.filePath || void 0;
  message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
  throw message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from;
  for (from in domCasing) {
    if (own$3.call(domCasing, from)) {
      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from) {
  let to = from.replace(cap, toDash);
  if (to.slice(0, 3) === "ms-") to = "-" + to;
  return to;
}
function toCamel(_, $1) {
  return $1.toUpperCase();
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}
const urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
const emptyOptions$1 = {};
function toString$1(value, options) {
  const settings = emptyOptions$1;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values.length) {
    result[index2] = one(values[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}
const element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}
function splice(list2, start, remove, items) {
  const end = list2.length;
  let chunkStart = 0;
  let parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    list2.splice(...parameters);
  } else {
    if (remove) list2.splice(start, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      list2.splice(...parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
function push(list2, items) {
  if (list2.length > 0) {
    splice(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
        const value = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list2) {
  let index2 = -1;
  const before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  splice(existing, 0, 0, before);
}
function decodeNumericCharacterReference(value, base) {
  const code2 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return "";
  }
  return String.fromCodePoint(code2);
}
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const asciiAlpha = regexCheck(/[A-Za-z]/);
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < 32 || code2 === 127)
  );
}
const asciiDigit = regexCheck(/\d/);
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < -2;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < 0 || code2 === 32);
}
function markdownSpace(code2) {
  return code2 === -2 || code2 === -1 || code2 === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
const unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex2) {
  return check;
  function check(code2) {
    return code2 !== null && code2 > -1 && regex2.test(String.fromCharCode(code2));
  }
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code2 = value.charCodeAt(index2);
    let replace = "";
    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code2 < 56320 && next > 56319 && next < 57344) {
        replace = String.fromCharCode(code2, next);
        skip = 1;
      } else {
        replace = "";
      }
    } else {
      replace = String.fromCharCode(code2);
    }
    if (replace) {
      result.push(value.slice(start, index2), encodeURIComponent(replace));
      start = index2 + skip + 1;
      replace = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start);
}
function factorySpace(effects, ok2, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start;
  function start(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type);
      return prefix(code2);
    }
    return ok2(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type);
    return ok2(code2);
  }
}
const content$1 = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code2) {
    effects.enter("paragraph");
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}
const document$2 = {
  tokenize: initializeDocument
};
const containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start;
  function start(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point2 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code2);
    }
    return start(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === null) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending
          childFlow.events[index2][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index2][1].end || // or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point2;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point2 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point2);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok2, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function classifyCharacter(code2) {
  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return 1;
  }
  if (unicodePunctuation(code2)) {
    return 2;
  }
}
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text2;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
          }
          nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text2, context]]);
          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
          nextEvents = push(nextEvents, [["exit", text2, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start;
  function start(code2) {
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok2(code2);
  }
}
function movePoint(point2, offset) {
  point2.column += offset;
  point2.offset += offset;
  point2._bufferIndex += offset;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code2);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    if (code2 === 64) {
      return nok(code2);
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === 58) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === 64) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === 46) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code2);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok2;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
      const next = code2 === 45 ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok2, nok) {
  return start;
  function start(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
  }
  function after(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code2);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code2);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  const self2 = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok2, nok)(code2);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code2);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter("characterEscapeValue");
      effects.consume(code2);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code2);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  const self2 = this;
  let size = 0;
  let max2;
  let test;
  return start;
  function start(code2) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code2);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max2 = 31;
    test = asciiAlphanumeric;
    return value(code2);
  }
  function numeric(code2) {
    if (code2 === 88 || code2 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code2);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max2 = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max2 = 7;
    test = asciiDigit;
    return value(code2);
  }
  function value(code2) {
    if (code2 === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code2);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code2) && size++ < max2) {
      effects.consume(code2);
      return value;
    }
    return nok(code2);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
const codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start;
  function start(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code2);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok2(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code2);
  }
  function info(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code2);
    }
    if (code2 === 96 && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit("codeFenced");
    return ok2(code2);
  }
  function tokenizeCloseStart(effects2, ok3, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      effects2.enter("lineEnding");
      effects2.consume(code2);
      effects2.exit("lineEnding");
      return start2;
    }
    function start2(code2) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === null || markdownLineEnding(code2)) {
        effects2.exit("codeFencedFence");
        return ok3(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
const furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === null) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter("codeFlowValue");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("codeFlowValue");
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit("codeIndented");
    return ok2(code2);
  }
}
function tokenizeFurtherStart(effects, ok2, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
  }
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  let sizeOpen = 0;
  let size;
  let token;
  return start;
  function start(code2) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between(code2);
  }
  function between(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 32) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return between;
    }
    effects.enter("codeTextData");
    return data(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
      effects.exit("codeTextData");
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === 96) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code2);
    }
    token.type = "codeTextData";
    return data(code2);
  }
}
class SpliceBuffer {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index2) {
    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
      throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    }
    if (index2 < this.left.length) return this.left[index2];
    return this.right[this.right.length - index2 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start, stop);
    }
    if (start > this.left.length) {
      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
    }
    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start, deleteCount, items) {
    const count = deleteCount || 0;
    this.setCursor(Math.trunc(start));
    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n2) {
    if (n2 === this.left.length || n2 > this.left.length && this.right.length === 0 || n2 < 0 && this.left.length === 0) return;
    if (n2 < this.left.length) {
      const removed = this.left.splice(n2, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(this.left.length + this.right.length - n2, Number.POSITIVE_INFINITY);
      chunkedPush(this.left, removed.reverse());
    }
  }
}
function chunkedPush(list2, right) {
  let chunkStart = 0;
  if (right.length < 1e4) {
    list2.push(...right);
  } else {
    while (chunkStart < right.length) {
      list2.push(...right.slice(chunkStart, chunkStart + 1e4));
      chunkStart += 1e4;
    }
  }
}
function subtokenize(eventsArray) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events.get(index2);
    if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events.get(lineIndex)[1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index2 = -1;
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start = index2 + 1;
      breaks.push(start);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start2 = startPositions.pop();
    jumps.push([start2, start2 + slice2.length - 1]);
    events.splice(start2, 2, slice2);
  }
  jumps.reverse();
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === null) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code2);
  }
  function contentContinue(code2) {
    effects.consume(code2);
    effects.exit("chunkContent");
    previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code2) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok2(code2);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
  }
}
function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start;
  function start(code2) {
    if (code2 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === 60 || code2 === 62 || code2 === 92) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok2(code2);
    }
    if (balance < limit && code2 === 40) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === 41) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === 40 || code2 === 41 || code2 === 92) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start;
  function start(code2) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen) seen = !markdownSpace(code2);
    return code2 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === 91 || code2 === 92 || code2 === 93) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
  let marker;
  return start;
  function start(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === 40 ? 41 : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type);
      return ok2;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
      effects.exit("chunkString");
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === 92 ? escape2 : inside;
  }
  function escape2(code2) {
    if (code2 === marker || code2 === 92) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}
function factoryWhitespace(effects, ok2) {
  let seen;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start,
        seen ? "linePrefix" : "lineSuffix"
      )(code2);
    }
    return ok2(code2);
  }
}
const definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
const titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  const self2 = this;
  let identifier;
  return start;
  function start(code2) {
    effects.enter("definition");
    return before(code2);
  }
  function before(code2) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code2 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code2);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier);
      return ok2(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok2, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("hardBreakEscape");
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit("hardBreakEscape");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content2;
  let text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content2, context], ["enter", text2, context], ["exit", text2, context], ["exit", content2, context]]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  let size = 0;
  return start;
  function start(code2) {
    effects.enter("atxHeading");
    return before(code2);
  }
  function before(code2) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === 35 && size++ < 6) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === null || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("atxHeading");
      return ok2(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, "whitespace")(code2);
    }
    effects.enter("atxHeadingText");
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === 35) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
      effects.exit("atxHeadingText");
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
const htmlRawNames = ["pre", "script", "style", "textarea"];
const htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
const blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index2;
  let markerB;
  return start;
  function start(code2) {
    return before(code2);
  }
  function before(code2) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      marker = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      marker = 2;
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      if (index2 === value.length) {
        return self2.interrupt ? ok2 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === 47;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = 1;
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code2) : continuation(code2);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === null || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === 60 && marker === 1) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === 62 && marker === 4) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 63 && marker === 3) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === 93 && marker === 5) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code2);
    }
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
  }
  function continuationStartNonLazy(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter("htmlFlowData");
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === 62) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer.length < 8) {
      effects.consume(code2);
      buffer += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === 45 && marker === 2) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit("htmlFlow");
    return ok2(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter("lineEnding");
      effects.consume(code2);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok2(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok2, nok) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok2, nok);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start;
  function start(code2) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === 33) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === 47) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === 91) {
      effects.consume(code2);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 45) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === 45) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value = "CDATA[";
    if (code2 === value.charCodeAt(index2++)) {
      effects.consume(code2);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === 62) {
      return end(code2);
    }
    if (code2 === 93) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === null || code2 === 62) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === null) {
      return nok(code2);
    }
    if (code2 === 63) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === 62 ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === 45 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === 47) {
      effects.consume(code2);
      return end;
    }
    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === 61) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 34 || code2 === 39) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === null) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
      return nok(code2);
    }
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === 62) {
      effects.consume(code2);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter("htmlTextData");
    return returnState(code2);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
const resourceConstruct = {
  tokenize: tokenizeResource
};
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text2 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [["enter", group, context], ["enter", label, context]];
  media = push(media, events.slice(open + 1, open + offset + 3));
  media = push(media, [["enter", text2, context]]);
  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
  media = push(media, [["exit", text2, context], events[close - 2], events[close - 1], ["exit", label, context]]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code2) {
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    })));
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code2) {
    if (code2 === 40) {
      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
    }
    if (code2 === 91) {
      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
  }
  function labelEndOk(code2) {
    return ok2(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return resourceStart;
  function resourceStart(code2) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code2);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === 41) {
      return resourceEnd(code2);
    }
    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === 34 || code2 === 39 || code2 === 40) {
      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code2);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok2, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code2) {
    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
  }
  function referenceFullAfter(code2) {
    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok2(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok2, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code2);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code2);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code2);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code2);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code2) {
    if (code2 === 91) {
      effects.enter("labelMarker");
      effects.consume(code2);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  const self2 = this;
  return start;
  function start(code2) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code2);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code2) {
    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code2) {
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    return factorySpace(effects, ok2, "linePrefix");
  }
}
const thematicBreak$1 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  let size = 0;
  let marker;
  return start;
  function start(code2) {
    effects.enter("thematicBreak");
    return before(code2);
  }
  function before(code2) {
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code2);
    }
    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
      effects.exit("thematicBreak");
      return ok2(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
  }
}
const list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
const indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start;
  function start(code2) {
    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self2.interrupt || code2 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    if (asciiDigit(code2) && ++size < 10) {
      effects.consume(code2);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    effects.enter("listItemMarker");
    effects.consume(code2);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
    );
  }
  function onBlank(code2) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code2);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok2(code2);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code2);
  }
  function notBlank(code2) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(effects, effects.attempt(list$1, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  const self2 = this;
  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
  function afterPrefix(code2) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content2;
  let text2;
  let definition2;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text2][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
    events[content2][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content2][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  const self2 = this;
  let marker;
  return start;
  function start(code2) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter("setextHeadingLineSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === null || markdownLineEnding(code2)) {
      effects.exit("setextHeadingLine");
      return ok2(code2);
    }
    return nok(code2);
  }
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code2);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    if (code2 === null) {
      effects.consume(code2);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code2);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory("string");
const text$2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code2) {
      return atBreak(code2) ? text2(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === null) {
        effects.consume(code2);
        return;
      }
      effects.enter("data");
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit("data");
        return text2(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === null) {
        return true;
      }
      const list2 = constructs2[code2];
      let index2 = -1;
      if (list2) {
        while (++index2 < list2.length) {
          const item = list2[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
function createTokenizer(parser, initialize, from) {
  let point2 = Object.assign(
    from ? Object.assign({}, from) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice2) {
    chunks = push(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line, column, offset, _index, _bufferIndex } = point2;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point2._index < chunks.length) {
      const chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    state = state(code2);
  }
  function consume(code2) {
    if (markdownLineEnding(code2)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code2 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code2 !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context.previous = code2;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map) {
        return start;
        function start(code2) {
          const def = code2 !== null && map[code2];
          const all2 = code2 !== null && map.null;
          const list2 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list2)(code2);
        }
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        if (list2.length === 0) {
          return bogusState;
        }
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok();
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok2,
            nok
          )(code2);
        }
      }
      function ok2(code2) {
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point2 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};
const contentInitial = {
  [91]: definition
};
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};
const string = {
  [38]: characterReference,
  [92]: characterEscape
};
const text$1 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
const insideSpan = {
  null: [attention, resolver]
};
const attentionMarkers = {
  null: [42, 95]
};
const disable = {
  null: []
};
const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$1
}, Symbol.toStringTag, { value: "Module" }));
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content$1),
    document: create2(document$2),
    flow: create2(flow$1),
    string: create2(string$1),
    text: create2(text$2)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code2 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next) chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(-5);
      if (buffer) chunks.push(buffer);
      chunks.push(null);
    }
    return chunks;
  }
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}
const own$2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list2, onenterlistordered),
      listUnordered: opener(list2),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own$2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(Object.assign({
          sliceSerialize: events[index2][2].sliceSerialize
        }, context), events[index2][1]);
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point(events.length > 0 ? events[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point(events.length > 0 ? events[events.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    let index2 = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      switch (event[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case "lineEndingBlank": {
          if (event[0] === "enter") {
            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index2;
            }
            atMarker = void 0;
          }
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace": {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem3 = item;
          events.splice(index2, 0, ["enter", item, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
        start: token.start,
        end: token.end
      }) + "): its not open");
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point(token.end);
  }
  function resume() {
    return toString$1(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = {
        start: point(token.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string2 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string2);
    ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
  }
  function onexitlabel() {
    const fragment2 = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment2.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    tail.position.end = point(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text2() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak2() {
    return {
      type: "thematicBreak"
    };
  }
}
function point(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own$2.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
      start: left.start,
      end: left.end
    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is open");
  } else {
    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
      start: right.start,
      end: right.end
    }) + ") is still open");
  }
}
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id2 = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id2.toLowerCase());
  const index2 = state.footnoteOrder.indexOf(id2);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id2);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id2);
    counter = state.footnoteOrder.length;
  } else {
    counter = index2 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id2, reuseCounter);
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function html(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}
function imageReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id2);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties.title = definition2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function inlineCode(state, node2) {
  const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text2);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text2]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function linkReference(state, node2) {
  const id2 = String(node2.identifier).toUpperCase();
  const definition2 = state.definitionById.get(id2);
  if (!definition2) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition2.url || "") };
  if (definition2.title !== null && definition2.title !== void 0) {
    properties.title = definition2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index2 = -1;
  while (++index2 < results.length) {
    const child = results[index2];
    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index2 = -1;
    while (!loose && ++index2 < children.length) {
      loose = listItemLoose(children[index2]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}
function list(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index2 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index2 < results.length) {
    const child = results[index2];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start && end) body.position = { start, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const tab = 9;
const space = 32;
function trimLines(value) {
  const source = String(value);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last = 0;
  const lines = [];
  while (match) {
    lines.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines.push(trimLine(source.slice(last), last > 0, false));
  return lines.join("");
}
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;
  if (start) {
    let code2 = value.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
}
function text(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function thematicBreak(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
const handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}
const VOID = -1;
const PRIMITIVE = 0;
const ARRAY = 1;
const OBJECT = 2;
const DATE = 3;
const REGEXP = 4;
const MAP = 5;
const SET = 6;
const ERROR = 7;
const BIGINT = 8;
const env = typeof self === "object" ? self : globalThis;
const deserializer = ($, _) => {
  const as = (out, index2) => {
    $.set(index2, out);
    return out;
  };
  const unpair = (index2) => {
    if ($.has(index2))
      return $.get(index2);
    const [type, value] = _[index2];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index2);
      case ARRAY: {
        const arr = as([], index2);
        for (const index3 of value)
          arr.push(unpair(index3));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index2);
        for (const [key, index3] of value)
          object[unpair(key)] = unpair(index3);
        return object;
      }
      case DATE:
        return as(new Date(value), index2);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index2);
      }
      case MAP: {
        const map = as(/* @__PURE__ */ new Map(), index2);
        for (const [key, index3] of value)
          map.set(unpair(key), unpair(index3));
        return map;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index2);
        for (const index3 of value)
          set.add(unpair(index3));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as(new env[name2](message), index2);
      }
      case BIGINT:
        return as(BigInt(value), index2);
      case "BigInt":
        return as(Object(BigInt(value)), index2);
    }
    return as(new env[type](value), index2);
  };
  return unpair;
};
const deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
const EMPTY = "";
const { toString } = {};
const { keys } = Object;
const typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
const shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
const serializer = (strict, json, $, _) => {
  const as = (out, value) => {
    const index2 = _.push(out) - 1;
    $.set(value, index2);
    return index2;
  };
  const pair = (value) => {
    if ($.has(value))
      return $.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type)
          return as([type, [...value]], value);
        const arr = [];
        const index2 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index2;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index2;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index2;
      }
      case SET: {
        const entries = [];
        const index2 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index2;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
const serialize = (value, { json, lossy } = {}) => {
  const _ = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
};
const structuredClone$1 = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));
function defaultFootnoteBackContent(_, rereferenceIndex) {
  const result = [{ type: "text", value: "" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition2 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition2) {
      continue;
    }
    const content2 = state.all(definition2);
    const id2 = String(definition2.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id2);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content2[content2.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content2.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content2, true)
    };
    state.patch(definition2, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...structuredClone$1(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}
const convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks2[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all2);
  function all2(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index2, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index2 === "number" ? index2 : void 0,
        parent || void 0
      )
    );
  }
}
function ok() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}
function color(d) {
  return d;
}
const empty = [];
const CONTINUE = true;
const EXIT = false;
const SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index2, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit2, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit2;
    function visit2() {
      let result = empty;
      let subresult;
      let offset;
      let grandparents;
      if (!test || is(node2, index2, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset > -1 && offset < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset];
            subresult = factory(child, offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty : [value];
}
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index2 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index2, parent);
  }
}
const own$1 = {}.hasOwnProperty;
const emptyOptions = {};
function createState(tree, options) {
  const settings = options || emptyOptions;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers$1 = { ...handlers, ...settings.handlers };
  const state = {
    all: all2,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers$1,
    one: one2,
    options: settings,
    patch,
    wrap: wrap$1
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map = node2.type === "definition" ? definitionById : footnoteById;
      const id2 = String(node2.identifier).toUpperCase();
      if (!map.has(id2)) {
        map.set(id2, node2);
      }
    }
  });
  return state;
  function one2(node2, parent) {
    const type = node2.type;
    const handle = state.handlers[type];
    if (own$1.call(state.handlers, type) && handle) {
      return handle(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = structuredClone$1(shallow);
        result.children = state.all(node2);
        return result;
      }
      return structuredClone$1(node2);
    }
    const unknown = state.options.unknownHandler || defaultUnknownHandler;
    return unknown(state, node2, parent);
  }
  function all2(parent) {
    const values = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index2 = -1;
      while (++index2 < nodes.length) {
        const result = state.one(nodes[index2], parent);
        if (result) {
          if (index2 && nodes[index2 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values.push(...result);
          } else {
            values.push(result);
          }
        }
      }
    }
    return values;
  }
}
function patch(from, to) {
  if (from.position) to.position = position$1(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, structuredClone$1(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own$1.call(data, "hProperties") || own$1.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap$1(nodes, loose) {
  const result = [];
  let index2 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index2 < nodes.length) {
    if (index2) result.push({ type: "text", value: "\n" });
    result.push(nodes[index2]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index2 = 0;
  let code2 = value.charCodeAt(index2);
  while (code2 === 9 || code2 === 32) {
    index2++;
    code2 = value.charCodeAt(index2);
  }
  return value.slice(index2);
}
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}
function bail(error) {
  if (error) {
    throw error;
  }
}
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject$1 = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key;
  for (key in obj) {
  }
  return typeof key === "undefined" || hasOwn.call(obj, key);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty && options.name === "__proto__") {
    defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend = function extend2() {
  var options, name2, src, copy, copyIsArray, clone;
  var target = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length; ++i) {
    options = arguments[i];
    if (options != null) {
      for (name2 in options) {
        src = getProperty(target, name2);
        copy = getProperty(options, name2);
        if (target !== copy) {
          if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && isArray(src) ? src : [];
            } else {
              clone = src && isPlainObject$1(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) });
          } else if (typeof copy !== "undefined") {
            setProperty(target, { name: name2, newValue: copy });
          }
        }
      }
    }
  }
  return target;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function trough() {
  const fns = [];
  const pipeline = { run, use };
  return pipeline;
  function run(...values) {
    let middlewareIndex = -1;
    const callback = values.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values[index2];
        }
      }
      values = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}
const minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path);
  let start = 0;
  let end = -1;
  let index2 = path.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path.length) {
    while (index2--) {
      if (path.codePointAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path.slice(start, end);
  }
  if (extname2 === path) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index2--) {
    if (path.codePointAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extnameIndex > -1) {
        if (path.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index2;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path.length;
  }
  return path.slice(start, end);
}
function dirname(path) {
  assertPath$1(path);
  if (path.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path.length;
  let unmatchedSlash;
  while (--index2) {
    if (path.codePointAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path.codePointAt(0) === 47 ? "/" : "." : end === 1 && path.codePointAt(0) === 47 ? "//" : path.slice(0, end);
}
function extname(path) {
  assertPath$1(path);
  let index2 = path.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code2 = path.codePointAt(index2);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath$1(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path) {
  assertPath$1(path);
  const absolute = path.codePointAt(0) === 47;
  let value = normalizeString(path, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path.codePointAt(path.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code2;
  let lastSlashIndex;
  while (++index2 <= path.length) {
    if (index2 < path.length) {
      code2 = path.codePointAt(index2);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path.slice(lastSlash + 1, index2);
        } else {
          result = path.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path) {
  if (typeof path !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path)
    );
  }
}
const minproc = { cwd };
function cwd() {
  return "/";
}
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}
function urlToPath(path) {
  if (typeof path === "string") {
    path = new URL(path);
  } else if (!isUrl(path)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
      const third = pathname.codePointAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array$1(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index2 = -1;
    while (++index2 < order.length) {
      const field2 = order[index2];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path) {
    if (isUrl(path)) {
      path = urlToPath(path);
    }
    assertNonEmpty(path, "path");
    if (this.path !== path) {
      this.history.push(path);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
}
function assertPart(part, name2) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path, name2) {
  if (!path) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array$1(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto);
    return apply;
  }
);
const own = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let index2 = -1;
    while (++index2 < this.attachers.length) {
      const attacher = this.attachers[index2];
      destination.use(...attacher);
    }
    destination.data(extend$1(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree, realFile, function(error, tree, file2) {
        if (error || !tree || !file2) {
          return realDone(error);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    return result;
    function realDone(error, file2) {
      complete = true;
      bail(error);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    return result;
    function realDone(error, tree2) {
      bail(error);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) ;
    else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = extend$1(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) ;
      else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index2 = -1;
      let entryIndex = -1;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entryIndex = index2;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject2(currentPrimary) && isPlainObject2(primary)) {
          primary = extend$1(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array(value);
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
const emptyPlugins = [];
const emptyRemarkRehypeOptions = { allowDangerousHtml: true };
const safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
const deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const allowedElements = options.allowedElements;
  const allowElement = options.allowElement;
  const children = options.children || "";
  const className = options.className;
  const components = options.components;
  const disallowedElements = options.disallowedElements;
  const rehypePlugins = options.rehypePlugins || emptyPlugins;
  const remarkPlugins = options.remarkPlugins || emptyPlugins;
  const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  const skipHtml = options.skipHtml;
  const unwrapDisallowed = options.unwrapDisallowed;
  const urlTransform = options.urlTransform || defaultUrlTransform;
  const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
  const file = new VFile();
  if (typeof children === "string") {
    file.value = children;
  }
  for (const deprecation of deprecations) {
    if (Object.hasOwn(options, deprecation.from)) {
      unreachable(
        "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
      );
    }
  }
  const mdastTree = processor.parse(file);
  let hastTree = processor.runSync(mdastTree, file);
  if (className) {
    hastTree = {
      type: "element",
      tagName: "div",
      properties: { className },
      // Assume no doctypes.
      children: (
        /** @type {Array<ElementContent>} */
        hastTree.type === "root" ? hastTree.children : [hastTree]
      )
    };
  }
  visit(hastTree, transform);
  return toJsxRuntime(hastTree, {
    Fragment: jsxRuntimeExports.Fragment,
    components,
    ignoreInvalidStyle: true,
    jsx: jsxRuntimeExports.jsx,
    jsxs: jsxRuntimeExports.jsxs,
    passKeys: true,
    passNode: true
  });
  function transform(node2, index2, parent) {
    if (node2.type === "raw" && parent && typeof index2 === "number") {
      if (skipHtml) {
        parent.children.splice(index2, 1);
      } else {
        parent.children[index2] = { type: "text", value: node2.value };
      }
      return index2;
    }
    if (node2.type === "element") {
      let key;
      for (key in urlAttributes) {
        if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
          const value = node2.properties[key];
          const test = urlAttributes[key];
          if (test === null || test.includes(node2.tagName)) {
            node2.properties[key] = urlTransform(String(value || ""), key, node2);
          }
        }
      }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
      if (!remove && allowElement && typeof index2 === "number") {
        remove = !allowElement(node2, index2, parent);
      }
      if (remove && parent && typeof index2 === "number") {
        if (unwrapDisallowed && node2.children) {
          parent.children.splice(index2, 1, ...node2.children);
        } else {
          parent.children.splice(index2, 1);
        }
        return index2;
      }
    }
  }
}
function defaultUrlTransform(value) {
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (
    // If there is no protocol, its relative.
    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon))
  ) {
    return value;
  }
  return "";
}
class ZZCSpeechRecognition {
  constructor({ interimResults = false, baseUrl, apiKey, silenceThreshold = 15, silenceDetectionTime = 3e3 } = {}) {
    this.onstart = null;
    this.onend = null;
    this.onresult = null;
    this.onerror = null;
    this.interimResults = interimResults;
    this.mediaRecorder = null;
    this.recordedChunks = [];
    this.isRecording = false;
    this.audioContext = null;
    this.silenceTimeout = null;
    this.silenceDetectionTime = silenceDetectionTime;
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
    this.silenceThreshold = silenceThreshold;
  }
  async start() {
    if (this.isRecording) return;
    this.recordedChunks = [];
    this.isRecording = true;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(stream);
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = this.audioContext.createMediaStreamSource(stream);
      const analyser = this.audioContext.createAnalyser();
      analyser.fftSize = 512;
      source.connect(analyser);
      this.detectSilence(analyser);
      this.mediaRecorder.onstart = () => {
        if (typeof this.onstart === "function") {
          this.onstart();
        }
      };
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = async () => {
        this.isRecording = false;
        try {
          const audioBlob = new Blob(this.recordedChunks, { type: "audio/webm" });
          const wavBlob = await this.convertToWav(audioBlob);
          const recognizedText = await this.sendToSpeechAPI(wavBlob);
          if (typeof this.onresult === "function") {
            this.onresult({ transcript: recognizedText, audioBlob: wavBlob });
          }
        } catch (error) {
          if (typeof this.onerror === "function") {
            this.onerror(error);
          }
        }
        if (typeof this.onend === "function") {
          this.onend();
        }
      };
      this.mediaRecorder.start();
    } catch (error) {
      if (typeof this.onerror === "function") {
        this.onerror(error);
      }
    }
  }
  stop() {
    if (this.isRecording && this.mediaRecorder) {
      this.mediaRecorder.stop();
    }
    clearTimeout(this.silenceTimeout);
  }
  abort() {
    if (this.isRecording && this.mediaRecorder) {
      this.mediaRecorder.stop();
      if (typeof this.onend === "function") {
        this.onend();
      }
      clearTimeout(this.silenceTimeout);
    }
  }
  // Silence detection logic
  detectSilence(analyser) {
    const dataArray2 = new Uint8Array(analyser.fftSize);
    const checkForSilence = () => {
      analyser.getByteFrequencyData(dataArray2);
      const volume = dataArray2.reduce((sum, value) => sum + value, 0) / dataArray2.length;
      console.debug(`debug: volume = ${volume}`);
      if (volume < this.silenceThreshold) {
        if (!this.silenceTimeout) {
          this.silenceTimeout = setTimeout(() => {
            this.stop();
          }, this.silenceDetectionTime);
        }
      } else {
        clearTimeout(this.silenceTimeout);
        this.silenceTimeout = null;
      }
      if (this.isRecording) {
        requestAnimationFrame(checkForSilence);
      }
    };
    requestAnimationFrame(checkForSilence);
  }
  // Function to convert WebM/OGG to WAV
  async convertToWav(audioBlob) {
    return new Promise((resolve, reject) => {
      const fileReader = new FileReader();
      fileReader.onload = (event) => {
        const arrayBuffer = event.target.result;
        const audioContext = new AudioContext();
        audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
          const wavBlob = this.audioBufferToWav(audioBuffer);
          resolve(wavBlob);
        }, reject);
      };
      fileReader.onerror = reject;
      fileReader.readAsArrayBuffer(audioBlob);
    });
  }
  audioBufferToWav(buffer) {
    let numOfChan = buffer.numberOfChannels, length = buffer.length * numOfChan * 2 + 44, bufferView = new DataView(new ArrayBuffer(length)), channels = [], offset = 0, pos = 0;
    this.writeString(bufferView, pos, "RIFF");
    pos += 4;
    bufferView.setUint32(pos, length - 8, true);
    pos += 4;
    this.writeString(bufferView, pos, "WAVE");
    pos += 4;
    this.writeString(bufferView, pos, "fmt ");
    pos += 4;
    bufferView.setUint32(pos, 16, true);
    pos += 4;
    bufferView.setUint16(pos, 1, true);
    pos += 2;
    bufferView.setUint16(pos, numOfChan, true);
    pos += 2;
    bufferView.setUint32(pos, buffer.sampleRate, true);
    pos += 4;
    bufferView.setUint32(pos, buffer.sampleRate * 2 * numOfChan, true);
    pos += 4;
    bufferView.setUint16(pos, numOfChan * 2, true);
    pos += 2;
    bufferView.setUint16(pos, 16, true);
    pos += 2;
    this.writeString(bufferView, pos, "data");
    pos += 4;
    bufferView.setUint32(pos, length - pos - 4, true);
    pos += 4;
    for (let i = 0; i < buffer.numberOfChannels; i++) channels.push(buffer.getChannelData(i));
    while (pos < length) {
      for (let i = 0; i < numOfChan; i++) {
        bufferView.setInt16(pos, channels[i][offset] * 32767, true);
        pos += 2;
      }
      offset++;
    }
    return new Blob([bufferView], { type: "audio/wav" });
  }
  writeString(view, offset, string2) {
    for (let i = 0; i < string2.length; i++) {
      view.setUint8(offset + i, string2.charCodeAt(i));
    }
  }
  // Function to send the audio to Azure's Speech-to-Text API
  async sendToSpeechAPI(wavBlob) {
    const url = `${this.baseUrl}/stt`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "x-api-key": this.apiKey
      },
      body: wavBlob
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API request failed with status: ${response.status}, message: ${errorText}`);
    }
    const data = await response.json();
    if (data.NBest && data.NBest.length > 0) {
      return data.NBest[0].Display;
    } else {
      return "No speech recognized.";
    }
  }
}
const Button = React.forwardRef(
  ({ className, variant = "default", ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: `px-4 py-2 rounded-md font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 ${variant === "default" ? "bg-primary text-primary-foreground hover:bg-primary/90" : "bg-destructive text-destructive-foreground hover:bg-destructive/90"} ${className}`,
        ref,
        ...props
      }
    );
  }
);
Button.displayName = "Button";
const Input = React.forwardRef(
  ({ className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        className: `flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 ${className}`,
        ref,
        ...props
      }
    );
  }
);
Input.displayName = "Input";
function AvatarChat() {
  const [input, setInput] = reactExports.useState("");
  const [messages, setMessages] = reactExports.useState([]);
  const [isListening, setIsListening] = reactExports.useState(false);
  const recognitionRef = reactExports.useRef(null);
  const avatarRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    recognitionRef.current = new ZZCSpeechRecognition({
      interimResults: false,
      baseUrl: "https://api.zzcreation.com/web",
      apiKey: "0f4404a5f9f56",
      silenceDetectionTime: 1500
    });
    recognitionRef.current.onresult = (result) => {
      if (result.transcript.trim()) {
        setMessages((prev) => [...prev, { type: "user", content: result.transcript }]);
        queryInput(result.transcript);
      }
    };
    recognitionRef.current.onend = () => {
      setIsListening(false);
    };
  }, []);
  const queryInput = (message) => {
    const credentials = btoa("zzc-test:123456");
    fetch("https://app.zzcreation.com/draw/generate-image/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Basic ${credentials}`
        // Use Basic Auth
      },
      body: JSON.stringify({
        prompt: message,
        session_id: "4"
        // You might want to generate a unique session ID
      })
    }).then((response) => response.json()).then((data) => {
      var _a2;
      setMessages((prev) => [
        ...prev,
        {
          type: "avatar",
          content: data.answer
          // imageUrl: data.urls[0] // Assuming the first URL is the one we want
        }
      ]);
      (_a2 = avatarRef.current) == null ? void 0 : _a2.speak(data.answer.replace(/https?:\/\/\S+/g, "").trim());
    }).catch((error) => {
      console.error("Error:", error);
      setMessages((prev) => [...prev, { type: "avatar", content: "Sorry, I couldn't generate an image." }]);
    });
  };
  const handleSend = () => {
    if (input.trim()) {
      setMessages((prev) => [...prev, { type: "user", content: input }]);
      queryInput(input);
      setInput("");
    }
  };
  const toggleListening = () => {
    var _a2, _b2;
    if (isListening) {
      (_a2 = recognitionRef.current) == null ? void 0 : _a2.stop();
    } else {
      (_b2 = recognitionRef.current) == null ? void 0 : _b2.start();
    }
    setIsListening(!isListening);
  };
  const memorizedMessages = reactExports.useMemo(() => {
    return messages.map((message, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex ${message.type === "user" ? "justify-end" : "justify-start"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `rounded-lg p-2 max-w-xs ${message.type === "user" ? "bg-blue-500 text-white" : "bg-white"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Markdown,
      {
        children: message.content,
        components: {
          img: ({ node: node2, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "max-w-full h-auto rounded-lg", ...props })
        }
      }
    ) }) }, index2));
  }, [messages]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row h-screen bg-gray-100", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-3/5 flex justify-center items-center bg-gray-500", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { ref: avatarRef }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-2/5 flex flex-col justify-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-auto p-4 space-y-4", children: memorizedMessages }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 bg-white border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            value: input,
            onChange: (e) => setInput(e.target.value),
            onKeyDown: (e) => {
              if (e.key === "Enter") {
                handleSend();
              }
            },
            placeholder: "",
            className: "flex-1"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleSend, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Send, { className: "w-4 h-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Send" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: toggleListening, variant: isListening ? "destructive" : "default", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Mic, { className: "w-4 h-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Toggle speech recognition" })
        ] })
      ] }) })
    ] })
  ] });
}
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarChat, {}) })
);
//# sourceMappingURL=index-BrCWDpJ_.js.map
